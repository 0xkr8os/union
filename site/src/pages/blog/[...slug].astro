---
import { Image } from "astro:assets"
import Layout from "#/layouts/Layout.astro"
import type { BlogPost } from "#/lib/types.ts"
import LanderSection from "#/components/LanderSection.astro"
import { toISODate, saneDateTime } from "#/lib/utilities.ts"
import { BLOCKS, INLINES } from "@contentful/rich-text-types"
import { contentfulClient } from "#/lib/contentful/client.ts"
import SocialsSection from "#/components/sections/SocialsSection.astro"
import { documentToHtmlString } from "@contentful/rich-text-html-renderer"

export const prerender = false

const { slug } = Astro.params

const {
  items: [blogPost]
} = await contentfulClient.getEntries<BlogPost>({
  limit: 1,
  "fields.slug": slug,
  content_type: "blog",
  select: [
    "sys.id", // entry id
    "fields.date",
    "fields.slug",
    "fields.date",
    "fields.title",
    "fields.cover",
    "fields.author",
    "fields.content",
    "fields.description"
  ]
})

// The browser should always check freshness
Astro.response.headers.set("cache-control", "public, max-age=0, must-revalidate")

// The CDN should cache for a year, but revalidate if the cache tag changes
Astro.response.headers.set("netlify-cdn-cache-control", "s-maxage=31536000")

// Tag the page with the blog post slug
if (slug) Astro.response.headers.set("netlify-cache-tag", slug)

const imageWithProtocol = (url: string) => `https:${url}`

const entryId = blogPost.sys.id

// @ts-expect-error
const coverFields = blogPost.fields.cover.fields
const imageUrl = imageWithProtocol(coverFields.file.url)
const { width, height } = coverFields.file.details.image as {
  width: number
  height: number
}
---

<Layout
  image={imageUrl}
  url={Astro.url.href}
  title={blogPost.fields.title}
  description={blogPost.fields.description}
>
  <LanderSection gradient="to-t">
    <div class="max-w-2xl self-center md:text-lg text-gray-300">
      <div class="text-lg flex gap-x-3 h-min">
        <time
          class="text-lg text-gray-400"
          data-contentful-field-id="date"
          data-contentful-entry-id={entryId}
          datetime={toISODate(blogPost.fields.date)}
        >
          {saneDateTime(blogPost.fields.date)}
        </time>
        <p
          class="hidden"
          data-contentful-field-id="author"
          data-contentful-entry-id={entryId}
        >
          {blogPost.fields.author}
        </p>
      </div>
      <h1
        data-contentful-field-id="title"
        data-contentful-entry-id={entryId}
        class="text-3xl sm:text-4xl font-extrabold mb-0"
      >
        {blogPost.fields.title}
      </h1>
      <Image
        {width}
        {height}
        class="my-3"
        loading="eager"
        src={imageUrl}
        alt={coverFields.title}
        data-contentful-field-id="cover"
        data-contentful-entry-id={entryId}
      />
      <p>
        <em
          data-contentful-entry-id={entryId}
          data-contentful-field-id="description"
        >
          {blogPost.fields.description}
        </em>
      </p>
      <article
        data-contentful-field-id="content"
        data-contentful-entry-id={entryId}
      >
      </article>
      <article
        set:html={documentToHtmlString(blogPost.fields.content, {
          renderNode: {
            [BLOCKS["EMBEDDED_ASSET"]]: (asset) => {
              const dataFields = asset.data.target.fields
              const imageUrl = imageWithProtocol(dataFields.file.url)
              const { width, height } = dataFields.file.details.image
              return `<Image src="${imageUrl}" alt="${dataFields.title}" width={${width}} height={${height}} />`
            },
            [INLINES["HYPERLINK"]]: (params) => /* html */ `
              <a 
                target="_blank"
                href="${params.data.uri}"
                rel="noopener noreferrer">${(params.content.at(0) as any)?.value}</a>`
          }
        })}
      />
    </div>
  </LanderSection>
  <SocialsSection />
</Layout>

<script>
  // @ts-expect-error
  import * as contentful from "contentful/browser"
  import { ContentfulLivePreview } from "@contentful/live-preview"

  type ConfigOptions = {
    locale: string
    entryId: string
    debugMode: boolean
    fields: Array<string>
    subscriptions: Array<VoidFunction>
  }

  document.addEventListener("DOMContentLoaded", () => {
    const emElement = document.querySelector("em[data-contentful-entry-id]")
    const entryId = emElement?.dataset.contentfulEntryId
    if (!entryId) return
    initializeContentfulLivePreview({
      entryId,
      locale: "en-US",
      debugMode: true,
      subscriptions: [],
      fields: [
        "date",
        "date",
        "title",
        "cover",
        "author",
        "content",
        "description"
      ]
    })
  })

  function initializeContentfulLivePreview({
    locale,
    fields,
    entryId,
    debugMode,
    subscriptions
  }: ConfigOptions) {
    const contentfulClient = contentful.createClient({
      space: "pf7z332xkown",
      host: "preview.contentful.com",
      /**
       * this token will be revoked before porting to own repo
       */
      accessToken: "Du9sF4eDPHdNyXN7hZTeWyyEB6tV7i2BuOyvUbrE-Uo"
    })
    ContentfulLivePreview.init({
      locale,
      debugMode,
      enableLiveUpdates: true,
      enableInspectorMode: true,
      targetOrigin: "https://app.contentful.com"
    })

    contentfulClient
      .getEntry(entryId)
      .then((entry: any) => {
        console.info("[initializeContentfulLivePreview.contentful]", entry)
        fields.forEach((fieldId) => {
          displayFieldData({
            entry,
            client: contentfulClient,
            fieldId,
            entryId
          })
          setupLivePreview({ entry, fieldId, entryId, subscriptions })
        })
      })
      .catch((error: any) =>
        console.error(`[initializeContentfulLivePreview]`, error)
      )
  }

  function setupLivePreview({
    entry,
    entryId,
    fieldId,
    subscriptions
  }: {
    entry: any
    entryId: string
    fieldId: string
    subscriptions: Array<VoidFunction>
  }) {
    const callback = (updatedData: any) => {
      const domElement = findElementByDataAttribute({ entryId, fieldId })
      if (domElement && updatedData.fields && updatedData.fields[fieldId]) {
        // Check if the content is text
        if (typeof updatedData.fields[fieldId] === "string") {
          domElement.textContent = updatedData.fields[fieldId]
        }
      }
    }
    const unsubscribe = ContentfulLivePreview.subscribe({
      callback,
      data: entry,
      locale: "en-US"
    })

    subscriptions.push(unsubscribe)
  }

  function findElementByDataAttribute({
    entryId,
    fieldId
  }: {
    entryId: string
    fieldId: string
  }) {
    if (typeof document === "undefined") return
    return document.querySelector(
      `[data-contentful-entry-id="${entryId}"][data-contentful-field-id="${fieldId}"]`
    )
  }

  function displayFieldData({
    entry,
    client,
    fieldId,
    entryId
  }: {
    entry: any
    client: any
    fieldId: string
    entryId: string
  }) {
    const domElement = findElementByDataAttribute({ entryId, fieldId })

    if (!domElement) {
      console.error(
        `DOM element with entry ID "${entryId}" and field ID "${fieldId}" not found.`
      )
      return
    }

    if (typeof document === "undefined") return
    domElement.textContent = entry.fields[fieldId]
  }
</script>

<script is:inline type="module" src="/scripts/anchor-targets.js"></script>

<style is:inline lang="postcss">
  h1 {
    color: white !important; 
  }
  img {
    width: 100%;
    height: auto;
    object-fit: cover;
    border-radius: 8px !important;
  }

  p > a, ul a:not(header a), ol a:not(header a) {
    text-decoration: underline;
    text-decoration-color: #A0ECFD !important;
    transition: border-bottom-color 0.2s ease-in-out;
    color: #A0ECFD !important;
  }

  p, q, blockquote {
    margin-bottom: 1rem;
    color: #D1D5DB;
  }


  p > a:hover {
    color: #A0ECFD;
  }

  ol, ul {
    li {
      color: #D1D5DB;
    }
    margin-bottom: 1rem;
  }
  @media (max-width: 640px) {
    p > a:hover {
      color: #A0ECFD;
      text-decoration-color: #fff !important;
    }
    h2 {
      font-size: 1.5rem !important;
    }
  }

  h2,h3,h4,h5 {
    margin-top: 2rem;
    margin-bottom: 0rem;
    font-size: 1.87rem;
    color: #ffffff;
  }

  h2::after, h3::after, h4::after, h5::after {
    content: "#";
    color: #ffffff;
    margin-left: 0.5rem;
    font-size: 1.5rem;
    position: relative;
    visibility: hidden;
  }

  h2:hover::after, h3:hover::after, h4:hover::after, h5:hover::after {
    visibility: visible;
  }

  *::selection {
    background-color: #A0ECFD;
    color: #000;
  }
</style>
