{
  "openapi": "3.0.3",
  "info": {
    "title": "Union Node REST API",
    "version": "0.0.1"
  },
  "servers": [
    {
      "url": "http://localhost:1317"
    }
  ],
  "paths": {
    "/cosmos/auth/v1beta1/account_info/{address}": {
      "get": {
        "description": "AccountInfo queries account info which is common to all account types.\n\n Since: cosmos-sdk 0.47",
        "operationId": "Query_AccountInfo",
        "parameters": [
          {
            "description": "address is the account address string.",
            "explode": false,
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryAccountInfoResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/auth/v1beta1/accounts": {
      "get": {
        "description": "Accounts returns all the existing accounts.\n\n When called from another module, this query might consume a high amount of\n gas if the pagination field is incorrectly set.\n\n Since: cosmos-sdk 0.43",
        "operationId": "Query_Accounts",
        "parameters": [
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryAccountsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/auth/v1beta1/accounts/{address}": {
      "get": {
        "description": "Account returns account details based on address.",
        "operationId": "Query_Account",
        "parameters": [
          {
            "description": "address defines the address to query for.",
            "explode": false,
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryAccountResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/auth/v1beta1/address_by_id/{id}": {
      "get": {
        "description": "AccountAddressByID returns account address based on account number.\n\n Since: cosmos-sdk 0.46.2",
        "operationId": "Query_AccountAddressByID",
        "parameters": [
          {
            "description": "Deprecated, use account_id instead id is the account number of the address to be queried. This field should have been an uint64 (like all account numbers), and will be updated to uint64 in a future version of the auth query.",
            "explode": false,
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "format": "int64",
              "type": "integer"
            },
            "style": "simple"
          },
          {
            "description": "account_id is the account number of the address to be queried. Since: cosmos-sdk 0.47",
            "explode": true,
            "in": "query",
            "name": "accountId",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryAccountAddressByIDResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/auth/v1beta1/bech32": {
      "get": {
        "description": "Bech32Prefix queries bech32Prefix\n\n Since: cosmos-sdk 0.46",
        "operationId": "Query_Bech32Prefix",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Bech32PrefixResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/auth/v1beta1/bech32/{addressBytes}": {
      "get": {
        "description": "AddressBytesToString converts Account Address bytes to string\n\n Since: cosmos-sdk 0.46",
        "operationId": "Query_AddressBytesToString",
        "parameters": [
          {
            "explode": false,
            "in": "path",
            "name": "addressBytes",
            "required": true,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AddressBytesToStringResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/auth/v1beta1/bech32/{addressString}": {
      "get": {
        "description": "AddressStringToBytes converts Address string to bytes\n\n Since: cosmos-sdk 0.46",
        "operationId": "Query_AddressStringToBytes",
        "parameters": [
          {
            "explode": false,
            "in": "path",
            "name": "addressString",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AddressStringToBytesResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/auth/v1beta1/module_accounts": {
      "get": {
        "description": "ModuleAccounts returns all the existing module accounts.\n\n Since: cosmos-sdk 0.46",
        "operationId": "Query_ModuleAccounts",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryModuleAccountsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/auth/v1beta1/module_accounts/{name}": {
      "get": {
        "description": "ModuleAccountByName returns the module account info by module name",
        "operationId": "Query_ModuleAccountByName",
        "parameters": [
          {
            "explode": false,
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryModuleAccountByNameResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/auth/v1beta1/params": {
      "get": {
        "description": "Params queries all parameters.",
        "operationId": "AuthParams",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryParamsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/authz/v1beta1/grants": {
      "get": {
        "description": "Returns list of `Authorization`, granted to the grantee by the granter.",
        "operationId": "Query_Grants",
        "parameters": [
          {
            "explode": true,
            "in": "query",
            "name": "granter",
            "required": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "explode": true,
            "in": "query",
            "name": "grantee",
            "required": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "Optional, msg_type_url, when set, will query only grants matching given msg type.",
            "explode": true,
            "in": "query",
            "name": "msgTypeUrl",
            "required": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryGrantsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/authz/v1beta1/grants/grantee/{grantee}": {
      "get": {
        "description": "GranteeGrants returns a list of `GrantAuthorization` by grantee.\n\n Since: cosmos-sdk 0.46",
        "operationId": "Query_GranteeGrants",
        "parameters": [
          {
            "explode": false,
            "in": "path",
            "name": "grantee",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryGranteeGrantsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/authz/v1beta1/grants/granter/{granter}": {
      "get": {
        "description": "GranterGrants returns list of `GrantAuthorization`, granted by granter.\n\n Since: cosmos-sdk 0.46",
        "operationId": "Query_GranterGrants",
        "parameters": [
          {
            "explode": false,
            "in": "path",
            "name": "granter",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryGranterGrantsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/bank/v1beta1/balances/{address}": {
      "get": {
        "description": "AllBalances queries the balance of all coins for a single account.\n\n When called from another module, this query might consume a high amount of\n gas if the pagination field is incorrectly set.",
        "operationId": "Query_AllBalances",
        "parameters": [
          {
            "description": "address is the address to query balances for.",
            "explode": false,
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "resolve_denom is the flag to resolve the denom into a human-readable form from the metadata. Since: cosmos-sdk 0.50",
            "explode": true,
            "in": "query",
            "name": "resolveDenom",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryAllBalancesResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/bank/v1beta1/balances/{address}/by_denom": {
      "get": {
        "description": "Balance queries the balance of a single coin for a single account.",
        "operationId": "Query_Balance",
        "parameters": [
          {
            "description": "address is the address to query balances for.",
            "explode": false,
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "denom is the coin denom to query balances for.",
            "explode": true,
            "in": "query",
            "name": "denom",
            "required": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryBalanceResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/bank/v1beta1/denom_owners/{denom}": {
      "get": {
        "description": "DenomOwners queries for all account addresses that own a particular token\n denomination.\n\n When called from another module, this query might consume a high amount of\n gas if the pagination field is incorrectly set.\n\n Since: cosmos-sdk 0.46",
        "operationId": "Query_DenomOwners",
        "parameters": [
          {
            "description": "denom defines the coin denomination to query all account holders for.",
            "explode": false,
            "in": "path",
            "name": "denom",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDenomOwnersResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/bank/v1beta1/denom_owners_by_query": {
      "get": {
        "description": "DenomOwnersByQuery queries for all account addresses that own a particular token\n denomination.\n\n Since: cosmos-sdk 0.50.3",
        "operationId": "Query_DenomOwnersByQuery",
        "parameters": [
          {
            "description": "denom defines the coin denomination to query all account holders for.",
            "explode": true,
            "in": "query",
            "name": "denom",
            "required": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDenomOwnersByQueryResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/bank/v1beta1/denoms_metadata": {
      "get": {
        "description": "DenomsMetadata queries the client metadata for all registered coin\n denominations.",
        "operationId": "Query_DenomsMetadata",
        "parameters": [
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDenomsMetadataResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/bank/v1beta1/denoms_metadata/{denom}": {
      "get": {
        "description": "DenomMetadata queries the client metadata of a given coin denomination.",
        "operationId": "Query_DenomMetadata",
        "parameters": [
          {
            "description": "denom is the coin denom to query the metadata for.",
            "explode": false,
            "in": "path",
            "name": "denom",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDenomMetadataResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/bank/v1beta1/denoms_metadata_by_query_string": {
      "get": {
        "description": "DenomMetadataByQueryString queries the client metadata of a given coin denomination.",
        "operationId": "Query_DenomMetadataByQueryString",
        "parameters": [
          {
            "description": "denom is the coin denom to query the metadata for.",
            "explode": true,
            "in": "query",
            "name": "denom",
            "required": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDenomMetadataByQueryStringResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/bank/v1beta1/params": {
      "get": {
        "description": "Params queries the parameters of x/bank module.",
        "operationId": "BankParams",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryParamsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/bank/v1beta1/send_enabled": {
      "get": {
        "description": "SendEnabled queries for SendEnabled entries.\n\n This query only returns denominations that have specific SendEnabled settings.\n Any denomination that does not have a specific setting will use the default\n params.default_send_enabled, and will not be returned by this query.\n\n Since: cosmos-sdk 0.47",
        "operationId": "Query_SendEnabled",
        "parameters": [
          {
            "description": "denoms is the specific denoms you want look up. Leave empty to get all entries.",
            "explode": true,
            "in": "query",
            "name": "denoms",
            "required": false,
            "schema": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "style": "form"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuerySendEnabledResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/bank/v1beta1/spendable_balances/{address}": {
      "get": {
        "description": "SpendableBalances queries the spendable balance of all coins for a single\n account.\n\n When called from another module, this query might consume a high amount of\n gas if the pagination field is incorrectly set.\n\n Since: cosmos-sdk 0.46",
        "operationId": "Query_SpendableBalances",
        "parameters": [
          {
            "description": "address is the address to query spendable balances for.",
            "explode": false,
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuerySpendableBalancesResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/bank/v1beta1/spendable_balances/{address}/by_denom": {
      "get": {
        "description": "SpendableBalanceByDenom queries the spendable balance of a single denom for\n a single account.\n\n When called from another module, this query might consume a high amount of\n gas if the pagination field is incorrectly set.\n\n Since: cosmos-sdk 0.47",
        "operationId": "Query_SpendableBalanceByDenom",
        "parameters": [
          {
            "description": "address is the address to query balances for.",
            "explode": false,
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "denom is the coin denom to query balances for.",
            "explode": true,
            "in": "query",
            "name": "denom",
            "required": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuerySpendableBalanceByDenomResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/bank/v1beta1/supply": {
      "get": {
        "description": "TotalSupply queries the total supply of all coins.\n\n When called from another module, this query might consume a high amount of\n gas if the pagination field is incorrectly set.",
        "operationId": "Query_TotalSupply",
        "parameters": [
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryTotalSupplyResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/bank/v1beta1/supply/by_denom": {
      "get": {
        "description": "SupplyOf queries the supply of a single coin.\n\n When called from another module, this query might consume a high amount of\n gas if the pagination field is incorrectly set.",
        "operationId": "Query_SupplyOf",
        "parameters": [
          {
            "description": "denom is the coin denom to query balances for.",
            "explode": true,
            "in": "query",
            "name": "denom",
            "required": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuerySupplyOfResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/base/node/v1beta1/config": {
      "get": {
        "description": "Config queries for the operator configuration.",
        "operationId": "Service_Config",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConfigResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Service"]
      }
    },
    "/cosmos/base/node/v1beta1/status": {
      "get": {
        "description": "Status queries for the node status.",
        "operationId": "Service_Status",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StatusResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Service"]
      }
    },
    "/cosmos/base/tendermint/v1beta1/abci_query": {
      "get": {
        "description": "ABCIQuery defines a query handler that supports ABCI queries directly to the\n application, bypassing Tendermint completely. The ABCI query must contain\n a valid and supported path, including app, custom, p2p, and store.\n\n Since: cosmos-sdk 0.46",
        "operationId": "Service_ABCIQuery",
        "parameters": [
          {
            "explode": true,
            "in": "query",
            "name": "data",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "explode": true,
            "in": "query",
            "name": "path",
            "required": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "explode": true,
            "in": "query",
            "name": "height",
            "required": false,
            "schema": {
              "format": "int64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "explode": true,
            "in": "query",
            "name": "prove",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ABCIQueryResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Service"]
      }
    },
    "/cosmos/base/tendermint/v1beta1/blocks/latest": {
      "get": {
        "description": "GetLatestBlock returns the latest block.",
        "operationId": "Service_GetLatestBlock",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetLatestBlockResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Service"]
      }
    },
    "/cosmos/base/tendermint/v1beta1/blocks/{height}": {
      "get": {
        "description": "GetBlockByHeight queries block for given height.",
        "operationId": "Service_GetBlockByHeight",
        "parameters": [
          {
            "explode": false,
            "in": "path",
            "name": "height",
            "required": true,
            "schema": {
              "format": "int64",
              "type": "integer"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetBlockByHeightResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Service"]
      }
    },
    "/cosmos/base/tendermint/v1beta1/node_info": {
      "get": {
        "description": "GetNodeInfo queries the current node info.",
        "operationId": "Service_GetNodeInfo",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetNodeInfoResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Service"]
      }
    },
    "/cosmos/base/tendermint/v1beta1/syncing": {
      "get": {
        "description": "GetSyncing queries node syncing.",
        "operationId": "Service_GetSyncing",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetSyncingResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Service"]
      }
    },
    "/cosmos/base/tendermint/v1beta1/validatorsets/latest": {
      "get": {
        "description": "GetLatestValidatorSet queries latest validator-set.",
        "operationId": "Service_GetLatestValidatorSet",
        "parameters": [
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetLatestValidatorSetResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Service"]
      }
    },
    "/cosmos/base/tendermint/v1beta1/validatorsets/{height}": {
      "get": {
        "description": "GetValidatorSetByHeight queries validator-set at a given height.",
        "operationId": "Service_GetValidatorSetByHeight",
        "parameters": [
          {
            "explode": false,
            "in": "path",
            "name": "height",
            "required": true,
            "schema": {
              "format": "int64",
              "type": "integer"
            },
            "style": "simple"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetValidatorSetByHeightResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Service"]
      }
    },
    "/cosmos/circuit/v1/accounts": {
      "get": {
        "description": "Account returns account permissions.",
        "operationId": "CircuitAccounts",
        "parameters": [
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/circuit/v1/accounts/{address}": {
      "get": {
        "description": "Account returns account permissions.",
        "operationId": "CircuitAccount",
        "parameters": [
          {
            "explode": false,
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/circuit/v1/disable_list": {
      "get": {
        "description": "DisabledList returns a list of disabled message urls",
        "operationId": "Query_DisabledList",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DisabledListResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/consensus/v1/params": {
      "get": {
        "description": "Params queries the parameters of x/consensus module.",
        "operationId": "ConsensusParams",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryParamsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/distribution/v1beta1/community_pool": {
      "get": {
        "description": "CommunityPool queries the community pool coins.",
        "operationId": "Query_CommunityPool",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryCommunityPoolResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/distribution/v1beta1/delegators/{delegatorAddress}/rewards": {
      "get": {
        "description": "DelegationTotalRewards queries the total rewards accrued by each\n validator.",
        "operationId": "Query_DelegationTotalRewards",
        "parameters": [
          {
            "description": "delegator_address defines the delegator address to query for.",
            "explode": false,
            "in": "path",
            "name": "delegatorAddress",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDelegationTotalRewardsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/distribution/v1beta1/delegators/{delegatorAddress}/rewards/{validatorAddress}": {
      "get": {
        "description": "DelegationRewards queries the total rewards accrued by a delegation.",
        "operationId": "Query_DelegationRewards",
        "parameters": [
          {
            "description": "delegator_address defines the delegator address to query for.",
            "explode": false,
            "in": "path",
            "name": "delegatorAddress",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "validator_address defines the validator address to query for.",
            "explode": false,
            "in": "path",
            "name": "validatorAddress",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDelegationRewardsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/distribution/v1beta1/delegators/{delegatorAddress}/validators": {
      "get": {
        "description": "DelegatorValidators queries the validators of a delegator.",
        "operationId": "Query_DelegatorValidators",
        "parameters": [
          {
            "description": "delegator_address defines the delegator address to query for.",
            "explode": false,
            "in": "path",
            "name": "delegatorAddress",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDelegatorValidatorsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/distribution/v1beta1/delegators/{delegatorAddress}/withdraw_address": {
      "get": {
        "description": "DelegatorWithdrawAddress queries withdraw address of a delegator.",
        "operationId": "Query_DelegatorWithdrawAddress",
        "parameters": [
          {
            "description": "delegator_address defines the delegator address to query for.",
            "explode": false,
            "in": "path",
            "name": "delegatorAddress",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDelegatorWithdrawAddressResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/distribution/v1beta1/params": {
      "get": {
        "description": "Params queries params of the distribution module.",
        "operationId": "DistributionParams",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryParamsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/distribution/v1beta1/validators/{validatorAddress}": {
      "get": {
        "description": "ValidatorDistributionInfo queries validator commission and self-delegation rewards for validator",
        "operationId": "Query_ValidatorDistributionInfo",
        "parameters": [
          {
            "description": "validator_address defines the validator address to query for.",
            "explode": false,
            "in": "path",
            "name": "validatorAddress",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryValidatorDistributionInfoResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/distribution/v1beta1/validators/{validatorAddress}/commission": {
      "get": {
        "description": "ValidatorCommission queries accumulated commission for a validator.",
        "operationId": "Query_ValidatorCommission",
        "parameters": [
          {
            "description": "validator_address defines the validator address to query for.",
            "explode": false,
            "in": "path",
            "name": "validatorAddress",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryValidatorCommissionResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/distribution/v1beta1/validators/{validatorAddress}/outstanding_rewards": {
      "get": {
        "description": "ValidatorOutstandingRewards queries rewards of a validator address.",
        "operationId": "Query_ValidatorOutstandingRewards",
        "parameters": [
          {
            "description": "validator_address defines the validator address to query for.",
            "explode": false,
            "in": "path",
            "name": "validatorAddress",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryValidatorOutstandingRewardsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/distribution/v1beta1/validators/{validatorAddress}/slashes": {
      "get": {
        "description": "ValidatorSlashes queries slash events of a validator.",
        "operationId": "Query_ValidatorSlashes",
        "parameters": [
          {
            "description": "validator_address defines the validator address to query for.",
            "explode": false,
            "in": "path",
            "name": "validatorAddress",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "starting_height defines the optional starting height to query the slashes.",
            "explode": true,
            "in": "query",
            "name": "startingHeight",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "starting_height defines the optional ending height to query the slashes.",
            "explode": true,
            "in": "query",
            "name": "endingHeight",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryValidatorSlashesResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/evidence/v1beta1/evidence": {
      "get": {
        "description": "AllEvidence queries all evidence.",
        "operationId": "Query_AllEvidence",
        "parameters": [
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryAllEvidenceResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/evidence/v1beta1/evidence/{hash}": {
      "get": {
        "description": "Evidence queries evidence based on evidence hash.",
        "operationId": "Query_Evidence",
        "parameters": [
          {
            "description": "hash defines the evidence hash of the requested evidence. Since: cosmos-sdk 0.47",
            "explode": false,
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "evidence_hash defines the hash of the requested evidence. Deprecated: Use hash, a HEX encoded string, instead.",
            "explode": true,
            "in": "query",
            "name": "evidenceHash",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryEvidenceResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/feegrant/v1beta1/allowance/{granter}/{grantee}": {
      "get": {
        "description": "Allowance returns granted allowance to the grantee by the granter.",
        "operationId": "Query_Allowance",
        "parameters": [
          {
            "description": "granter is the address of the user granting an allowance of their funds.",
            "explode": false,
            "in": "path",
            "name": "granter",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "grantee is the address of the user being granted an allowance of another user's funds.",
            "explode": false,
            "in": "path",
            "name": "grantee",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryAllowanceResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/feegrant/v1beta1/allowances/{grantee}": {
      "get": {
        "description": "Allowances returns all the grants for the given grantee address.",
        "operationId": "Query_Allowances",
        "parameters": [
          {
            "explode": false,
            "in": "path",
            "name": "grantee",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryAllowancesResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/feegrant/v1beta1/issued/{granter}": {
      "get": {
        "description": "AllowancesByGranter returns all the grants given by an address\n\n Since: cosmos-sdk 0.46",
        "operationId": "Query_AllowancesByGranter",
        "parameters": [
          {
            "explode": false,
            "in": "path",
            "name": "granter",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryAllowancesByGranterResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/gov/v1/constitution": {
      "get": {
        "description": "Constitution queries the chain's constitution.",
        "operationId": "Query_Constitution",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryConstitutionResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/gov/v1/params/{paramsType}": {
      "get": {
        "description": "Params queries all parameters of the gov module.",
        "operationId": "GovV1Params",
        "parameters": [
          {
            "description": "params_type defines which parameters to query for, can be one of \"voting\", \"tallying\" or \"deposit\".",
            "explode": false,
            "in": "path",
            "name": "paramsType",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryParamsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/gov/v1/proposals": {
      "get": {
        "description": "Proposals queries all proposals based on given status.",
        "operationId": "GovV1Proposals",
        "parameters": [
          {
            "description": "proposal_status defines the status of the proposals.",
            "explode": true,
            "in": "query",
            "name": "proposalStatus",
            "required": false,
            "schema": {
              "format": "enum",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "voter defines the voter address for the proposals.",
            "explode": true,
            "in": "query",
            "name": "voter",
            "required": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "depositor defines the deposit addresses from the proposals.",
            "explode": true,
            "in": "query",
            "name": "depositor",
            "required": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryProposalsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/gov/v1/proposals/{proposalId}": {
      "get": {
        "description": "Proposal queries proposal details based on ProposalID.",
        "operationId": "GovV1Proposal",
        "parameters": [
          {
            "description": "proposal_id defines the unique id of the proposal.",
            "explode": false,
            "in": "path",
            "name": "proposalId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryProposalResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/gov/v1/proposals/{proposalId}/deposits": {
      "get": {
        "description": "Deposits queries all deposits of a single proposal.",
        "operationId": "GovV1Deposits",
        "parameters": [
          {
            "description": "proposal_id defines the unique id of the proposal.",
            "explode": false,
            "in": "path",
            "name": "proposalId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "simple"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDepositsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/gov/v1/proposals/{proposalId}/deposits/{depositor}": {
      "get": {
        "description": "Deposit queries single deposit information based on proposalID, depositAddr.",
        "operationId": "GovV1Deposit",
        "parameters": [
          {
            "description": "proposal_id defines the unique id of the proposal.",
            "explode": false,
            "in": "path",
            "name": "proposalId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "simple"
          },
          {
            "description": "depositor defines the deposit addresses from the proposals.",
            "explode": false,
            "in": "path",
            "name": "depositor",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDepositResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/gov/v1/proposals/{proposalId}/tally": {
      "get": {
        "description": "TallyResult queries the tally of a proposal vote.",
        "operationId": "GovV1TallyResult",
        "parameters": [
          {
            "description": "proposal_id defines the unique id of the proposal.",
            "explode": false,
            "in": "path",
            "name": "proposalId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryTallyResultResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/gov/v1/proposals/{proposalId}/votes": {
      "get": {
        "description": "Votes queries votes of a given proposal.",
        "operationId": "GovV1Votes",
        "parameters": [
          {
            "description": "proposal_id defines the unique id of the proposal.",
            "explode": false,
            "in": "path",
            "name": "proposalId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "simple"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryVotesResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/gov/v1/proposals/{proposalId}/votes/{voter}": {
      "get": {
        "description": "Vote queries voted information based on proposalID, voterAddr.",
        "operationId": "GovV1Vote",
        "parameters": [
          {
            "description": "proposal_id defines the unique id of the proposal.",
            "explode": false,
            "in": "path",
            "name": "proposalId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "simple"
          },
          {
            "description": "voter defines the voter address for the proposals.",
            "explode": false,
            "in": "path",
            "name": "voter",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryVoteResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/gov/v1beta1/params/{paramsType}": {
      "get": {
        "description": "Params queries all parameters of the gov module.",
        "operationId": "GovV1Beta1Params",
        "parameters": [
          {
            "description": "params_type defines which parameters to query for, can be one of \"voting\", \"tallying\" or \"deposit\".",
            "explode": false,
            "in": "path",
            "name": "paramsType",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryParamsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/gov/v1beta1/proposals": {
      "get": {
        "description": "Proposals queries all proposals based on given status.",
        "operationId": "Query_Proposals",
        "parameters": [
          {
            "description": "proposal_status defines the status of the proposals.",
            "explode": true,
            "in": "query",
            "name": "proposalStatus",
            "required": false,
            "schema": {
              "format": "enum",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "voter defines the voter address for the proposals.",
            "explode": true,
            "in": "query",
            "name": "voter",
            "required": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "depositor defines the deposit addresses from the proposals.",
            "explode": true,
            "in": "query",
            "name": "depositor",
            "required": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryProposalsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposalId}": {
      "get": {
        "description": "Proposal queries proposal details based on ProposalID.",
        "operationId": "Query_Proposal",
        "parameters": [
          {
            "description": "proposal_id defines the unique id of the proposal.",
            "explode": false,
            "in": "path",
            "name": "proposalId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryProposalResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposalId}/deposits": {
      "get": {
        "description": "Deposits queries all deposits of a single proposal.",
        "operationId": "Query_Deposits",
        "parameters": [
          {
            "description": "proposal_id defines the unique id of the proposal.",
            "explode": false,
            "in": "path",
            "name": "proposalId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "simple"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDepositsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposalId}/deposits/{depositor}": {
      "get": {
        "description": "Deposit queries single deposit information based on proposalID, depositor address.",
        "operationId": "Query_Deposit",
        "parameters": [
          {
            "description": "proposal_id defines the unique id of the proposal.",
            "explode": false,
            "in": "path",
            "name": "proposalId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "simple"
          },
          {
            "description": "depositor defines the deposit addresses from the proposals.",
            "explode": false,
            "in": "path",
            "name": "depositor",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDepositResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposalId}/tally": {
      "get": {
        "description": "TallyResult queries the tally of a proposal vote.",
        "operationId": "Query_TallyResult",
        "parameters": [
          {
            "description": "proposal_id defines the unique id of the proposal.",
            "explode": false,
            "in": "path",
            "name": "proposalId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryTallyResultResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposalId}/votes": {
      "get": {
        "description": "Votes queries votes of a given proposal.",
        "operationId": "Query_Votes",
        "parameters": [
          {
            "description": "proposal_id defines the unique id of the proposal.",
            "explode": false,
            "in": "path",
            "name": "proposalId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "simple"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryVotesResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposalId}/votes/{voter}": {
      "get": {
        "description": "Vote queries voted information based on proposalID, voterAddr.",
        "operationId": "Query_Vote",
        "parameters": [
          {
            "description": "proposal_id defines the unique id of the proposal.",
            "explode": false,
            "in": "path",
            "name": "proposalId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "simple"
          },
          {
            "description": "voter defines the voter address for the proposals.",
            "explode": false,
            "in": "path",
            "name": "voter",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryVoteResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/group/v1/group_info/{groupId}": {
      "get": {
        "description": "GroupInfo queries group info based on group id.",
        "operationId": "Query_GroupInfo",
        "parameters": [
          {
            "description": "group_id is the unique ID of the group.",
            "explode": false,
            "in": "path",
            "name": "groupId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryGroupInfoResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/group/v1/group_members/{groupId}": {
      "get": {
        "description": "GroupMembers queries members of a group by group id.",
        "operationId": "Query_GroupMembers",
        "parameters": [
          {
            "description": "group_id is the unique ID of the group.",
            "explode": false,
            "in": "path",
            "name": "groupId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "simple"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryGroupMembersResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/group/v1/group_policies_by_admin/{admin}": {
      "get": {
        "description": "GroupPoliciesByAdmin queries group policies by admin address.",
        "operationId": "Query_GroupPoliciesByAdmin",
        "parameters": [
          {
            "description": "admin is the admin address of the group policy.",
            "explode": false,
            "in": "path",
            "name": "admin",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryGroupPoliciesByAdminResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/group/v1/group_policies_by_group/{groupId}": {
      "get": {
        "description": "GroupPoliciesByGroup queries group policies by group id.",
        "operationId": "Query_GroupPoliciesByGroup",
        "parameters": [
          {
            "description": "group_id is the unique ID of the group policy's group.",
            "explode": false,
            "in": "path",
            "name": "groupId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "simple"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryGroupPoliciesByGroupResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/group/v1/group_policy_info/{address}": {
      "get": {
        "description": "GroupPolicyInfo queries group policy info based on account address of group policy.",
        "operationId": "Query_GroupPolicyInfo",
        "parameters": [
          {
            "description": "address is the account address of the group policy.",
            "explode": false,
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryGroupPolicyInfoResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/group/v1/groups": {
      "get": {
        "description": "Groups queries all groups in state.\n\n Since: cosmos-sdk 0.47.1",
        "operationId": "Query_Groups",
        "parameters": [
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryGroupsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/group/v1/groups_by_admin/{admin}": {
      "get": {
        "description": "GroupsByAdmin queries groups by admin address.",
        "operationId": "Query_GroupsByAdmin",
        "parameters": [
          {
            "description": "admin is the account address of a group's admin.",
            "explode": false,
            "in": "path",
            "name": "admin",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryGroupsByAdminResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/group/v1/groups_by_member/{address}": {
      "get": {
        "description": "GroupsByMember queries groups by member address.",
        "operationId": "Query_GroupsByMember",
        "parameters": [
          {
            "description": "address is the group member address.",
            "explode": false,
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryGroupsByMemberResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/group/v1/proposal/{proposalId}": {
      "get": {
        "description": "Proposal queries a proposal based on proposal id.",
        "operationId": "GroupProposal",
        "parameters": [
          {
            "description": "proposal_id is the unique ID of a proposal.",
            "explode": false,
            "in": "path",
            "name": "proposalId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryProposalResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/group/v1/proposals/{proposalId}/tally": {
      "get": {
        "description": "TallyResult returns the tally result of a proposal. If the proposal is\n still in voting period, then this query computes the current tally state,\n which might not be final. On the other hand, if the proposal is final,\n then it simply returns the `final_tally_result` state stored in the\n proposal itself.",
        "operationId": "GroupTallyResult",
        "parameters": [
          {
            "description": "proposal_id is the unique id of a proposal.",
            "explode": false,
            "in": "path",
            "name": "proposalId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryTallyResultResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/group/v1/proposals_by_group_policy/{address}": {
      "get": {
        "description": "ProposalsByGroupPolicy queries proposals based on account address of group policy.",
        "operationId": "Query_ProposalsByGroupPolicy",
        "parameters": [
          {
            "description": "address is the account address of the group policy related to proposals.",
            "explode": false,
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryProposalsByGroupPolicyResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/group/v1/vote_by_proposal_voter/{proposalId}/{voter}": {
      "get": {
        "description": "VoteByProposalVoter queries a vote by proposal id and voter.",
        "operationId": "Query_VoteByProposalVoter",
        "parameters": [
          {
            "description": "proposal_id is the unique ID of a proposal.",
            "explode": false,
            "in": "path",
            "name": "proposalId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "simple"
          },
          {
            "description": "voter is a proposal voter account address.",
            "explode": false,
            "in": "path",
            "name": "voter",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryVoteByProposalVoterResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/group/v1/votes_by_proposal/{proposalId}": {
      "get": {
        "description": "VotesByProposal queries a vote by proposal id.",
        "operationId": "Query_VotesByProposal",
        "parameters": [
          {
            "description": "proposal_id is the unique ID of a proposal.",
            "explode": false,
            "in": "path",
            "name": "proposalId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "simple"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryVotesByProposalResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/group/v1/votes_by_voter/{voter}": {
      "get": {
        "description": "VotesByVoter queries a vote by voter.",
        "operationId": "Query_VotesByVoter",
        "parameters": [
          {
            "description": "voter is a proposal voter account address.",
            "explode": false,
            "in": "path",
            "name": "voter",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryVotesByVoterResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/mint/v1beta1/annual_provisions": {
      "get": {
        "description": "AnnualProvisions current minting annual provisions value.",
        "operationId": "Query_AnnualProvisions",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryAnnualProvisionsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/mint/v1beta1/inflation": {
      "get": {
        "description": "Inflation returns the current minting inflation value.",
        "operationId": "Query_Inflation",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryInflationResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/mint/v1beta1/params": {
      "get": {
        "description": "Params returns the total set of minting parameters.",
        "operationId": "MintParams",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryParamsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/nft/v1beta1/balance/{owner}/{classId}": {
      "get": {
        "description": "Balance queries the number of NFTs of a given class owned by the owner, same as balanceOf in ERC721",
        "operationId": "NftBalance",
        "parameters": [
          {
            "description": "owner is the owner address of the nft",
            "explode": false,
            "in": "path",
            "name": "owner",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "class_id associated with the nft",
            "explode": false,
            "in": "path",
            "name": "classId",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryBalanceResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/nft/v1beta1/classes": {
      "get": {
        "description": "Classes queries all NFT classes",
        "operationId": "Query_Classes",
        "parameters": [
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryClassesResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/nft/v1beta1/classes/{classId}": {
      "get": {
        "description": "Class queries an NFT class based on its id",
        "operationId": "Query_Class",
        "parameters": [
          {
            "description": "class_id associated with the nft",
            "explode": false,
            "in": "path",
            "name": "classId",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryClassResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/nft/v1beta1/nfts": {
      "get": {
        "description": "NFTs queries all NFTs of a given class or owner,choose at least one of the two, similar to tokenByIndex in\n ERC721Enumerable",
        "operationId": "Query_NFTs",
        "parameters": [
          {
            "description": "class_id associated with the nft",
            "explode": true,
            "in": "query",
            "name": "classId",
            "required": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "owner is the owner address of the nft",
            "explode": true,
            "in": "query",
            "name": "owner",
            "required": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryNFTsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/nft/v1beta1/nfts/{classId}/{id}": {
      "get": {
        "description": "NFT queries an NFT based on its class and id.",
        "operationId": "Query_NFT",
        "parameters": [
          {
            "description": "class_id associated with the nft",
            "explode": false,
            "in": "path",
            "name": "classId",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "id is a unique identifier of the NFT",
            "explode": false,
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryNFTResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/nft/v1beta1/owner/{classId}/{id}": {
      "get": {
        "description": "Owner queries the owner of the NFT based on its class and id, same as ownerOf in ERC721",
        "operationId": "Query_Owner",
        "parameters": [
          {
            "description": "class_id associated with the nft",
            "explode": false,
            "in": "path",
            "name": "classId",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "id is a unique identifier of the NFT",
            "explode": false,
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryOwnerResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/nft/v1beta1/supply/{classId}": {
      "get": {
        "description": "Supply queries the number of NFTs from the given class, same as totalSupply of ERC721.",
        "operationId": "Query_Supply",
        "parameters": [
          {
            "description": "class_id associated with the nft",
            "explode": false,
            "in": "path",
            "name": "classId",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuerySupplyResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/params/v1beta1/params": {
      "get": {
        "description": "Params queries a specific parameter of a module, given its subspace and\n key.",
        "operationId": "Params",
        "parameters": [
          {
            "description": "subspace defines the module to query the parameter for.",
            "explode": true,
            "in": "query",
            "name": "subspace",
            "required": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "key defines the key of the parameter in the subspace.",
            "explode": true,
            "in": "query",
            "name": "key",
            "required": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryParamsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/params/v1beta1/subspaces": {
      "get": {
        "description": "Subspaces queries for all registered subspaces and all keys for a subspace.\n\n Since: cosmos-sdk 0.46",
        "operationId": "Query_Subspaces",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuerySubspacesResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/slashing/v1beta1/params": {
      "get": {
        "description": "Params queries the parameters of slashing module",
        "operationId": "SlashingParams",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryParamsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/slashing/v1beta1/signing_infos": {
      "get": {
        "description": "SigningInfos queries signing info of all validators",
        "operationId": "Query_SigningInfos",
        "parameters": [
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuerySigningInfosResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/slashing/v1beta1/signing_infos/{consAddress}": {
      "get": {
        "description": "SigningInfo queries the signing info of given cons address",
        "operationId": "Query_SigningInfo",
        "parameters": [
          {
            "description": "cons_address is the address to query signing info of",
            "explode": false,
            "in": "path",
            "name": "consAddress",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuerySigningInfoResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/staking/v1beta1/delegations/{delegatorAddr}": {
      "get": {
        "description": "DelegatorDelegations queries all delegations of a given delegator address.\n\n When called from another module, this query might consume a high amount of\n gas if the pagination field is incorrectly set.",
        "operationId": "Query_DelegatorDelegations",
        "parameters": [
          {
            "description": "delegator_addr defines the delegator address to query for.",
            "explode": false,
            "in": "path",
            "name": "delegatorAddr",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDelegatorDelegationsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/staking/v1beta1/delegators/{delegatorAddr}/redelegations": {
      "get": {
        "description": "Redelegations queries redelegations of given address.\n\n When called from another module, this query might consume a high amount of\n gas if the pagination field is incorrectly set.",
        "operationId": "Query_Redelegations",
        "parameters": [
          {
            "description": "delegator_addr defines the delegator address to query for.",
            "explode": false,
            "in": "path",
            "name": "delegatorAddr",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "src_validator_addr defines the validator address to redelegate from.",
            "explode": true,
            "in": "query",
            "name": "srcValidatorAddr",
            "required": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "dst_validator_addr defines the validator address to redelegate to.",
            "explode": true,
            "in": "query",
            "name": "dstValidatorAddr",
            "required": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryRedelegationsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/staking/v1beta1/delegators/{delegatorAddr}/unbonding_delegations": {
      "get": {
        "description": "DelegatorUnbondingDelegations queries all unbonding delegations of a given\n delegator address.\n\n When called from another module, this query might consume a high amount of\n gas if the pagination field is incorrectly set.",
        "operationId": "Query_DelegatorUnbondingDelegations",
        "parameters": [
          {
            "description": "delegator_addr defines the delegator address to query for.",
            "explode": false,
            "in": "path",
            "name": "delegatorAddr",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDelegatorUnbondingDelegationsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/staking/v1beta1/delegators/{delegatorAddr}/validators": {
      "get": {
        "description": "DelegatorValidators queries all validators info for given delegator\n address.\n\n When called from another module, this query might consume a high amount of\n gas if the pagination field is incorrectly set.",
        "operationId": "StakingDelegatorValidators",
        "parameters": [
          {
            "description": "delegator_addr defines the delegator address to query for.",
            "explode": false,
            "in": "path",
            "name": "delegatorAddr",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDelegatorValidatorsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/staking/v1beta1/delegators/{delegatorAddr}/validators/{validatorAddr}": {
      "get": {
        "description": "DelegatorValidator queries validator info for given delegator validator\n pair.",
        "operationId": "Query_DelegatorValidator",
        "parameters": [
          {
            "description": "delegator_addr defines the delegator address to query for.",
            "explode": false,
            "in": "path",
            "name": "delegatorAddr",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "validator_addr defines the validator address to query for.",
            "explode": false,
            "in": "path",
            "name": "validatorAddr",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDelegatorValidatorResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/staking/v1beta1/historical_info/{height}": {
      "get": {
        "description": "HistoricalInfo queries the historical info for given height.",
        "operationId": "Query_HistoricalInfo",
        "parameters": [
          {
            "description": "height defines at which height to query the historical info.",
            "explode": false,
            "in": "path",
            "name": "height",
            "required": true,
            "schema": {
              "format": "int64",
              "type": "integer"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryHistoricalInfoResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/staking/v1beta1/params": {
      "get": {
        "description": "Parameters queries the staking parameters.",
        "operationId": "StakingParams",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryParamsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/staking/v1beta1/pool": {
      "get": {
        "description": "Pool queries the pool info.",
        "operationId": "Query_Pool",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryPoolResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/staking/v1beta1/validators": {
      "get": {
        "description": "Validators queries all validators that match the given status.\n\n When called from another module, this query might consume a high amount of\n gas if the pagination field is incorrectly set.",
        "operationId": "Query_Validators",
        "parameters": [
          {
            "description": "status enables to query for validators matching a given status.",
            "explode": true,
            "in": "query",
            "name": "status",
            "required": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryValidatorsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/staking/v1beta1/validators/{validatorAddr}": {
      "get": {
        "description": "Validator queries validator info for given validator address.",
        "operationId": "Query_Validator",
        "parameters": [
          {
            "description": "validator_addr defines the validator address to query for.",
            "explode": false,
            "in": "path",
            "name": "validatorAddr",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryValidatorResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/staking/v1beta1/validators/{validatorAddr}/delegations": {
      "get": {
        "description": "ValidatorDelegations queries delegate info for given validator.\n\n When called from another module, this query might consume a high amount of\n gas if the pagination field is incorrectly set.",
        "operationId": "Query_ValidatorDelegations",
        "parameters": [
          {
            "description": "validator_addr defines the validator address to query for.",
            "explode": false,
            "in": "path",
            "name": "validatorAddr",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryValidatorDelegationsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/staking/v1beta1/validators/{validatorAddr}/delegations/{delegatorAddr}": {
      "get": {
        "description": "Delegation queries delegate info for given validator delegator pair.",
        "operationId": "Query_Delegation",
        "parameters": [
          {
            "description": "validator_addr defines the validator address to query for.",
            "explode": false,
            "in": "path",
            "name": "validatorAddr",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "delegator_addr defines the delegator address to query for.",
            "explode": false,
            "in": "path",
            "name": "delegatorAddr",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDelegationResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/staking/v1beta1/validators/{validatorAddr}/delegations/{delegatorAddr}/unbonding_delegation": {
      "get": {
        "description": "UnbondingDelegation queries unbonding info for given validator delegator\n pair.",
        "operationId": "Query_UnbondingDelegation",
        "parameters": [
          {
            "description": "validator_addr defines the validator address to query for.",
            "explode": false,
            "in": "path",
            "name": "validatorAddr",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "delegator_addr defines the delegator address to query for.",
            "explode": false,
            "in": "path",
            "name": "delegatorAddr",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryUnbondingDelegationResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/staking/v1beta1/validators/{validatorAddr}/unbonding_delegations": {
      "get": {
        "description": "ValidatorUnbondingDelegations queries unbonding delegations of a validator.\n\n When called from another module, this query might consume a high amount of\n gas if the pagination field is incorrectly set.",
        "operationId": "Query_ValidatorUnbondingDelegations",
        "parameters": [
          {
            "description": "validator_addr defines the validator address to query for.",
            "explode": false,
            "in": "path",
            "name": "validatorAddr",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryValidatorUnbondingDelegationsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/tx/v1beta1/decode": {
      "post": {
        "description": "TxDecode decodes the transaction.\n\n Since: cosmos-sdk 0.47",
        "operationId": "Service_TxDecode",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TxDecodeRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TxDecodeResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Service"]
      }
    },
    "/cosmos/tx/v1beta1/decode/amino": {
      "post": {
        "description": "TxDecodeAmino decodes an Amino transaction from encoded bytes to JSON.\n\n Since: cosmos-sdk 0.47",
        "operationId": "Service_TxDecodeAmino",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TxDecodeAminoRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TxDecodeAminoResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Service"]
      }
    },
    "/cosmos/tx/v1beta1/encode": {
      "post": {
        "description": "TxEncode encodes the transaction.\n\n Since: cosmos-sdk 0.47",
        "operationId": "Service_TxEncode",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TxEncodeRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TxEncodeResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Service"]
      }
    },
    "/cosmos/tx/v1beta1/encode/amino": {
      "post": {
        "description": "TxEncodeAmino encodes an Amino transaction from JSON to encoded bytes.\n\n Since: cosmos-sdk 0.47",
        "operationId": "Service_TxEncodeAmino",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TxEncodeAminoRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TxEncodeAminoResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Service"]
      }
    },
    "/cosmos/tx/v1beta1/simulate": {
      "post": {
        "description": "Simulate simulates executing a transaction for estimating gas usage.",
        "operationId": "Service_Simulate",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SimulateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimulateResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Service"]
      }
    },
    "/cosmos/tx/v1beta1/txs": {
      "get": {
        "description": "GetTxsEvent fetches txs by event.",
        "operationId": "Service_GetTxsEvent",
        "parameters": [
          {
            "description": "events is the list of transaction event type. Deprecated post v0.47.x: use query instead, which should contain a valid events query.",
            "explode": true,
            "in": "query",
            "name": "events",
            "required": false,
            "schema": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "style": "form"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "explode": true,
            "in": "query",
            "name": "orderBy",
            "required": false,
            "schema": {
              "format": "enum",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "page is the page number to query, starts at 1. If not provided, will default to first page.",
            "explode": true,
            "in": "query",
            "name": "page",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "query defines the transaction event query that is proxied to Tendermint's TxSearch RPC method. The query must be valid. Since cosmos-sdk 0.50",
            "explode": true,
            "in": "query",
            "name": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetTxsEventResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Service"]
      },
      "post": {
        "description": "BroadcastTx broadcast transaction.",
        "operationId": "Service_BroadcastTx",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BroadcastTxRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BroadcastTxResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Service"]
      }
    },
    "/cosmos/tx/v1beta1/txs/block/{height}": {
      "get": {
        "description": "GetBlockWithTxs fetches a block with decoded txs.\n\n Since: cosmos-sdk 0.45.2",
        "operationId": "Service_GetBlockWithTxs",
        "parameters": [
          {
            "description": "height is the height of the block to query.",
            "explode": false,
            "in": "path",
            "name": "height",
            "required": true,
            "schema": {
              "format": "int64",
              "type": "integer"
            },
            "style": "simple"
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.key",
            "required": false,
            "schema": {
              "format": "bytes",
              "type": "string"
            },
            "style": "form"
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
            "explode": true,
            "in": "query",
            "name": "pagination.offset",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
            "explode": true,
            "in": "query",
            "name": "pagination.limit",
            "required": false,
            "schema": {
              "format": "uint64",
              "type": "integer"
            },
            "style": "form"
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
            "explode": true,
            "in": "query",
            "name": "pagination.countTotal",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
            "explode": true,
            "in": "query",
            "name": "pagination.reverse",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetBlockWithTxsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Service"]
      }
    },
    "/cosmos/tx/v1beta1/txs/{hash}": {
      "get": {
        "description": "GetTx fetches a tx by hash.",
        "operationId": "Service_GetTx",
        "parameters": [
          {
            "description": "hash is the tx hash to query, encoded as a hex string.",
            "explode": false,
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetTxResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Service"]
      }
    },
    "/cosmos/upgrade/v1beta1/applied_plan/{name}": {
      "get": {
        "description": "AppliedPlan queries a previously applied upgrade plan by its name.",
        "operationId": "Query_AppliedPlan",
        "parameters": [
          {
            "description": "name is the name of the applied plan to query for.",
            "explode": false,
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryAppliedPlanResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/upgrade/v1beta1/authority": {
      "get": {
        "description": "Returns the account with authority to conduct upgrades\n\n Since: cosmos-sdk 0.46",
        "operationId": "Query_Authority",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryAuthorityResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/upgrade/v1beta1/current_plan": {
      "get": {
        "description": "CurrentPlan queries the current upgrade plan.",
        "operationId": "Query_CurrentPlan",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryCurrentPlanResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/upgrade/v1beta1/module_versions": {
      "get": {
        "description": "ModuleVersions queries the list of module versions from state.\n\n Since: cosmos-sdk 0.43",
        "operationId": "Query_ModuleVersions",
        "parameters": [
          {
            "description": "module_name is a field to query a specific module consensus version from state. Leaving this empty will fetch the full list of module versions from state",
            "explode": true,
            "in": "query",
            "name": "moduleName",
            "required": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryModuleVersionsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/cosmos/upgrade/v1beta1/upgraded_consensus_state/{lastHeight}": {
      "get": {
        "description": "UpgradedConsensusState queries the consensus state that will serve\n as a trusted kernel for the next version of this chain. It will only be\n stored at the last height of this chain.\n UpgradedConsensusState RPC not supported with legacy querier\n This rpc is deprecated now that IBC has its own replacement\n (https://github.com/cosmos/ibc-go/blob/2c880a22e9f9cc75f62b527ca94aa75ce1106001/proto/ibc/core/client/v1/query.proto#L54)",
        "operationId": "Query_UpgradedConsensusState",
        "parameters": [
          {
            "description": "last height of the current chain must be sent in request as this is the height under which next consensus state is stored",
            "explode": false,
            "in": "path",
            "name": "lastHeight",
            "required": true,
            "schema": {
              "format": "int64",
              "type": "integer"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryUpgradedConsensusStateResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/tokenfactory.v1beta1/denoms/{denom}/authority_metadata": {
      "get": {
        "description": "DenomAuthorityMetadata defines a gRPC query method for fetching\n DenomAuthorityMetadata for a particular denom.",
        "operationId": "Query_DenomAuthorityMetadata",
        "parameters": [
          {
            "explode": false,
            "in": "path",
            "name": "denom",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDenomAuthorityMetadataResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/tokenfactory.v1beta1/denoms_from_creator/{creator}": {
      "get": {
        "description": "DenomsFromCreator defines a gRPC query method for fetching all\n denominations created by a specific admin/creator.",
        "operationId": "Query_DenomsFromCreator",
        "parameters": [
          {
            "explode": false,
            "in": "path",
            "name": "creator",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDenomsFromCreatorResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/tokenfactory.v1beta1/params": {
      "get": {
        "description": "Params defines a gRPC query method that returns the tokenfactory module's\n parameters.",
        "operationId": "TokenfactoryParams",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryParamsResponse"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            },
            "description": "Default error response"
          }
        },
        "tags": ["Query"]
      }
    },
    "/ibc/apps/transfer/v1/channels/{channel_id}/ports/{port_id}/escrow_address": {
      "get": {
        "operationId": "EscrowAddress",
        "parameters": [
          {
            "description": "unique channel identifier",
            "in": "path",
            "name": "channel_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "unique port identifier",
            "in": "path",
            "name": "port_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/EscrowAddress_200_response"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/EscrowAddress_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "EscrowAddress returns the escrow address for a particular port and channel id.",
        "tags": ["Query"]
      }
    },
    "/ibc/apps/transfer/v1/denom_hashes/{trace}": {
      "get": {
        "operationId": "DenomHash",
        "parameters": [
          {
            "description": "The denomination trace ([port_id]/[channel_id])+/[denom]",
            "in": "path",
            "name": "trace",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/DenomHash_200_response"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/EscrowAddress_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "DenomHash queries a denomination hash information.",
        "tags": ["Query"]
      }
    },
    "/ibc/apps/transfer/v1/denom_traces": {
      "get": {
        "operationId": "DenomTraces",
        "parameters": [
          {
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "name": "pagination.key",
            "schema": {
              "format": "byte",
              "type": "string"
            }
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "name": "pagination.offset",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "name": "pagination.limit",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "name": "pagination.count_total",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "name": "pagination.reverse",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/DenomTraces_200_response"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/EscrowAddress_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "DenomTraces queries all denomination traces.",
        "tags": ["Query"]
      }
    },
    "/ibc/apps/transfer/v1/denom_traces/{hash}": {
      "get": {
        "operationId": "DenomTrace",
        "parameters": [
          {
            "description": "hash (in hex format) or denom (full denom with ibc prefix) of the denomination trace information.",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/DenomTrace_200_response"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/EscrowAddress_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "DenomTrace queries a denomination trace information.",
        "tags": ["Query"]
      }
    },
    "/ibc/apps/transfer/v1/denoms/{denom}/total_escrow": {
      "get": {
        "operationId": "TotalEscrowForDenom",
        "parameters": [
          {
            "in": "path",
            "name": "denom",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/TotalEscrowForDenom_200_response"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/EscrowAddress_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "TotalEscrowForDenom returns the total amount of tokens in escrow based on the denom.",
        "tags": ["Query"]
      }
    },
    "/ibc/apps/transfer/v1/params": {
      "get": {
        "operationId": "TransferParams",
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/TransferParams_200_response"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/EscrowAddress_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "Params queries all parameters of the ibc-transfer module.",
        "tags": ["Query"]
      }
    },
    "/ibc/apps/interchain_accounts/controller/v1/owners/{owner}/connections/{connection_id}": {
      "get": {
        "operationId": "InterchainAccount",
        "parameters": [
          {
            "in": "path",
            "name": "owner",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "connection_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/InterchainAccount_200_response"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/EscrowAddress_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "InterchainAccount returns the interchain account address for a given owner address on a given connection",
        "tags": ["Query"]
      }
    },
    "/ibc/apps/interchain_accounts/controller/v1/params": {
      "get": {
        "operationId": "InterchainAccountsControllerParams",
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/InterchainAccountsControllerParams_200_response"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/EscrowAddress_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "Params queries all parameters of the ICA controller submodule.",
        "tags": ["Query"]
      }
    },
    "/ibc/apps/interchain_accounts/host/v1/params": {
      "get": {
        "operationId": "InterchainAccountsHostParams",
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/InterchainAccountsHostParams_200_response"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/EscrowAddress_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "Params queries all parameters of the ICA host submodule.",
        "tags": ["Query"]
      }
    },
    "/ibc/apps/fee/v1/channels/{channel_id}/ports/{port_id}/fee_enabled": {
      "get": {
        "operationId": "FeeEnabledChannel",
        "parameters": [
          {
            "description": "unique channel identifier",
            "in": "path",
            "name": "channel_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "unique port identifier",
            "in": "path",
            "name": "port_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryFeeEnabledChannelResponse_defines_the_response_type_for_the_FeeEnabledChannel_rpc"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "FeeEnabledChannel returns true if the provided port and channel identifiers belong to a fee enabled channel",
        "tags": ["Query"]
      }
    },
    "/ibc/apps/fee/v1/channels/{channel_id}/ports/{port_id}/incentivized_packets": {
      "get": {
        "operationId": "IncentivizedPacketsForChannel",
        "parameters": [
          {
            "in": "path",
            "name": "channel_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "port_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "name": "pagination.key",
            "schema": {
              "format": "byte",
              "type": "string"
            }
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "name": "pagination.offset",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "name": "pagination.limit",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "name": "pagination.count_total",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "name": "pagination.reverse",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Height to query at.",
            "in": "query",
            "name": "query_height",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryIncentivizedPacketsResponse_defines_the_response_type_for_the_incentivized_packets_RPC"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "Gets all incentivized packets for a specific channel",
        "tags": ["Query"]
      }
    },
    "/ibc/apps/fee/v1/channels/{channel_id}/relayers/{relayer}/counterparty_payee": {
      "get": {
        "operationId": "CounterpartyPayee",
        "parameters": [
          {
            "description": "unique channel identifier",
            "in": "path",
            "name": "channel_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "the relayer address to which the counterparty is registered",
            "in": "path",
            "name": "relayer",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryCounterpartyPayeeResponse_defines_the_response_type_for_the_CounterpartyPayee_rpc"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "CounterpartyPayee returns the registered counterparty payee for forward relaying",
        "tags": ["Query"]
      }
    },
    "/ibc/apps/fee/v1/channels/{channel_id}/relayers/{relayer}/payee": {
      "get": {
        "operationId": "Payee",
        "parameters": [
          {
            "description": "unique channel identifier",
            "in": "path",
            "name": "channel_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "the relayer address to which the distribution address is registered",
            "in": "path",
            "name": "relayer",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryPayeeResponse_defines_the_response_type_for_the_Payee_rpc"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "Payee returns the registered payee address for a specific channel given the relayer address",
        "tags": ["Query"]
      }
    },
    "/ibc/apps/fee/v1/channels/{packet_id.channel_id}/ports/{packet_id.port_id}/sequences/{packet_id.sequence}/incentivized_packet": {
      "get": {
        "operationId": "IncentivizedPacket",
        "parameters": [
          {
            "description": "channel unique identifier",
            "in": "path",
            "name": "packet_id.channel_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "channel port identifier",
            "in": "path",
            "name": "packet_id.port_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "packet sequence",
            "in": "path",
            "name": "packet_id.sequence",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "block height at which to query.",
            "in": "query",
            "name": "query_height",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryIncentivizedPacketsResponse_defines_the_response_type_for_the_IncentivizedPacket_rpc"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "IncentivizedPacket returns all packet fees for a packet given its identifier",
        "tags": ["Query"]
      }
    },
    "/ibc/apps/fee/v1/channels/{packet_id.channel_id}/ports/{packet_id.port_id}/sequences/{packet_id.sequence}/total_ack_fees": {
      "get": {
        "operationId": "TotalAckFees",
        "parameters": [
          {
            "description": "channel unique identifier",
            "in": "path",
            "name": "packet_id.channel_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "channel port identifier",
            "in": "path",
            "name": "packet_id.port_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "packet sequence",
            "in": "path",
            "name": "packet_id.sequence",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryTotalAckFeesResponse_defines_the_response_type_for_the_TotalAckFees_rpc"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "TotalAckFees returns the total acknowledgement fees for a packet given its identifier",
        "tags": ["Query"]
      }
    },
    "/ibc/apps/fee/v1/channels/{packet_id.channel_id}/ports/{packet_id.port_id}/sequences/{packet_id.sequence}/total_recv_fees": {
      "get": {
        "operationId": "TotalRecvFees",
        "parameters": [
          {
            "description": "channel unique identifier",
            "in": "path",
            "name": "packet_id.channel_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "channel port identifier",
            "in": "path",
            "name": "packet_id.port_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "packet sequence",
            "in": "path",
            "name": "packet_id.sequence",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryTotalRecvFeesResponse_defines_the_response_type_for_the_TotalRecvFees_rpc"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "TotalRecvFees returns the total receive fees for a packet given its identifier",
        "tags": ["Query"]
      }
    },
    "/ibc/apps/fee/v1/channels/{packet_id.channel_id}/ports/{packet_id.port_id}/sequences/{packet_id.sequence}/total_timeout_fees": {
      "get": {
        "operationId": "TotalTimeoutFees",
        "parameters": [
          {
            "description": "channel unique identifier",
            "in": "path",
            "name": "packet_id.channel_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "channel port identifier",
            "in": "path",
            "name": "packet_id.port_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "packet sequence",
            "in": "path",
            "name": "packet_id.sequence",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryTotalTimeoutFeesResponse_defines_the_response_type_for_the_TotalTimeoutFees_rpc"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "TotalTimeoutFees returns the total timeout fees for a packet given its identifier",
        "tags": ["Query"]
      }
    },
    "/ibc/apps/fee/v1/fee_enabled": {
      "get": {
        "operationId": "FeeEnabledChannels",
        "parameters": [
          {
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "name": "pagination.key",
            "schema": {
              "format": "byte",
              "type": "string"
            }
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "name": "pagination.offset",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "name": "pagination.limit",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "name": "pagination.count_total",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "name": "pagination.reverse",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "block height at which to query.",
            "in": "query",
            "name": "query_height",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryFeeEnabledChannelsResponse_defines_the_response_type_for_the_FeeEnabledChannels_rpc"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "FeeEnabledChannels returns a list of all fee enabled channels",
        "tags": ["Query"]
      }
    },
    "/ibc/apps/fee/v1/incentivized_packets": {
      "get": {
        "operationId": "IncentivizedPackets",
        "parameters": [
          {
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "name": "pagination.key",
            "schema": {
              "format": "byte",
              "type": "string"
            }
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "name": "pagination.offset",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "name": "pagination.limit",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "name": "pagination.count_total",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "name": "pagination.reverse",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "block height at which to query.",
            "in": "query",
            "name": "query_height",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryIncentivizedPacketsResponse_defines_the_response_type_for_the_IncentivizedPackets_rpc"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "IncentivizedPackets returns all incentivized packets and their associated fees",
        "tags": ["Query"]
      }
    },
    "/ibc/core/client/v1/client_states": {
      "get": {
        "operationId": "ClientStates",
        "parameters": [
          {
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "name": "pagination.key",
            "schema": {
              "format": "byte",
              "type": "string"
            }
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "name": "pagination.offset",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "name": "pagination.limit",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "name": "pagination.count_total",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "name": "pagination.reverse",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/ClientStates_200_response"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "ClientStates queries all the IBC light clients of a chain.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/client/v1/client_states/{client_id}": {
      "get": {
        "operationId": "ClientState",
        "parameters": [
          {
            "description": "client state unique identifier",
            "in": "path",
            "name": "client_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/ClientState_200_response"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "ClientState queries an IBC light client.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/client/v1/client_status/{client_id}": {
      "get": {
        "operationId": "ClientStatus",
        "parameters": [
          {
            "description": "client unique identifier",
            "in": "path",
            "name": "client_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/ClientStatus_200_response"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "Status queries the status of an IBC client.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/client/v1/consensus_states/{client_id}": {
      "get": {
        "operationId": "ConsensusStates",
        "parameters": [
          {
            "description": "client identifier",
            "in": "path",
            "name": "client_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "name": "pagination.key",
            "schema": {
              "format": "byte",
              "type": "string"
            }
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "name": "pagination.offset",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "name": "pagination.limit",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "name": "pagination.count_total",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "name": "pagination.reverse",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryConsensusStatesResponse_is_the_response_type_for_the_Query_ConsensusStates_RPC_method"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "ConsensusStates queries all the consensus state associated with a given\nclient.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/client/v1/consensus_states/{client_id}/heights": {
      "get": {
        "operationId": "ConsensusStateHeights",
        "parameters": [
          {
            "description": "client identifier",
            "in": "path",
            "name": "client_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "name": "pagination.key",
            "schema": {
              "format": "byte",
              "type": "string"
            }
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "name": "pagination.offset",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "name": "pagination.limit",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "name": "pagination.count_total",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "name": "pagination.reverse",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryConsensusStateHeightsResponse_is_the_response_type_for_the_Query_ConsensusStateHeights_RPC_method"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "ConsensusStateHeights queries the height of every consensus states associated with a given client.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/client/v1/consensus_states/{client_id}/revision/{revision_number}/height/{revision_height}": {
      "get": {
        "operationId": "ConsensusState",
        "parameters": [
          {
            "description": "client identifier",
            "in": "path",
            "name": "client_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "consensus state revision number",
            "in": "path",
            "name": "revision_number",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "consensus state revision height",
            "in": "path",
            "name": "revision_height",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "latest_height overrrides the height field and queries the latest stored\nConsensusState.",
            "in": "query",
            "name": "latest_height",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryConsensusStateResponse_is_the_response_type_for_the_Query_ConsensusState_RPC_method"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "ConsensusState queries a consensus state associated with a client state at\na given height.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/client/v1/params": {
      "get": {
        "operationId": "ClientParams",
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/ClientParams_200_response"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "ClientParams queries all parameters of the ibc client submodule.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/client/v1/upgraded_client_states": {
      "get": {
        "operationId": "UpgradedClientState",
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/UpgradedClientState_200_response"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "UpgradedClientState queries an Upgraded IBC light client.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/client/v1/upgraded_consensus_states": {
      "get": {
        "operationId": "UpgradedConsensusState",
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/UpgradedConsensusState_200_response"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "UpgradedConsensusState queries an Upgraded IBC consensus state.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/connection/v1/client_connections/{client_id}": {
      "get": {
        "operationId": "ClientConnections",
        "parameters": [
          {
            "description": "client identifier associated with a connection",
            "in": "path",
            "name": "client_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryClientConnectionsResponse_is_the_response_type_for_the_Query_ClientConnections_RPC_method"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "ClientConnections queries the connection paths associated with a client\nstate.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/connection/v1/connections": {
      "get": {
        "operationId": "Connections",
        "parameters": [
          {
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "name": "pagination.key",
            "schema": {
              "format": "byte",
              "type": "string"
            }
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "name": "pagination.offset",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "name": "pagination.limit",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "name": "pagination.count_total",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "name": "pagination.reverse",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/Connections_200_response"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "Connections queries all the IBC connections of a chain.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/connection/v1/connections/{connection_id}": {
      "get": {
        "operationId": "Connection",
        "parameters": [
          {
            "description": "connection unique identifier",
            "in": "path",
            "name": "connection_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/Connection_200_response"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "Connection queries an IBC connection end.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/connection/v1/connections/{connection_id}/client_state": {
      "get": {
        "operationId": "ConnectionClientState",
        "parameters": [
          {
            "description": "connection identifier",
            "in": "path",
            "name": "connection_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryConnectionClientStateResponse_is_the_response_type_for_the_Query_ConnectionClientState_RPC_method"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "ConnectionClientState queries the client state associated with the\nconnection.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/connection/v1/connections/{connection_id}/consensus_state/revision/{revision_number}/height/{revision_height}": {
      "get": {
        "operationId": "ConnectionConsensusState",
        "parameters": [
          {
            "description": "connection identifier",
            "in": "path",
            "name": "connection_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "revision_number",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "revision_height",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryConnectionConsensusStateResponse_is_the_response_type_for_the_Query_ConnectionConsensusState_RPC_method"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "ConnectionConsensusState queries the consensus state associated with the\nconnection.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/connection/v1/params": {
      "get": {
        "operationId": "ConnectionParams",
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/ConnectionParams_200_response"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "ConnectionParams queries all parameters of the ibc connection submodule.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/channel/v1/channels": {
      "get": {
        "operationId": "Channels",
        "parameters": [
          {
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "name": "pagination.key",
            "schema": {
              "format": "byte",
              "type": "string"
            }
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "name": "pagination.offset",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "name": "pagination.limit",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "name": "pagination.count_total",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "name": "pagination.reverse",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/Channels_200_response"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "Channels queries all the IBC channels of a chain.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}": {
      "get": {
        "operationId": "Channel",
        "parameters": [
          {
            "description": "channel unique identifier",
            "in": "path",
            "name": "channel_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "port unique identifier",
            "in": "path",
            "name": "port_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/Channel_200_response"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "Channel queries an IBC Channel.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/client_state": {
      "get": {
        "operationId": "ChannelClientState",
        "parameters": [
          {
            "description": "channel unique identifier",
            "in": "path",
            "name": "channel_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "port unique identifier",
            "in": "path",
            "name": "port_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryChannelClientStateResponse_is_the_Response_type_for_the_Query_QueryChannelClientState_RPC_method"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "ChannelClientState queries for the client state for the channel associated\nwith the provided channel identifiers.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/consensus_state/revision/{revision_number}/height/{revision_height}": {
      "get": {
        "operationId": "ChannelConsensusState",
        "parameters": [
          {
            "description": "channel unique identifier",
            "in": "path",
            "name": "channel_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "port unique identifier",
            "in": "path",
            "name": "port_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "revision number of the consensus state",
            "in": "path",
            "name": "revision_number",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "revision height of the consensus state",
            "in": "path",
            "name": "revision_height",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryChannelClientStateResponse_is_the_Response_type_for_the_Query_QueryChannelClientState_RPC_method_1"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "ChannelConsensusState queries for the consensus state for the channel\nassociated with the provided channel identifiers.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/next_sequence": {
      "get": {
        "operationId": "NextSequenceReceive",
        "parameters": [
          {
            "description": "channel unique identifier",
            "in": "path",
            "name": "channel_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "port unique identifier",
            "in": "path",
            "name": "port_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QuerySequenceResponse_is_the_request_type_for_the_Query_QueryNextSequenceReceiveResponse_RPC_method"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "NextSequenceReceive returns the next receive sequence for a given channel.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/next_sequence_send": {
      "get": {
        "operationId": "NextSequenceSend",
        "parameters": [
          {
            "description": "channel unique identifier",
            "in": "path",
            "name": "channel_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "port unique identifier",
            "in": "path",
            "name": "port_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryNextSequenceSendResponse_is_the_request_type_for_the_Query_QueryNextSequenceSend_RPC_method"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "NextSequenceSend returns the next send sequence for a given channel.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acknowledgements": {
      "get": {
        "operationId": "PacketAcknowledgements",
        "parameters": [
          {
            "description": "channel unique identifier",
            "in": "path",
            "name": "channel_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "port unique identifier",
            "in": "path",
            "name": "port_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "name": "pagination.key",
            "schema": {
              "format": "byte",
              "type": "string"
            }
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "name": "pagination.offset",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "name": "pagination.limit",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "name": "pagination.count_total",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "name": "pagination.reverse",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "list of packet sequences.",
            "explode": true,
            "in": "query",
            "name": "packet_commitment_sequences",
            "schema": {
              "items": {
                "format": "uint64",
                "type": "string"
              },
              "type": "array"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryPacketAcknowledgemetsResponse_is_the_request_type_for_the_Query_QueryPacketAcknowledgements_RPC_method"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "PacketAcknowledgements returns all the packet acknowledgements associated\nwith a channel.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acks/{sequence}": {
      "get": {
        "operationId": "PacketAcknowledgement",
        "parameters": [
          {
            "description": "channel unique identifier",
            "in": "path",
            "name": "channel_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "port unique identifier",
            "in": "path",
            "name": "port_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "packet sequence",
            "in": "path",
            "name": "sequence",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryPacketAcknowledgementResponse_defines_the_client_query_response_for_a_packet_which_also_includes_a_proof_and_the_height_from_which_the_proof_was_retrieved"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "PacketAcknowledgement queries a stored packet acknowledgement hash.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments": {
      "get": {
        "operationId": "PacketCommitments",
        "parameters": [
          {
            "description": "channel unique identifier",
            "in": "path",
            "name": "channel_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "port unique identifier",
            "in": "path",
            "name": "port_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "name": "pagination.key",
            "schema": {
              "format": "byte",
              "type": "string"
            }
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "name": "pagination.offset",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "name": "pagination.limit",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "name": "pagination.count_total",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "name": "pagination.reverse",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryPacketCommitmentsResponse_is_the_request_type_for_the_Query_QueryPacketCommitments_RPC_method"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "PacketCommitments returns all the packet commitments hashes associated\nwith a channel.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_ack_sequences}/unreceived_acks": {
      "get": {
        "operationId": "UnreceivedAcks",
        "parameters": [
          {
            "description": "channel unique identifier",
            "in": "path",
            "name": "channel_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "port unique identifier",
            "in": "path",
            "name": "port_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "list of acknowledgement sequences",
            "explode": false,
            "in": "path",
            "name": "packet_ack_sequences",
            "required": true,
            "schema": {
              "items": {
                "format": "uint64",
                "type": "string"
              },
              "minItems": 1,
              "type": "array"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryUnreceivedAcksResponse_is_the_response_type_for_the_Query_UnreceivedAcks_RPC_method"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "UnreceivedAcks returns all the unreceived IBC acknowledgements associated\nwith a channel and sequences.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_commitment_sequences}/unreceived_packets": {
      "get": {
        "operationId": "UnreceivedPackets",
        "parameters": [
          {
            "description": "channel unique identifier",
            "in": "path",
            "name": "channel_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "port unique identifier",
            "in": "path",
            "name": "port_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "list of packet sequences",
            "explode": false,
            "in": "path",
            "name": "packet_commitment_sequences",
            "required": true,
            "schema": {
              "items": {
                "format": "uint64",
                "type": "string"
              },
              "minItems": 1,
              "type": "array"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryUnreceivedPacketsResponse_is_the_response_type_for_the_Query_UnreceivedPacketCommitments_RPC_method"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "UnreceivedPackets returns all the unreceived IBC packets associated with a\nchannel and sequences.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{sequence}": {
      "get": {
        "operationId": "PacketCommitment",
        "parameters": [
          {
            "description": "channel unique identifier",
            "in": "path",
            "name": "channel_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "port unique identifier",
            "in": "path",
            "name": "port_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "packet sequence",
            "in": "path",
            "name": "sequence",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryPacketCommitmentResponse_defines_the_client_query_response_for_a_packet_which_also_includes_a_proof_and_the_height_from_which_the_proof_was_retrieved"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "PacketCommitment queries a stored packet commitment hash.",
        "tags": ["Query"]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_receipts/{sequence}": {
      "get": {
        "operationId": "PacketReceipt",
        "parameters": [
          {
            "description": "channel unique identifier",
            "in": "path",
            "name": "channel_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "port unique identifier",
            "in": "path",
            "name": "port_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "packet sequence",
            "in": "path",
            "name": "sequence",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryPacketReceiptResponse_defines_the_client_query_response_for_a_packet_receipt_which_also_includes_a_proof__and_the_height_from_which_the_proof_was_retrieved"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "PacketReceipt queries if a given packet sequence has been received on the\nqueried chain",
        "tags": ["Query"]
      }
    },
    "/ibc/core/channel/v1/connections/{connection}/channels": {
      "get": {
        "operationId": "ConnectionChannels",
        "parameters": [
          {
            "description": "connection unique identifier",
            "in": "path",
            "name": "connection",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "name": "pagination.key",
            "schema": {
              "format": "byte",
              "type": "string"
            }
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "name": "pagination.offset",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "name": "pagination.limit",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "name": "pagination.count_total",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "name": "pagination.reverse",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/QueryConnectionChannelsResponse_is_the_Response_type_for_the_Query_QueryConnectionChannels_RPC_method"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/FeeEnabledChannel_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "ConnectionChannels queries all the channels associated with a connection\nend.",
        "tags": ["Query"]
      }
    },
    "/ibc/lightclients/wasm/v1/code_hashes": {
      "get": {
        "operationId": "CodeHashes",
        "parameters": [
          {
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "name": "pagination.key",
            "schema": {
              "format": "byte",
              "type": "string"
            }
          },
          {
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "name": "pagination.offset",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "name": "pagination.limit",
            "schema": {
              "format": "uint64",
              "type": "string"
            }
          },
          {
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "name": "pagination.count_total",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "name": "pagination.reverse",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/CodeHashes_200_response"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/EscrowAddress_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "Get all Wasm code hashes",
        "tags": ["Query"]
      }
    },
    "/ibc/lightclients/wasm/v1/code_hashes/{code_hash}/code": {
      "get": {
        "operationId": "Code",
        "parameters": [
          {
            "in": "path",
            "name": "code_hash",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/Code_200_response"
                }
              }
            },
            "description": "A successful response."
          },
          "default": {
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/EscrowAddress_default_response"
                }
              }
            },
            "description": "An unexpected error response."
          }
        },
        "summary": "Get Wasm code for given code hash",
        "tags": ["Query"]
      }
    }
  },
  "components": {
    "schemas": {
      "AddressBytesToStringResponse": {
        "description": "AddressBytesToStringResponse is the response type for AddressString rpc method. Since: cosmos-sdk 0.46",
        "example": {
          "addressString": "addressString"
        },
        "properties": {
          "addressString": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "AddressStringToBytesResponse": {
        "description": "AddressStringToBytesResponse is the response type for AddressBytes rpc method. Since: cosmos-sdk 0.46",
        "example": {
          "addressBytes": "addressBytes"
        },
        "properties": {
          "addressBytes": {
            "format": "bytes",
            "type": "string"
          }
        },
        "type": "object"
      },
      "BaseAccount": {
        "description": "BaseAccount defines a base account type. It contains all the necessary fields for basic account functionality. Any custom account type should extend this type for additional functionality (e.g. vesting).",
        "example": {
          "sequence": 6,
          "address": "address",
          "accountNumber": 0,
          "pubKey": {
            "@type": "@type"
          }
        },
        "properties": {
          "address": {
            "type": "string"
          },
          "pubKey": {
            "$ref": "#/components/schemas/GoogleProtobufAny"
          },
          "accountNumber": {
            "format": "uint64",
            "type": "integer"
          },
          "sequence": {
            "format": "uint64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "Bech32PrefixResponse": {
        "description": "Bech32PrefixResponse is the response type for Bech32Prefix rpc method. Since: cosmos-sdk 0.46",
        "example": {
          "bech32Prefix": "bech32Prefix"
        },
        "properties": {
          "bech32Prefix": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "GoogleProtobufAny": {
        "additionalProperties": true,
        "description": "Contains an arbitrary serialized message along with a @type that describes the type of the serialized message.",
        "example": {
          "@type": "@type"
        },
        "properties": {
          "@type": {
            "description": "The type of the serialized message.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "PageResponse": {
        "description": "PageResponse is to be embedded in gRPC response messages where the corresponding request message has used PageRequest.  message SomeResponse {          repeated Bar results = 1;          PageResponse page = 2;  }",
        "example": {
          "total": 0,
          "nextKey": "nextKey"
        },
        "properties": {
          "nextKey": {
            "description": "next_key is the key to be passed to PageRequest.key to query the next page most efficiently. It will be empty if there are no more results.",
            "format": "bytes",
            "type": "string"
          },
          "total": {
            "description": "total is total number of results available if PageRequest.count_total was set, its value is undefined otherwise",
            "format": "uint64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "Params": {
        "description": "Params defines the parameters for the tokenfactory module.",
        "example": {
          "denomCreationFee": [
            {
              "amount": "amount",
              "denom": "denom"
            },
            {
              "amount": "amount",
              "denom": "denom"
            }
          ],
          "denomCreationGasConsume": 0
        },
        "properties": {
          "denomCreationFee": {
            "items": {
              "$ref": "#/components/schemas/Coin"
            },
            "type": "array"
          },
          "denomCreationGasConsume": {
            "description": "if denom_creation_fee is an empty array, then this field is used to add more gas consumption to the base cost. https://github.com/CosmWasm/token-factory/issues/11",
            "format": "uint64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "QueryAccountAddressByIDResponse": {
        "description": "QueryAccountAddressByIDResponse is the response type for AccountAddressByID rpc method Since: cosmos-sdk 0.46.2",
        "example": {
          "accountAddress": "accountAddress"
        },
        "properties": {
          "accountAddress": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "QueryAccountInfoResponse": {
        "description": "QueryAccountInfoResponse is the Query/AccountInfo response type. Since: cosmos-sdk 0.47",
        "example": {
          "info": {
            "sequence": 6,
            "address": "address",
            "accountNumber": 0,
            "pubKey": {
              "@type": "@type"
            }
          }
        },
        "properties": {
          "info": {
            "$ref": "#/components/schemas/BaseAccount"
          }
        },
        "type": "object"
      },
      "QueryAccountResponse": {
        "description": "QueryAccountResponse is the response type for the Query/Account RPC method.",
        "example": {
          "account": {
            "@type": "@type"
          }
        },
        "properties": {
          "account": {
            "$ref": "#/components/schemas/GoogleProtobufAny"
          }
        },
        "type": "object"
      },
      "QueryAccountsResponse": {
        "description": "QueryAccountsResponse is the response type for the Query/Accounts RPC method. Since: cosmos-sdk 0.43",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "accounts": [
            {
              "@type": "@type"
            },
            {
              "@type": "@type"
            }
          ]
        },
        "properties": {
          "accounts": {
            "description": "accounts are the existing accounts",
            "items": {
              "$ref": "#/components/schemas/GoogleProtobufAny"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryModuleAccountByNameResponse": {
        "description": "QueryModuleAccountByNameResponse is the response type for the Query/ModuleAccountByName RPC method.",
        "example": {
          "account": {
            "@type": "@type"
          }
        },
        "properties": {
          "account": {
            "$ref": "#/components/schemas/GoogleProtobufAny"
          }
        },
        "type": "object"
      },
      "QueryModuleAccountsResponse": {
        "description": "QueryModuleAccountsResponse is the response type for the Query/ModuleAccounts RPC method. Since: cosmos-sdk 0.46",
        "example": {
          "accounts": [
            {
              "@type": "@type"
            },
            {
              "@type": "@type"
            }
          ]
        },
        "properties": {
          "accounts": {
            "items": {
              "$ref": "#/components/schemas/GoogleProtobufAny"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "QueryParamsResponse": {
        "description": "QueryParamsResponse is the response type for the Query/Params RPC method.",
        "example": {
          "params": {
            "denomCreationFee": [
              {
                "amount": "amount",
                "denom": "denom"
              },
              {
                "amount": "amount",
                "denom": "denom"
              }
            ],
            "denomCreationGasConsume": 0
          }
        },
        "properties": {
          "params": {
            "$ref": "#/components/schemas/Params"
          }
        },
        "type": "object"
      },
      "Status": {
        "description": "The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).",
        "example": {
          "code": 1,
          "details": [
            {
              "@type": "@type"
            },
            {
              "@type": "@type"
            }
          ],
          "message": "message"
        },
        "properties": {
          "code": {
            "description": "The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].",
            "format": "int32",
            "type": "integer"
          },
          "message": {
            "description": "A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client.",
            "type": "string"
          },
          "details": {
            "description": "A list of messages that carry the error details.  There is a common set of message types for APIs to use.",
            "items": {
              "$ref": "#/components/schemas/GoogleProtobufAny"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "Grant": {
        "description": "Grant is stored in the KVStore to record a grant with full context",
        "example": {
          "grantee": "grantee",
          "allowance": {
            "@type": "@type"
          },
          "granter": "granter"
        },
        "properties": {
          "granter": {
            "description": "granter is the address of the user granting an allowance of their funds.",
            "type": "string"
          },
          "grantee": {
            "description": "grantee is the address of the user being granted an allowance of another user's funds.",
            "type": "string"
          },
          "allowance": {
            "$ref": "#/components/schemas/GoogleProtobufAny"
          }
        },
        "type": "object"
      },
      "GrantAuthorization": {
        "description": "GrantAuthorization extends a grant with both the addresses of the grantee and granter. It is used in genesis.proto and query.proto",
        "example": {
          "authorization": {
            "@type": "@type"
          },
          "grantee": "grantee",
          "expiration": "2000-01-23T04:56:07.000+00:00",
          "granter": "granter"
        },
        "properties": {
          "granter": {
            "type": "string"
          },
          "grantee": {
            "type": "string"
          },
          "authorization": {
            "$ref": "#/components/schemas/GoogleProtobufAny"
          },
          "expiration": {
            "format": "date-time",
            "type": "string"
          }
        },
        "type": "object"
      },
      "QueryGranteeGrantsResponse": {
        "description": "QueryGranteeGrantsResponse is the response type for the Query/GranteeGrants RPC method.",
        "example": {
          "grants": [
            {
              "authorization": {
                "@type": "@type"
              },
              "grantee": "grantee",
              "expiration": "2000-01-23T04:56:07.000+00:00",
              "granter": "granter"
            },
            {
              "authorization": {
                "@type": "@type"
              },
              "grantee": "grantee",
              "expiration": "2000-01-23T04:56:07.000+00:00",
              "granter": "granter"
            }
          ],
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          }
        },
        "properties": {
          "grants": {
            "description": "grants is a list of grants granted to the grantee.",
            "items": {
              "$ref": "#/components/schemas/GrantAuthorization"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryGranterGrantsResponse": {
        "description": "QueryGranterGrantsResponse is the response type for the Query/GranterGrants RPC method.",
        "example": {
          "grants": [
            {
              "authorization": {
                "@type": "@type"
              },
              "grantee": "grantee",
              "expiration": "2000-01-23T04:56:07.000+00:00",
              "granter": "granter"
            },
            {
              "authorization": {
                "@type": "@type"
              },
              "grantee": "grantee",
              "expiration": "2000-01-23T04:56:07.000+00:00",
              "granter": "granter"
            }
          ],
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          }
        },
        "properties": {
          "grants": {
            "description": "grants is a list of grants granted by the granter.",
            "items": {
              "$ref": "#/components/schemas/GrantAuthorization"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryGrantsResponse": {
        "description": "QueryGrantsResponse is the response type for the Query/Authorizations RPC method.",
        "example": {
          "grants": [
            {
              "grantee": "grantee",
              "allowance": {
                "@type": "@type"
              },
              "granter": "granter"
            },
            {
              "grantee": "grantee",
              "allowance": {
                "@type": "@type"
              },
              "granter": "granter"
            }
          ],
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          }
        },
        "properties": {
          "grants": {
            "description": "authorizations is a list of grants granted for grantee by granter.",
            "items": {
              "$ref": "#/components/schemas/Grant"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "Coin": {
        "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.",
        "example": {
          "amount": "amount",
          "denom": "denom"
        },
        "properties": {
          "denom": {
            "type": "string"
          },
          "amount": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "DenomOwner": {
        "description": "DenomOwner defines structure representing an account that owns or holds a particular denominated token. It contains the account address and account balance of the denominated token. Since: cosmos-sdk 0.46",
        "example": {
          "address": "address",
          "balance": {
            "amount": "amount",
            "denom": "denom"
          }
        },
        "properties": {
          "address": {
            "description": "address defines the address that owns a particular denomination.",
            "type": "string"
          },
          "balance": {
            "$ref": "#/components/schemas/Coin"
          }
        },
        "type": "object"
      },
      "DenomUnit": {
        "description": "DenomUnit represents a struct that describes a given denomination unit of the basic token.",
        "example": {
          "aliases": ["aliases", "aliases"],
          "denom": "denom",
          "exponent": 0
        },
        "properties": {
          "denom": {
            "description": "denom represents the string name of the given denom unit (e.g uatom).",
            "type": "string"
          },
          "exponent": {
            "description": "exponent represents power of 10 exponent that one must raise the base_denom to in order to equal the given DenomUnit's denom 1 denom = 10^exponent base_denom (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with exponent = 6, thus: 1 atom = 10^6 uatom).",
            "format": "uint32",
            "type": "integer"
          },
          "aliases": {
            "description": "aliases is a list of string aliases for the given denom",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "Metadata": {
        "description": "Metadata represents a struct that describes a basic token.",
        "example": {
          "symbol": "symbol",
          "uriHash": "uriHash",
          "denomUnits": [
            {
              "aliases": ["aliases", "aliases"],
              "denom": "denom",
              "exponent": 0
            },
            {
              "aliases": ["aliases", "aliases"],
              "denom": "denom",
              "exponent": 0
            }
          ],
          "display": "display",
          "name": "name",
          "description": "description",
          "uri": "uri",
          "base": "base"
        },
        "properties": {
          "description": {
            "type": "string"
          },
          "denomUnits": {
            "description": "denom_units represents the list of DenomUnit's for a given coin",
            "items": {
              "$ref": "#/components/schemas/DenomUnit"
            },
            "type": "array"
          },
          "base": {
            "description": "base represents the base denom (should be the DenomUnit with exponent = 0).",
            "type": "string"
          },
          "display": {
            "description": "display indicates the suggested denom that should be displayed in clients.",
            "type": "string"
          },
          "name": {
            "description": "name defines the name of the token (eg: Cosmos Atom) Since: cosmos-sdk 0.43",
            "type": "string"
          },
          "symbol": {
            "description": "symbol is the token symbol usually shown on exchanges (eg: ATOM). This can be the same as the display. Since: cosmos-sdk 0.43",
            "type": "string"
          },
          "uri": {
            "description": "URI to a document (on or off-chain) that contains additional information. Optional. Since: cosmos-sdk 0.46",
            "type": "string"
          },
          "uriHash": {
            "description": "URIHash is a sha256 hash of a document pointed by URI. It's used to verify that the document didn't change. Optional. Since: cosmos-sdk 0.46",
            "type": "string"
          }
        },
        "type": "object"
      },
      "QueryAllBalancesResponse": {
        "description": "QueryAllBalancesResponse is the response type for the Query/AllBalances RPC method.",
        "example": {
          "balances": [
            {
              "amount": "amount",
              "denom": "denom"
            },
            {
              "amount": "amount",
              "denom": "denom"
            }
          ],
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          }
        },
        "properties": {
          "balances": {
            "description": "balances is the balances of all the coins.",
            "items": {
              "$ref": "#/components/schemas/Coin"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryBalanceResponse": {
        "description": "QueryBalanceResponse is the response type for the Query/Balance RPC method",
        "example": {
          "amount": 0
        },
        "properties": {
          "amount": {
            "description": "amount is the number of all NFTs of a given class owned by the owner",
            "format": "uint64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "QueryDenomMetadataByQueryStringResponse": {
        "description": "QueryDenomMetadataByQueryStringResponse is the response type for the Query/DenomMetadata RPC method. Identical with QueryDenomMetadataResponse but receives denom as query string in request.",
        "example": {
          "metadata": {
            "symbol": "symbol",
            "uriHash": "uriHash",
            "denomUnits": [
              {
                "aliases": ["aliases", "aliases"],
                "denom": "denom",
                "exponent": 0
              },
              {
                "aliases": ["aliases", "aliases"],
                "denom": "denom",
                "exponent": 0
              }
            ],
            "display": "display",
            "name": "name",
            "description": "description",
            "uri": "uri",
            "base": "base"
          }
        },
        "properties": {
          "metadata": {
            "$ref": "#/components/schemas/Metadata"
          }
        },
        "type": "object"
      },
      "QueryDenomMetadataResponse": {
        "description": "QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC method.",
        "example": {
          "metadata": {
            "symbol": "symbol",
            "uriHash": "uriHash",
            "denomUnits": [
              {
                "aliases": ["aliases", "aliases"],
                "denom": "denom",
                "exponent": 0
              },
              {
                "aliases": ["aliases", "aliases"],
                "denom": "denom",
                "exponent": 0
              }
            ],
            "display": "display",
            "name": "name",
            "description": "description",
            "uri": "uri",
            "base": "base"
          }
        },
        "properties": {
          "metadata": {
            "$ref": "#/components/schemas/Metadata"
          }
        },
        "type": "object"
      },
      "QueryDenomOwnersByQueryResponse": {
        "description": "QueryDenomOwnersByQueryResponse defines the RPC response of a DenomOwnersByQuery RPC query. Since: cosmos-sdk 0.50.3",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "denomOwners": [
            {
              "address": "address",
              "balance": {
                "amount": "amount",
                "denom": "denom"
              }
            },
            {
              "address": "address",
              "balance": {
                "amount": "amount",
                "denom": "denom"
              }
            }
          ]
        },
        "properties": {
          "denomOwners": {
            "items": {
              "$ref": "#/components/schemas/DenomOwner"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryDenomOwnersResponse": {
        "description": "QueryDenomOwnersResponse defines the RPC response of a DenomOwners RPC query. Since: cosmos-sdk 0.46",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "denomOwners": [
            {
              "address": "address",
              "balance": {
                "amount": "amount",
                "denom": "denom"
              }
            },
            {
              "address": "address",
              "balance": {
                "amount": "amount",
                "denom": "denom"
              }
            }
          ]
        },
        "properties": {
          "denomOwners": {
            "items": {
              "$ref": "#/components/schemas/DenomOwner"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryDenomsMetadataResponse": {
        "description": "QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC method.",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "metadatas": [
            {
              "symbol": "symbol",
              "uriHash": "uriHash",
              "denomUnits": [
                {
                  "aliases": ["aliases", "aliases"],
                  "denom": "denom",
                  "exponent": 0
                },
                {
                  "aliases": ["aliases", "aliases"],
                  "denom": "denom",
                  "exponent": 0
                }
              ],
              "display": "display",
              "name": "name",
              "description": "description",
              "uri": "uri",
              "base": "base"
            },
            {
              "symbol": "symbol",
              "uriHash": "uriHash",
              "denomUnits": [
                {
                  "aliases": ["aliases", "aliases"],
                  "denom": "denom",
                  "exponent": 0
                },
                {
                  "aliases": ["aliases", "aliases"],
                  "denom": "denom",
                  "exponent": 0
                }
              ],
              "display": "display",
              "name": "name",
              "description": "description",
              "uri": "uri",
              "base": "base"
            }
          ]
        },
        "properties": {
          "metadatas": {
            "description": "metadata provides the client information for all the registered tokens.",
            "items": {
              "$ref": "#/components/schemas/Metadata"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QuerySendEnabledResponse": {
        "description": "QuerySendEnabledResponse defines the RPC response of a SendEnable query. Since: cosmos-sdk 0.47",
        "example": {
          "sendEnabled": [
            {
              "denom": "denom",
              "enabled": true
            },
            {
              "denom": "denom",
              "enabled": true
            }
          ],
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          }
        },
        "properties": {
          "sendEnabled": {
            "items": {
              "$ref": "#/components/schemas/SendEnabled"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QuerySpendableBalanceByDenomResponse": {
        "description": "QuerySpendableBalanceByDenomResponse defines the gRPC response structure for querying an account's spendable balance for a specific denom. Since: cosmos-sdk 0.47",
        "example": {
          "balance": {
            "amount": "amount",
            "denom": "denom"
          }
        },
        "properties": {
          "balance": {
            "$ref": "#/components/schemas/Coin"
          }
        },
        "type": "object"
      },
      "QuerySpendableBalancesResponse": {
        "description": "QuerySpendableBalancesResponse defines the gRPC response structure for querying an account's spendable balances. Since: cosmos-sdk 0.46",
        "example": {
          "balances": [
            {
              "amount": "amount",
              "denom": "denom"
            },
            {
              "amount": "amount",
              "denom": "denom"
            }
          ],
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          }
        },
        "properties": {
          "balances": {
            "description": "balances is the spendable balances of all the coins.",
            "items": {
              "$ref": "#/components/schemas/Coin"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QuerySupplyOfResponse": {
        "description": "QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method.",
        "example": {
          "amount": {
            "amount": "amount",
            "denom": "denom"
          }
        },
        "properties": {
          "amount": {
            "$ref": "#/components/schemas/Coin"
          }
        },
        "type": "object"
      },
      "QueryTotalSupplyResponse": {
        "description": "QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC method",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "supply": [
            {
              "amount": "amount",
              "denom": "denom"
            },
            {
              "amount": "amount",
              "denom": "denom"
            }
          ]
        },
        "properties": {
          "supply": {
            "description": "supply is the supply of the coins",
            "items": {
              "$ref": "#/components/schemas/Coin"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "SendEnabled": {
        "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is sendable).",
        "example": {
          "denom": "denom",
          "enabled": true
        },
        "properties": {
          "denom": {
            "type": "string"
          },
          "enabled": {
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "ConfigResponse": {
        "description": "ConfigResponse defines the response structure for the Config gRPC query.",
        "example": {
          "pruningInterval": "pruningInterval",
          "minimumGasPrice": "minimumGasPrice",
          "pruningKeepRecent": "pruningKeepRecent",
          "haltHeight": 0
        },
        "properties": {
          "minimumGasPrice": {
            "type": "string"
          },
          "pruningKeepRecent": {
            "type": "string"
          },
          "pruningInterval": {
            "type": "string"
          },
          "haltHeight": {
            "format": "uint64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "StatusResponse": {
        "description": "StateResponse defines the response structure for the status of a node.",
        "example": {
          "validatorHash": "validatorHash",
          "appHash": "appHash",
          "earliestStoreHeight": 0,
          "height": 6,
          "timestamp": "2000-01-23T04:56:07.000+00:00"
        },
        "properties": {
          "earliestStoreHeight": {
            "format": "uint64",
            "type": "integer"
          },
          "height": {
            "format": "uint64",
            "type": "integer"
          },
          "timestamp": {
            "format": "date-time",
            "type": "string"
          },
          "appHash": {
            "format": "bytes",
            "type": "string"
          },
          "validatorHash": {
            "format": "bytes",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ABCIQueryResponse": {
        "description": "ABCIQueryResponse defines the response structure for the ABCIQuery gRPC query. Note: This type is a duplicate of the ResponseQuery proto type defined in Tendermint.",
        "example": {
          "proofOps": {
            "ops": [
              {
                "data": "data",
                "type": "type",
                "key": "key"
              },
              {
                "data": "data",
                "type": "type",
                "key": "key"
              }
            ]
          },
          "code": 0,
          "codespace": "codespace",
          "log": "log",
          "index": 6,
          "value": "value",
          "key": "key",
          "info": "info",
          "height": 1
        },
        "properties": {
          "code": {
            "format": "uint32",
            "type": "integer"
          },
          "log": {
            "type": "string"
          },
          "info": {
            "type": "string"
          },
          "index": {
            "format": "int64",
            "type": "integer"
          },
          "key": {
            "format": "bytes",
            "type": "string"
          },
          "value": {
            "format": "bytes",
            "type": "string"
          },
          "proofOps": {
            "$ref": "#/components/schemas/ProofOps"
          },
          "height": {
            "format": "int64",
            "type": "integer"
          },
          "codespace": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "Block": {
        "example": {
          "data": {
            "txs": ["txs", "txs"]
          },
          "evidence": {
            "evidence": [
              {
                "lightClientAttackEvidence": {
                  "commonHeight": 7,
                  "totalVotingPower": 1,
                  "conflictingBlock": {
                    "signedHeader": {
                      "commit": {
                        "blockId": {
                          "partSetHeader": {
                            "total": 0,
                            "hash": "hash"
                          },
                          "hash": "hash"
                        },
                        "round": 7,
                        "signatures": [
                          {
                            "blockIdFlag": 1,
                            "signature": "signature",
                            "validatorAddress": "validatorAddress",
                            "timestamp": "2000-01-23T04:56:07.000+00:00"
                          },
                          {
                            "blockIdFlag": 1,
                            "signature": "signature",
                            "validatorAddress": "validatorAddress",
                            "timestamp": "2000-01-23T04:56:07.000+00:00"
                          }
                        ],
                        "height": 4
                      },
                      "header": {
                        "dataHash": "dataHash",
                        "consensusHash": "consensusHash",
                        "evidenceHash": "evidenceHash",
                        "proposerAddress": "proposerAddress",
                        "appHash": "appHash",
                        "version": {
                          "app": 1,
                          "block": 6
                        },
                        "lastResultsHash": "lastResultsHash",
                        "lastBlockId": {
                          "partSetHeader": {
                            "total": 0,
                            "hash": "hash"
                          },
                          "hash": "hash"
                        },
                        "chainId": "chainId",
                        "validatorsHash": "validatorsHash",
                        "lastCommitHash": "lastCommitHash",
                        "time": "2000-01-23T04:56:07.000+00:00",
                        "nextValidatorsHash": "nextValidatorsHash",
                        "height": 5
                      }
                    },
                    "validatorSet": {
                      "totalVotingPower": 6,
                      "validators": [
                        {
                          "votingPower": 1,
                          "address": "address",
                          "proposerPriority": 1,
                          "pubKey": {
                            "bn254": "bn254",
                            "ed25519": "ed25519",
                            "secp256k1": "secp256k1"
                          }
                        },
                        {
                          "votingPower": 1,
                          "address": "address",
                          "proposerPriority": 1,
                          "pubKey": {
                            "bn254": "bn254",
                            "ed25519": "ed25519",
                            "secp256k1": "secp256k1"
                          }
                        }
                      ],
                      "proposer": {
                        "votingPower": 1,
                        "address": "address",
                        "proposerPriority": 1,
                        "pubKey": {
                          "bn254": "bn254",
                          "ed25519": "ed25519",
                          "secp256k1": "secp256k1"
                        }
                      }
                    }
                  },
                  "byzantineValidators": [
                    {
                      "votingPower": 1,
                      "address": "address",
                      "proposerPriority": 1,
                      "pubKey": {
                        "bn254": "bn254",
                        "ed25519": "ed25519",
                        "secp256k1": "secp256k1"
                      }
                    },
                    {
                      "votingPower": 1,
                      "address": "address",
                      "proposerPriority": 1,
                      "pubKey": {
                        "bn254": "bn254",
                        "ed25519": "ed25519",
                        "secp256k1": "secp256k1"
                      }
                    }
                  ],
                  "timestamp": "2000-01-23T04:56:07.000+00:00"
                },
                "duplicateVoteEvidence": {
                  "totalVotingPower": 3,
                  "voteA": {
                    "blockId": {
                      "partSetHeader": {
                        "total": 0,
                        "hash": "hash"
                      },
                      "hash": "hash"
                    },
                    "extension": "extension",
                    "round": 7,
                    "signature": "signature",
                    "validatorAddress": "validatorAddress",
                    "validatorIndex": 9,
                    "type": 5,
                    "extensionSignature": "extensionSignature",
                    "height": 2,
                    "timestamp": "2000-01-23T04:56:07.000+00:00"
                  },
                  "voteB": {
                    "blockId": {
                      "partSetHeader": {
                        "total": 0,
                        "hash": "hash"
                      },
                      "hash": "hash"
                    },
                    "extension": "extension",
                    "round": 7,
                    "signature": "signature",
                    "validatorAddress": "validatorAddress",
                    "validatorIndex": 9,
                    "type": 5,
                    "extensionSignature": "extensionSignature",
                    "height": 2,
                    "timestamp": "2000-01-23T04:56:07.000+00:00"
                  },
                  "validatorPower": 2,
                  "timestamp": "2000-01-23T04:56:07.000+00:00"
                }
              },
              {
                "lightClientAttackEvidence": {
                  "commonHeight": 7,
                  "totalVotingPower": 1,
                  "conflictingBlock": {
                    "signedHeader": {
                      "commit": {
                        "blockId": {
                          "partSetHeader": {
                            "total": 0,
                            "hash": "hash"
                          },
                          "hash": "hash"
                        },
                        "round": 7,
                        "signatures": [
                          {
                            "blockIdFlag": 1,
                            "signature": "signature",
                            "validatorAddress": "validatorAddress",
                            "timestamp": "2000-01-23T04:56:07.000+00:00"
                          },
                          {
                            "blockIdFlag": 1,
                            "signature": "signature",
                            "validatorAddress": "validatorAddress",
                            "timestamp": "2000-01-23T04:56:07.000+00:00"
                          }
                        ],
                        "height": 4
                      },
                      "header": {
                        "dataHash": "dataHash",
                        "consensusHash": "consensusHash",
                        "evidenceHash": "evidenceHash",
                        "proposerAddress": "proposerAddress",
                        "appHash": "appHash",
                        "version": {
                          "app": 1,
                          "block": 6
                        },
                        "lastResultsHash": "lastResultsHash",
                        "lastBlockId": {
                          "partSetHeader": {
                            "total": 0,
                            "hash": "hash"
                          },
                          "hash": "hash"
                        },
                        "chainId": "chainId",
                        "validatorsHash": "validatorsHash",
                        "lastCommitHash": "lastCommitHash",
                        "time": "2000-01-23T04:56:07.000+00:00",
                        "nextValidatorsHash": "nextValidatorsHash",
                        "height": 5
                      }
                    },
                    "validatorSet": {
                      "totalVotingPower": 6,
                      "validators": [
                        {
                          "votingPower": 1,
                          "address": "address",
                          "proposerPriority": 1,
                          "pubKey": {
                            "bn254": "bn254",
                            "ed25519": "ed25519",
                            "secp256k1": "secp256k1"
                          }
                        },
                        {
                          "votingPower": 1,
                          "address": "address",
                          "proposerPriority": 1,
                          "pubKey": {
                            "bn254": "bn254",
                            "ed25519": "ed25519",
                            "secp256k1": "secp256k1"
                          }
                        }
                      ],
                      "proposer": {
                        "votingPower": 1,
                        "address": "address",
                        "proposerPriority": 1,
                        "pubKey": {
                          "bn254": "bn254",
                          "ed25519": "ed25519",
                          "secp256k1": "secp256k1"
                        }
                      }
                    }
                  },
                  "byzantineValidators": [
                    {
                      "votingPower": 1,
                      "address": "address",
                      "proposerPriority": 1,
                      "pubKey": {
                        "bn254": "bn254",
                        "ed25519": "ed25519",
                        "secp256k1": "secp256k1"
                      }
                    },
                    {
                      "votingPower": 1,
                      "address": "address",
                      "proposerPriority": 1,
                      "pubKey": {
                        "bn254": "bn254",
                        "ed25519": "ed25519",
                        "secp256k1": "secp256k1"
                      }
                    }
                  ],
                  "timestamp": "2000-01-23T04:56:07.000+00:00"
                },
                "duplicateVoteEvidence": {
                  "totalVotingPower": 3,
                  "voteA": {
                    "blockId": {
                      "partSetHeader": {
                        "total": 0,
                        "hash": "hash"
                      },
                      "hash": "hash"
                    },
                    "extension": "extension",
                    "round": 7,
                    "signature": "signature",
                    "validatorAddress": "validatorAddress",
                    "validatorIndex": 9,
                    "type": 5,
                    "extensionSignature": "extensionSignature",
                    "height": 2,
                    "timestamp": "2000-01-23T04:56:07.000+00:00"
                  },
                  "voteB": {
                    "blockId": {
                      "partSetHeader": {
                        "total": 0,
                        "hash": "hash"
                      },
                      "hash": "hash"
                    },
                    "extension": "extension",
                    "round": 7,
                    "signature": "signature",
                    "validatorAddress": "validatorAddress",
                    "validatorIndex": 9,
                    "type": 5,
                    "extensionSignature": "extensionSignature",
                    "height": 2,
                    "timestamp": "2000-01-23T04:56:07.000+00:00"
                  },
                  "validatorPower": 2,
                  "timestamp": "2000-01-23T04:56:07.000+00:00"
                }
              }
            ]
          },
          "header": {
            "dataHash": "dataHash",
            "consensusHash": "consensusHash",
            "evidenceHash": "evidenceHash",
            "proposerAddress": "proposerAddress",
            "appHash": "appHash",
            "version": {
              "app": 1,
              "block": 6
            },
            "lastResultsHash": "lastResultsHash",
            "lastBlockId": {
              "partSetHeader": {
                "total": 0,
                "hash": "hash"
              },
              "hash": "hash"
            },
            "chainId": "chainId",
            "validatorsHash": "validatorsHash",
            "lastCommitHash": "lastCommitHash",
            "time": "2000-01-23T04:56:07.000+00:00",
            "nextValidatorsHash": "nextValidatorsHash",
            "height": 5
          },
          "lastCommit": {
            "blockId": {
              "partSetHeader": {
                "total": 0,
                "hash": "hash"
              },
              "hash": "hash"
            },
            "round": 7,
            "signatures": [
              {
                "blockIdFlag": 1,
                "signature": "signature",
                "validatorAddress": "validatorAddress",
                "timestamp": "2000-01-23T04:56:07.000+00:00"
              },
              {
                "blockIdFlag": 1,
                "signature": "signature",
                "validatorAddress": "validatorAddress",
                "timestamp": "2000-01-23T04:56:07.000+00:00"
              }
            ],
            "height": 4
          }
        },
        "properties": {
          "header": {
            "$ref": "#/components/schemas/Header"
          },
          "data": {
            "$ref": "#/components/schemas/Data"
          },
          "evidence": {
            "$ref": "#/components/schemas/EvidenceList"
          },
          "lastCommit": {
            "$ref": "#/components/schemas/Commit"
          }
        },
        "type": "object"
      },
      "BlockID": {
        "description": "BlockID",
        "example": {
          "partSetHeader": {
            "total": 0,
            "hash": "hash"
          },
          "hash": "hash"
        },
        "properties": {
          "hash": {
            "format": "bytes",
            "type": "string"
          },
          "partSetHeader": {
            "$ref": "#/components/schemas/PartSetHeader"
          }
        },
        "type": "object"
      },
      "Commit": {
        "description": "Commit contains the evidence that a block was committed by a set of validators.",
        "example": {
          "blockId": {
            "partSetHeader": {
              "total": 0,
              "hash": "hash"
            },
            "hash": "hash"
          },
          "round": 7,
          "signatures": [
            {
              "blockIdFlag": 1,
              "signature": "signature",
              "validatorAddress": "validatorAddress",
              "timestamp": "2000-01-23T04:56:07.000+00:00"
            },
            {
              "blockIdFlag": 1,
              "signature": "signature",
              "validatorAddress": "validatorAddress",
              "timestamp": "2000-01-23T04:56:07.000+00:00"
            }
          ],
          "height": 4
        },
        "properties": {
          "height": {
            "format": "int64",
            "type": "integer"
          },
          "round": {
            "format": "int32",
            "type": "integer"
          },
          "blockId": {
            "$ref": "#/components/schemas/BlockID"
          },
          "signatures": {
            "items": {
              "$ref": "#/components/schemas/CommitSig"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "CommitSig": {
        "description": "CommitSig is a part of the Vote included in a Commit.",
        "example": {
          "blockIdFlag": 1,
          "signature": "signature",
          "validatorAddress": "validatorAddress",
          "timestamp": "2000-01-23T04:56:07.000+00:00"
        },
        "properties": {
          "blockIdFlag": {
            "format": "enum",
            "type": "integer"
          },
          "validatorAddress": {
            "format": "bytes",
            "type": "string"
          },
          "timestamp": {
            "format": "date-time",
            "type": "string"
          },
          "signature": {
            "format": "bytes",
            "type": "string"
          }
        },
        "type": "object"
      },
      "Consensus": {
        "description": "Consensus captures the consensus rules for processing a block in the blockchain, including all blockchain data structures and the rules of the application's state transition machine.",
        "example": {
          "app": 1,
          "block": 6
        },
        "properties": {
          "block": {
            "format": "uint64",
            "type": "integer"
          },
          "app": {
            "format": "uint64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "Data": {
        "description": "Data contains the set of transactions included in the block",
        "example": {
          "txs": ["txs", "txs"]
        },
        "properties": {
          "txs": {
            "description": "Txs that will be applied by state @ block.Height+1. NOTE: not all txs here are valid.  We're just agreeing on the order first. This means that block.AppHash does not include these txs.",
            "items": {
              "format": "bytes",
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "DefaultNodeInfo": {
        "example": {
          "other": {
            "rpcAddress": "rpcAddress",
            "txIndex": "txIndex"
          },
          "channels": "channels",
          "listenAddr": "listenAddr",
          "protocolVersion": {
            "app": 1,
            "block": 6,
            "p2p": 0
          },
          "defaultNodeId": "defaultNodeId",
          "moniker": "moniker",
          "version": "version",
          "network": "network"
        },
        "properties": {
          "protocolVersion": {
            "$ref": "#/components/schemas/ProtocolVersion"
          },
          "defaultNodeId": {
            "type": "string"
          },
          "listenAddr": {
            "type": "string"
          },
          "network": {
            "type": "string"
          },
          "version": {
            "type": "string"
          },
          "channels": {
            "format": "bytes",
            "type": "string"
          },
          "moniker": {
            "type": "string"
          },
          "other": {
            "$ref": "#/components/schemas/DefaultNodeInfoOther"
          }
        },
        "type": "object"
      },
      "DefaultNodeInfoOther": {
        "example": {
          "rpcAddress": "rpcAddress",
          "txIndex": "txIndex"
        },
        "properties": {
          "txIndex": {
            "type": "string"
          },
          "rpcAddress": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "DuplicateVoteEvidence": {
        "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.",
        "example": {
          "totalVotingPower": 3,
          "voteA": {
            "blockId": {
              "partSetHeader": {
                "total": 0,
                "hash": "hash"
              },
              "hash": "hash"
            },
            "extension": "extension",
            "round": 7,
            "signature": "signature",
            "validatorAddress": "validatorAddress",
            "validatorIndex": 9,
            "type": 5,
            "extensionSignature": "extensionSignature",
            "height": 2,
            "timestamp": "2000-01-23T04:56:07.000+00:00"
          },
          "voteB": {
            "blockId": {
              "partSetHeader": {
                "total": 0,
                "hash": "hash"
              },
              "hash": "hash"
            },
            "extension": "extension",
            "round": 7,
            "signature": "signature",
            "validatorAddress": "validatorAddress",
            "validatorIndex": 9,
            "type": 5,
            "extensionSignature": "extensionSignature",
            "height": 2,
            "timestamp": "2000-01-23T04:56:07.000+00:00"
          },
          "validatorPower": 2,
          "timestamp": "2000-01-23T04:56:07.000+00:00"
        },
        "properties": {
          "voteA": {
            "$ref": "#/components/schemas/Vote"
          },
          "voteB": {
            "$ref": "#/components/schemas/Vote"
          },
          "totalVotingPower": {
            "format": "int64",
            "type": "integer"
          },
          "validatorPower": {
            "format": "int64",
            "type": "integer"
          },
          "timestamp": {
            "format": "date-time",
            "type": "string"
          }
        },
        "type": "object"
      },
      "Evidence": {
        "example": {
          "lightClientAttackEvidence": {
            "commonHeight": 7,
            "totalVotingPower": 1,
            "conflictingBlock": {
              "signedHeader": {
                "commit": {
                  "blockId": {
                    "partSetHeader": {
                      "total": 0,
                      "hash": "hash"
                    },
                    "hash": "hash"
                  },
                  "round": 7,
                  "signatures": [
                    {
                      "blockIdFlag": 1,
                      "signature": "signature",
                      "validatorAddress": "validatorAddress",
                      "timestamp": "2000-01-23T04:56:07.000+00:00"
                    },
                    {
                      "blockIdFlag": 1,
                      "signature": "signature",
                      "validatorAddress": "validatorAddress",
                      "timestamp": "2000-01-23T04:56:07.000+00:00"
                    }
                  ],
                  "height": 4
                },
                "header": {
                  "dataHash": "dataHash",
                  "consensusHash": "consensusHash",
                  "evidenceHash": "evidenceHash",
                  "proposerAddress": "proposerAddress",
                  "appHash": "appHash",
                  "version": {
                    "app": 1,
                    "block": 6
                  },
                  "lastResultsHash": "lastResultsHash",
                  "lastBlockId": {
                    "partSetHeader": {
                      "total": 0,
                      "hash": "hash"
                    },
                    "hash": "hash"
                  },
                  "chainId": "chainId",
                  "validatorsHash": "validatorsHash",
                  "lastCommitHash": "lastCommitHash",
                  "time": "2000-01-23T04:56:07.000+00:00",
                  "nextValidatorsHash": "nextValidatorsHash",
                  "height": 5
                }
              },
              "validatorSet": {
                "totalVotingPower": 6,
                "validators": [
                  {
                    "votingPower": 1,
                    "address": "address",
                    "proposerPriority": 1,
                    "pubKey": {
                      "bn254": "bn254",
                      "ed25519": "ed25519",
                      "secp256k1": "secp256k1"
                    }
                  },
                  {
                    "votingPower": 1,
                    "address": "address",
                    "proposerPriority": 1,
                    "pubKey": {
                      "bn254": "bn254",
                      "ed25519": "ed25519",
                      "secp256k1": "secp256k1"
                    }
                  }
                ],
                "proposer": {
                  "votingPower": 1,
                  "address": "address",
                  "proposerPriority": 1,
                  "pubKey": {
                    "bn254": "bn254",
                    "ed25519": "ed25519",
                    "secp256k1": "secp256k1"
                  }
                }
              }
            },
            "byzantineValidators": [
              {
                "votingPower": 1,
                "address": "address",
                "proposerPriority": 1,
                "pubKey": {
                  "bn254": "bn254",
                  "ed25519": "ed25519",
                  "secp256k1": "secp256k1"
                }
              },
              {
                "votingPower": 1,
                "address": "address",
                "proposerPriority": 1,
                "pubKey": {
                  "bn254": "bn254",
                  "ed25519": "ed25519",
                  "secp256k1": "secp256k1"
                }
              }
            ],
            "timestamp": "2000-01-23T04:56:07.000+00:00"
          },
          "duplicateVoteEvidence": {
            "totalVotingPower": 3,
            "voteA": {
              "blockId": {
                "partSetHeader": {
                  "total": 0,
                  "hash": "hash"
                },
                "hash": "hash"
              },
              "extension": "extension",
              "round": 7,
              "signature": "signature",
              "validatorAddress": "validatorAddress",
              "validatorIndex": 9,
              "type": 5,
              "extensionSignature": "extensionSignature",
              "height": 2,
              "timestamp": "2000-01-23T04:56:07.000+00:00"
            },
            "voteB": {
              "blockId": {
                "partSetHeader": {
                  "total": 0,
                  "hash": "hash"
                },
                "hash": "hash"
              },
              "extension": "extension",
              "round": 7,
              "signature": "signature",
              "validatorAddress": "validatorAddress",
              "validatorIndex": 9,
              "type": 5,
              "extensionSignature": "extensionSignature",
              "height": 2,
              "timestamp": "2000-01-23T04:56:07.000+00:00"
            },
            "validatorPower": 2,
            "timestamp": "2000-01-23T04:56:07.000+00:00"
          }
        },
        "properties": {
          "duplicateVoteEvidence": {
            "$ref": "#/components/schemas/DuplicateVoteEvidence"
          },
          "lightClientAttackEvidence": {
            "$ref": "#/components/schemas/LightClientAttackEvidence"
          }
        },
        "type": "object"
      },
      "EvidenceList": {
        "example": {
          "evidence": [
            {
              "lightClientAttackEvidence": {
                "commonHeight": 7,
                "totalVotingPower": 1,
                "conflictingBlock": {
                  "signedHeader": {
                    "commit": {
                      "blockId": {
                        "partSetHeader": {
                          "total": 0,
                          "hash": "hash"
                        },
                        "hash": "hash"
                      },
                      "round": 7,
                      "signatures": [
                        {
                          "blockIdFlag": 1,
                          "signature": "signature",
                          "validatorAddress": "validatorAddress",
                          "timestamp": "2000-01-23T04:56:07.000+00:00"
                        },
                        {
                          "blockIdFlag": 1,
                          "signature": "signature",
                          "validatorAddress": "validatorAddress",
                          "timestamp": "2000-01-23T04:56:07.000+00:00"
                        }
                      ],
                      "height": 4
                    },
                    "header": {
                      "dataHash": "dataHash",
                      "consensusHash": "consensusHash",
                      "evidenceHash": "evidenceHash",
                      "proposerAddress": "proposerAddress",
                      "appHash": "appHash",
                      "version": {
                        "app": 1,
                        "block": 6
                      },
                      "lastResultsHash": "lastResultsHash",
                      "lastBlockId": {
                        "partSetHeader": {
                          "total": 0,
                          "hash": "hash"
                        },
                        "hash": "hash"
                      },
                      "chainId": "chainId",
                      "validatorsHash": "validatorsHash",
                      "lastCommitHash": "lastCommitHash",
                      "time": "2000-01-23T04:56:07.000+00:00",
                      "nextValidatorsHash": "nextValidatorsHash",
                      "height": 5
                    }
                  },
                  "validatorSet": {
                    "totalVotingPower": 6,
                    "validators": [
                      {
                        "votingPower": 1,
                        "address": "address",
                        "proposerPriority": 1,
                        "pubKey": {
                          "bn254": "bn254",
                          "ed25519": "ed25519",
                          "secp256k1": "secp256k1"
                        }
                      },
                      {
                        "votingPower": 1,
                        "address": "address",
                        "proposerPriority": 1,
                        "pubKey": {
                          "bn254": "bn254",
                          "ed25519": "ed25519",
                          "secp256k1": "secp256k1"
                        }
                      }
                    ],
                    "proposer": {
                      "votingPower": 1,
                      "address": "address",
                      "proposerPriority": 1,
                      "pubKey": {
                        "bn254": "bn254",
                        "ed25519": "ed25519",
                        "secp256k1": "secp256k1"
                      }
                    }
                  }
                },
                "byzantineValidators": [
                  {
                    "votingPower": 1,
                    "address": "address",
                    "proposerPriority": 1,
                    "pubKey": {
                      "bn254": "bn254",
                      "ed25519": "ed25519",
                      "secp256k1": "secp256k1"
                    }
                  },
                  {
                    "votingPower": 1,
                    "address": "address",
                    "proposerPriority": 1,
                    "pubKey": {
                      "bn254": "bn254",
                      "ed25519": "ed25519",
                      "secp256k1": "secp256k1"
                    }
                  }
                ],
                "timestamp": "2000-01-23T04:56:07.000+00:00"
              },
              "duplicateVoteEvidence": {
                "totalVotingPower": 3,
                "voteA": {
                  "blockId": {
                    "partSetHeader": {
                      "total": 0,
                      "hash": "hash"
                    },
                    "hash": "hash"
                  },
                  "extension": "extension",
                  "round": 7,
                  "signature": "signature",
                  "validatorAddress": "validatorAddress",
                  "validatorIndex": 9,
                  "type": 5,
                  "extensionSignature": "extensionSignature",
                  "height": 2,
                  "timestamp": "2000-01-23T04:56:07.000+00:00"
                },
                "voteB": {
                  "blockId": {
                    "partSetHeader": {
                      "total": 0,
                      "hash": "hash"
                    },
                    "hash": "hash"
                  },
                  "extension": "extension",
                  "round": 7,
                  "signature": "signature",
                  "validatorAddress": "validatorAddress",
                  "validatorIndex": 9,
                  "type": 5,
                  "extensionSignature": "extensionSignature",
                  "height": 2,
                  "timestamp": "2000-01-23T04:56:07.000+00:00"
                },
                "validatorPower": 2,
                "timestamp": "2000-01-23T04:56:07.000+00:00"
              }
            },
            {
              "lightClientAttackEvidence": {
                "commonHeight": 7,
                "totalVotingPower": 1,
                "conflictingBlock": {
                  "signedHeader": {
                    "commit": {
                      "blockId": {
                        "partSetHeader": {
                          "total": 0,
                          "hash": "hash"
                        },
                        "hash": "hash"
                      },
                      "round": 7,
                      "signatures": [
                        {
                          "blockIdFlag": 1,
                          "signature": "signature",
                          "validatorAddress": "validatorAddress",
                          "timestamp": "2000-01-23T04:56:07.000+00:00"
                        },
                        {
                          "blockIdFlag": 1,
                          "signature": "signature",
                          "validatorAddress": "validatorAddress",
                          "timestamp": "2000-01-23T04:56:07.000+00:00"
                        }
                      ],
                      "height": 4
                    },
                    "header": {
                      "dataHash": "dataHash",
                      "consensusHash": "consensusHash",
                      "evidenceHash": "evidenceHash",
                      "proposerAddress": "proposerAddress",
                      "appHash": "appHash",
                      "version": {
                        "app": 1,
                        "block": 6
                      },
                      "lastResultsHash": "lastResultsHash",
                      "lastBlockId": {
                        "partSetHeader": {
                          "total": 0,
                          "hash": "hash"
                        },
                        "hash": "hash"
                      },
                      "chainId": "chainId",
                      "validatorsHash": "validatorsHash",
                      "lastCommitHash": "lastCommitHash",
                      "time": "2000-01-23T04:56:07.000+00:00",
                      "nextValidatorsHash": "nextValidatorsHash",
                      "height": 5
                    }
                  },
                  "validatorSet": {
                    "totalVotingPower": 6,
                    "validators": [
                      {
                        "votingPower": 1,
                        "address": "address",
                        "proposerPriority": 1,
                        "pubKey": {
                          "bn254": "bn254",
                          "ed25519": "ed25519",
                          "secp256k1": "secp256k1"
                        }
                      },
                      {
                        "votingPower": 1,
                        "address": "address",
                        "proposerPriority": 1,
                        "pubKey": {
                          "bn254": "bn254",
                          "ed25519": "ed25519",
                          "secp256k1": "secp256k1"
                        }
                      }
                    ],
                    "proposer": {
                      "votingPower": 1,
                      "address": "address",
                      "proposerPriority": 1,
                      "pubKey": {
                        "bn254": "bn254",
                        "ed25519": "ed25519",
                        "secp256k1": "secp256k1"
                      }
                    }
                  }
                },
                "byzantineValidators": [
                  {
                    "votingPower": 1,
                    "address": "address",
                    "proposerPriority": 1,
                    "pubKey": {
                      "bn254": "bn254",
                      "ed25519": "ed25519",
                      "secp256k1": "secp256k1"
                    }
                  },
                  {
                    "votingPower": 1,
                    "address": "address",
                    "proposerPriority": 1,
                    "pubKey": {
                      "bn254": "bn254",
                      "ed25519": "ed25519",
                      "secp256k1": "secp256k1"
                    }
                  }
                ],
                "timestamp": "2000-01-23T04:56:07.000+00:00"
              },
              "duplicateVoteEvidence": {
                "totalVotingPower": 3,
                "voteA": {
                  "blockId": {
                    "partSetHeader": {
                      "total": 0,
                      "hash": "hash"
                    },
                    "hash": "hash"
                  },
                  "extension": "extension",
                  "round": 7,
                  "signature": "signature",
                  "validatorAddress": "validatorAddress",
                  "validatorIndex": 9,
                  "type": 5,
                  "extensionSignature": "extensionSignature",
                  "height": 2,
                  "timestamp": "2000-01-23T04:56:07.000+00:00"
                },
                "voteB": {
                  "blockId": {
                    "partSetHeader": {
                      "total": 0,
                      "hash": "hash"
                    },
                    "hash": "hash"
                  },
                  "extension": "extension",
                  "round": 7,
                  "signature": "signature",
                  "validatorAddress": "validatorAddress",
                  "validatorIndex": 9,
                  "type": 5,
                  "extensionSignature": "extensionSignature",
                  "height": 2,
                  "timestamp": "2000-01-23T04:56:07.000+00:00"
                },
                "validatorPower": 2,
                "timestamp": "2000-01-23T04:56:07.000+00:00"
              }
            }
          ]
        },
        "properties": {
          "evidence": {
            "items": {
              "$ref": "#/components/schemas/Evidence"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "GetBlockByHeightResponse": {
        "description": "GetBlockByHeightResponse is the response type for the Query/GetBlockByHeight RPC method.",
        "example": {
          "blockId": {
            "partSetHeader": {
              "total": 0,
              "hash": "hash"
            },
            "hash": "hash"
          },
          "sdkBlock": {
            "data": {
              "txs": ["txs", "txs"]
            },
            "evidence": {
              "evidence": [
                {
                  "lightClientAttackEvidence": {
                    "commonHeight": 7,
                    "totalVotingPower": 1,
                    "conflictingBlock": {
                      "signedHeader": {
                        "commit": {
                          "blockId": {
                            "partSetHeader": {
                              "total": 0,
                              "hash": "hash"
                            },
                            "hash": "hash"
                          },
                          "round": 7,
                          "signatures": [
                            {
                              "blockIdFlag": 1,
                              "signature": "signature",
                              "validatorAddress": "validatorAddress",
                              "timestamp": "2000-01-23T04:56:07.000+00:00"
                            },
                            {
                              "blockIdFlag": 1,
                              "signature": "signature",
                              "validatorAddress": "validatorAddress",
                              "timestamp": "2000-01-23T04:56:07.000+00:00"
                            }
                          ],
                          "height": 4
                        },
                        "header": {
                          "dataHash": "dataHash",
                          "consensusHash": "consensusHash",
                          "evidenceHash": "evidenceHash",
                          "proposerAddress": "proposerAddress",
                          "appHash": "appHash",
                          "version": {
                            "app": 1,
                            "block": 6
                          },
                          "lastResultsHash": "lastResultsHash",
                          "lastBlockId": {
                            "partSetHeader": {
                              "total": 0,
                              "hash": "hash"
                            },
                            "hash": "hash"
                          },
                          "chainId": "chainId",
                          "validatorsHash": "validatorsHash",
                          "lastCommitHash": "lastCommitHash",
                          "time": "2000-01-23T04:56:07.000+00:00",
                          "nextValidatorsHash": "nextValidatorsHash",
                          "height": 5
                        }
                      },
                      "validatorSet": {
                        "totalVotingPower": 6,
                        "validators": [
                          {
                            "votingPower": 1,
                            "address": "address",
                            "proposerPriority": 1,
                            "pubKey": {
                              "bn254": "bn254",
                              "ed25519": "ed25519",
                              "secp256k1": "secp256k1"
                            }
                          },
                          {
                            "votingPower": 1,
                            "address": "address",
                            "proposerPriority": 1,
                            "pubKey": {
                              "bn254": "bn254",
                              "ed25519": "ed25519",
                              "secp256k1": "secp256k1"
                            }
                          }
                        ],
                        "proposer": {
                          "votingPower": 1,
                          "address": "address",
                          "proposerPriority": 1,
                          "pubKey": {
                            "bn254": "bn254",
                            "ed25519": "ed25519",
                            "secp256k1": "secp256k1"
                          }
                        }
                      }
                    },
                    "byzantineValidators": [
                      {
                        "votingPower": 1,
                        "address": "address",
                        "proposerPriority": 1,
                        "pubKey": {
                          "bn254": "bn254",
                          "ed25519": "ed25519",
                          "secp256k1": "secp256k1"
                        }
                      },
                      {
                        "votingPower": 1,
                        "address": "address",
                        "proposerPriority": 1,
                        "pubKey": {
                          "bn254": "bn254",
                          "ed25519": "ed25519",
                          "secp256k1": "secp256k1"
                        }
                      }
                    ],
                    "timestamp": "2000-01-23T04:56:07.000+00:00"
                  },
                  "duplicateVoteEvidence": {
                    "totalVotingPower": 3,
                    "voteA": {
                      "blockId": {
                        "partSetHeader": {
                          "total": 0,
                          "hash": "hash"
                        },
                        "hash": "hash"
                      },
                      "extension": "extension",
                      "round": 7,
                      "signature": "signature",
                      "validatorAddress": "validatorAddress",
                      "validatorIndex": 9,
                      "type": 5,
                      "extensionSignature": "extensionSignature",
                      "height": 2,
                      "timestamp": "2000-01-23T04:56:07.000+00:00"
                    },
                    "voteB": {
                      "blockId": {
                        "partSetHeader": {
                          "total": 0,
                          "hash": "hash"
                        },
                        "hash": "hash"
                      },
                      "extension": "extension",
                      "round": 7,
                      "signature": "signature",
                      "validatorAddress": "validatorAddress",
                      "validatorIndex": 9,
                      "type": 5,
                      "extensionSignature": "extensionSignature",
                      "height": 2,
                      "timestamp": "2000-01-23T04:56:07.000+00:00"
                    },
                    "validatorPower": 2,
                    "timestamp": "2000-01-23T04:56:07.000+00:00"
                  }
                },
                {
                  "lightClientAttackEvidence": {
                    "commonHeight": 7,
                    "totalVotingPower": 1,
                    "conflictingBlock": {
                      "signedHeader": {
                        "commit": {
                          "blockId": {
                            "partSetHeader": {
                              "total": 0,
                              "hash": "hash"
                            },
                            "hash": "hash"
                          },
                          "round": 7,
                          "signatures": [
                            {
                              "blockIdFlag": 1,
                              "signature": "signature",
                              "validatorAddress": "validatorAddress",
                              "timestamp": "2000-01-23T04:56:07.000+00:00"
                            },
                            {
                              "blockIdFlag": 1,
                              "signature": "signature",
                              "validatorAddress": "validatorAddress",
                              "timestamp": "2000-01-23T04:56:07.000+00:00"
                            }
                          ],
                          "height": 4
                        },
                        "header": {
                          "dataHash": "dataHash",
                          "consensusHash": "consensusHash",
                          "evidenceHash": "evidenceHash",
                          "proposerAddress": "proposerAddress",
                          "appHash": "appHash",
                          "version": {
                            "app": 1,
                            "block": 6
                          },
                          "lastResultsHash": "lastResultsHash",
                          "lastBlockId": {
                            "partSetHeader": {
                              "total": 0,
                              "hash": "hash"
                            },
                            "hash": "hash"
                          },
                          "chainId": "chainId",
                          "validatorsHash": "validatorsHash",
                          "lastCommitHash": "lastCommitHash",
                          "time": "2000-01-23T04:56:07.000+00:00",
                          "nextValidatorsHash": "nextValidatorsHash",
                          "height": 5
                        }
                      },
                      "validatorSet": {
                        "totalVotingPower": 6,
                        "validators": [
                          {
                            "votingPower": 1,
                            "address": "address",
                            "proposerPriority": 1,
                            "pubKey": {
                              "bn254": "bn254",
                              "ed25519": "ed25519",
                              "secp256k1": "secp256k1"
                            }
                          },
                          {
                            "votingPower": 1,
                            "address": "address",
                            "proposerPriority": 1,
                            "pubKey": {
                              "bn254": "bn254",
                              "ed25519": "ed25519",
                              "secp256k1": "secp256k1"
                            }
                          }
                        ],
                        "proposer": {
                          "votingPower": 1,
                          "address": "address",
                          "proposerPriority": 1,
                          "pubKey": {
                            "bn254": "bn254",
                            "ed25519": "ed25519",
                            "secp256k1": "secp256k1"
                          }
                        }
                      }
                    },
                    "byzantineValidators": [
                      {
                        "votingPower": 1,
                        "address": "address",
                        "proposerPriority": 1,
                        "pubKey": {
                          "bn254": "bn254",
                          "ed25519": "ed25519",
                          "secp256k1": "secp256k1"
                        }
                      },
                      {
                        "votingPower": 1,
                        "address": "address",
                        "proposerPriority": 1,
                        "pubKey": {
                          "bn254": "bn254",
                          "ed25519": "ed25519",
                          "secp256k1": "secp256k1"
                        }
                      }
                    ],
                    "timestamp": "2000-01-23T04:56:07.000+00:00"
                  },
                  "duplicateVoteEvidence": {
                    "totalVotingPower": 3,
                    "voteA": {
                      "blockId": {
                        "partSetHeader": {
                          "total": 0,
                          "hash": "hash"
                        },
                        "hash": "hash"
                      },
                      "extension": "extension",
                      "round": 7,
                      "signature": "signature",
                      "validatorAddress": "validatorAddress",
                      "validatorIndex": 9,
                      "type": 5,
                      "extensionSignature": "extensionSignature",
                      "height": 2,
                      "timestamp": "2000-01-23T04:56:07.000+00:00"
                    },
                    "voteB": {
                      "blockId": {
                        "partSetHeader": {
                          "total": 0,
                          "hash": "hash"
                        },
                        "hash": "hash"
                      },
                      "extension": "extension",
                      "round": 7,
                      "signature": "signature",
                      "validatorAddress": "validatorAddress",
                      "validatorIndex": 9,
                      "type": 5,
                      "extensionSignature": "extensionSignature",
                      "height": 2,
                      "timestamp": "2000-01-23T04:56:07.000+00:00"
                    },
                    "validatorPower": 2,
                    "timestamp": "2000-01-23T04:56:07.000+00:00"
                  }
                }
              ]
            },
            "header": {
              "dataHash": "dataHash",
              "consensusHash": "consensusHash",
              "evidenceHash": "evidenceHash",
              "proposerAddress": "proposerAddress",
              "appHash": "appHash",
              "version": {
                "app": 1,
                "block": 6
              },
              "lastResultsHash": "lastResultsHash",
              "lastBlockId": {
                "partSetHeader": {
                  "total": 0,
                  "hash": "hash"
                },
                "hash": "hash"
              },
              "chainId": "chainId",
              "validatorsHash": "validatorsHash",
              "lastCommitHash": "lastCommitHash",
              "time": "2000-01-23T04:56:07.000+00:00",
              "nextValidatorsHash": "nextValidatorsHash",
              "height": 5
            },
            "lastCommit": {
              "blockId": {
                "partSetHeader": {
                  "total": 0,
                  "hash": "hash"
                },
                "hash": "hash"
              },
              "round": 7,
              "signatures": [
                {
                  "blockIdFlag": 1,
                  "signature": "signature",
                  "validatorAddress": "validatorAddress",
                  "timestamp": "2000-01-23T04:56:07.000+00:00"
                },
                {
                  "blockIdFlag": 1,
                  "signature": "signature",
                  "validatorAddress": "validatorAddress",
                  "timestamp": "2000-01-23T04:56:07.000+00:00"
                }
              ],
              "height": 4
            }
          },
          "block": {
            "data": {
              "txs": ["txs", "txs"]
            },
            "evidence": {
              "evidence": [
                {
                  "lightClientAttackEvidence": {
                    "commonHeight": 7,
                    "totalVotingPower": 1,
                    "conflictingBlock": {
                      "signedHeader": {
                        "commit": {
                          "blockId": {
                            "partSetHeader": {
                              "total": 0,
                              "hash": "hash"
                            },
                            "hash": "hash"
                          },
                          "round": 7,
                          "signatures": [
                            {
                              "blockIdFlag": 1,
                              "signature": "signature",
                              "validatorAddress": "validatorAddress",
                              "timestamp": "2000-01-23T04:56:07.000+00:00"
                            },
                            {
                              "blockIdFlag": 1,
                              "signature": "signature",
                              "validatorAddress": "validatorAddress",
                              "timestamp": "2000-01-23T04:56:07.000+00:00"
                            }
                          ],
                          "height": 4
                        },
                        "header": {
                          "dataHash": "dataHash",
                          "consensusHash": "consensusHash",
                          "evidenceHash": "evidenceHash",
                          "proposerAddress": "proposerAddress",
                          "appHash": "appHash",
                          "version": {
                            "app": 1,
                            "block": 6
                          },
                          "lastResultsHash": "lastResultsHash",
                          "lastBlockId": {
                            "partSetHeader": {
                              "total": 0,
                              "hash": "hash"
                            },
                            "hash": "hash"
                          },
                          "chainId": "chainId",
                          "validatorsHash": "validatorsHash",
                          "lastCommitHash": "lastCommitHash",
                          "time": "2000-01-23T04:56:07.000+00:00",
                          "nextValidatorsHash": "nextValidatorsHash",
                          "height": 5
                        }
                      },
                      "validatorSet": {
                        "totalVotingPower": 6,
                        "validators": [
                          {
                            "votingPower": 1,
                            "address": "address",
                            "proposerPriority": 1,
                            "pubKey": {
                              "bn254": "bn254",
                              "ed25519": "ed25519",
                              "secp256k1": "secp256k1"
                            }
                          },
                          {
                            "votingPower": 1,
                            "address": "address",
                            "proposerPriority": 1,
                            "pubKey": {
                              "bn254": "bn254",
                              "ed25519": "ed25519",
                              "secp256k1": "secp256k1"
                            }
                          }
                        ],
                        "proposer": {
                          "votingPower": 1,
                          "address": "address",
                          "proposerPriority": 1,
                          "pubKey": {
                            "bn254": "bn254",
                            "ed25519": "ed25519",
                            "secp256k1": "secp256k1"
                          }
                        }
                      }
                    },
                    "byzantineValidators": [
                      {
                        "votingPower": 1,
                        "address": "address",
                        "proposerPriority": 1,
                        "pubKey": {
                          "bn254": "bn254",
                          "ed25519": "ed25519",
                          "secp256k1": "secp256k1"
                        }
                      },
                      {
                        "votingPower": 1,
                        "address": "address",
                        "proposerPriority": 1,
                        "pubKey": {
                          "bn254": "bn254",
                          "ed25519": "ed25519",
                          "secp256k1": "secp256k1"
                        }
                      }
                    ],
                    "timestamp": "2000-01-23T04:56:07.000+00:00"
                  },
                  "duplicateVoteEvidence": {
                    "totalVotingPower": 3,
                    "voteA": {
                      "blockId": {
                        "partSetHeader": {
                          "total": 0,
                          "hash": "hash"
                        },
                        "hash": "hash"
                      },
                      "extension": "extension",
                      "round": 7,
                      "signature": "signature",
                      "validatorAddress": "validatorAddress",
                      "validatorIndex": 9,
                      "type": 5,
                      "extensionSignature": "extensionSignature",
                      "height": 2,
                      "timestamp": "2000-01-23T04:56:07.000+00:00"
                    },
                    "voteB": {
                      "blockId": {
                        "partSetHeader": {
                          "total": 0,
                          "hash": "hash"
                        },
                        "hash": "hash"
                      },
                      "extension": "extension",
                      "round": 7,
                      "signature": "signature",
                      "validatorAddress": "validatorAddress",
                      "validatorIndex": 9,
                      "type": 5,
                      "extensionSignature": "extensionSignature",
                      "height": 2,
                      "timestamp": "2000-01-23T04:56:07.000+00:00"
                    },
                    "validatorPower": 2,
                    "timestamp": "2000-01-23T04:56:07.000+00:00"
                  }
                },
                {
                  "lightClientAttackEvidence": {
                    "commonHeight": 7,
                    "totalVotingPower": 1,
                    "conflictingBlock": {
                      "signedHeader": {
                        "commit": {
                          "blockId": {
                            "partSetHeader": {
                              "total": 0,
                              "hash": "hash"
                            },
                            "hash": "hash"
                          },
                          "round": 7,
                          "signatures": [
                            {
                              "blockIdFlag": 1,
                              "signature": "signature",
                              "validatorAddress": "validatorAddress",
                              "timestamp": "2000-01-23T04:56:07.000+00:00"
                            },
                            {
                              "blockIdFlag": 1,
                              "signature": "signature",
                              "validatorAddress": "validatorAddress",
                              "timestamp": "2000-01-23T04:56:07.000+00:00"
                            }
                          ],
                          "height": 4
                        },
                        "header": {
                          "dataHash": "dataHash",
                          "consensusHash": "consensusHash",
                          "evidenceHash": "evidenceHash",
                          "proposerAddress": "proposerAddress",
                          "appHash": "appHash",
                          "version": {
                            "app": 1,
                            "block": 6
                          },
                          "lastResultsHash": "lastResultsHash",
                          "lastBlockId": {
                            "partSetHeader": {
                              "total": 0,
                              "hash": "hash"
                            },
                            "hash": "hash"
                          },
                          "chainId": "chainId",
                          "validatorsHash": "validatorsHash",
                          "lastCommitHash": "lastCommitHash",
                          "time": "2000-01-23T04:56:07.000+00:00",
                          "nextValidatorsHash": "nextValidatorsHash",
                          "height": 5
                        }
                      },
                      "validatorSet": {
                        "totalVotingPower": 6,
                        "validators": [
                          {
                            "votingPower": 1,
                            "address": "address",
                            "proposerPriority": 1,
                            "pubKey": {
                              "bn254": "bn254",
                              "ed25519": "ed25519",
                              "secp256k1": "secp256k1"
                            }
                          },
                          {
                            "votingPower": 1,
                            "address": "address",
                            "proposerPriority": 1,
                            "pubKey": {
                              "bn254": "bn254",
                              "ed25519": "ed25519",
                              "secp256k1": "secp256k1"
                            }
                          }
                        ],
                        "proposer": {
                          "votingPower": 1,
                          "address": "address",
                          "proposerPriority": 1,
                          "pubKey": {
                            "bn254": "bn254",
                            "ed25519": "ed25519",
                            "secp256k1": "secp256k1"
                          }
                        }
                      }
                    },
                    "byzantineValidators": [
                      {
                        "votingPower": 1,
                        "address": "address",
                        "proposerPriority": 1,
                        "pubKey": {
                          "bn254": "bn254",
                          "ed25519": "ed25519",
                          "secp256k1": "secp256k1"
                        }
                      },
                      {
                        "votingPower": 1,
                        "address": "address",
                        "proposerPriority": 1,
                        "pubKey": {
                          "bn254": "bn254",
                          "ed25519": "ed25519",
                          "secp256k1": "secp256k1"
                        }
                      }
                    ],
                    "timestamp": "2000-01-23T04:56:07.000+00:00"
                  },
                  "duplicateVoteEvidence": {
                    "totalVotingPower": 3,
                    "voteA": {
                      "blockId": {
                        "partSetHeader": {
                          "total": 0,
                          "hash": "hash"
                        },
                        "hash": "hash"
                      },
                      "extension": "extension",
                      "round": 7,
                      "signature": "signature",
                      "validatorAddress": "validatorAddress",
                      "validatorIndex": 9,
                      "type": 5,
                      "extensionSignature": "extensionSignature",
                      "height": 2,
                      "timestamp": "2000-01-23T04:56:07.000+00:00"
                    },
                    "voteB": {
                      "blockId": {
                        "partSetHeader": {
                          "total": 0,
                          "hash": "hash"
                        },
                        "hash": "hash"
                      },
                      "extension": "extension",
                      "round": 7,
                      "signature": "signature",
                      "validatorAddress": "validatorAddress",
                      "validatorIndex": 9,
                      "type": 5,
                      "extensionSignature": "extensionSignature",
                      "height": 2,
                      "timestamp": "2000-01-23T04:56:07.000+00:00"
                    },
                    "validatorPower": 2,
                    "timestamp": "2000-01-23T04:56:07.000+00:00"
                  }
                }
              ]
            },
            "header": {
              "dataHash": "dataHash",
              "consensusHash": "consensusHash",
              "evidenceHash": "evidenceHash",
              "proposerAddress": "proposerAddress",
              "appHash": "appHash",
              "version": {
                "app": 1,
                "block": 6
              },
              "lastResultsHash": "lastResultsHash",
              "lastBlockId": {
                "partSetHeader": {
                  "total": 0,
                  "hash": "hash"
                },
                "hash": "hash"
              },
              "chainId": "chainId",
              "validatorsHash": "validatorsHash",
              "lastCommitHash": "lastCommitHash",
              "time": "2000-01-23T04:56:07.000+00:00",
              "nextValidatorsHash": "nextValidatorsHash",
              "height": 5
            },
            "lastCommit": {
              "blockId": {
                "partSetHeader": {
                  "total": 0,
                  "hash": "hash"
                },
                "hash": "hash"
              },
              "round": 7,
              "signatures": [
                {
                  "blockIdFlag": 1,
                  "signature": "signature",
                  "validatorAddress": "validatorAddress",
                  "timestamp": "2000-01-23T04:56:07.000+00:00"
                },
                {
                  "blockIdFlag": 1,
                  "signature": "signature",
                  "validatorAddress": "validatorAddress",
                  "timestamp": "2000-01-23T04:56:07.000+00:00"
                }
              ],
              "height": 4
            }
          }
        },
        "properties": {
          "blockId": {
            "$ref": "#/components/schemas/BlockID"
          },
          "block": {
            "$ref": "#/components/schemas/Block"
          },
          "sdkBlock": {
            "$ref": "#/components/schemas/Block"
          }
        },
        "type": "object"
      },
      "GetLatestBlockResponse": {
        "description": "GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC method.",
        "example": {
          "blockId": {
            "partSetHeader": {
              "total": 0,
              "hash": "hash"
            },
            "hash": "hash"
          },
          "sdkBlock": {
            "data": {
              "txs": ["txs", "txs"]
            },
            "evidence": {
              "evidence": [
                {
                  "lightClientAttackEvidence": {
                    "commonHeight": 7,
                    "totalVotingPower": 1,
                    "conflictingBlock": {
                      "signedHeader": {
                        "commit": {
                          "blockId": {
                            "partSetHeader": {
                              "total": 0,
                              "hash": "hash"
                            },
                            "hash": "hash"
                          },
                          "round": 7,
                          "signatures": [
                            {
                              "blockIdFlag": 1,
                              "signature": "signature",
                              "validatorAddress": "validatorAddress",
                              "timestamp": "2000-01-23T04:56:07.000+00:00"
                            },
                            {
                              "blockIdFlag": 1,
                              "signature": "signature",
                              "validatorAddress": "validatorAddress",
                              "timestamp": "2000-01-23T04:56:07.000+00:00"
                            }
                          ],
                          "height": 4
                        },
                        "header": {
                          "dataHash": "dataHash",
                          "consensusHash": "consensusHash",
                          "evidenceHash": "evidenceHash",
                          "proposerAddress": "proposerAddress",
                          "appHash": "appHash",
                          "version": {
                            "app": 1,
                            "block": 6
                          },
                          "lastResultsHash": "lastResultsHash",
                          "lastBlockId": {
                            "partSetHeader": {
                              "total": 0,
                              "hash": "hash"
                            },
                            "hash": "hash"
                          },
                          "chainId": "chainId",
                          "validatorsHash": "validatorsHash",
                          "lastCommitHash": "lastCommitHash",
                          "time": "2000-01-23T04:56:07.000+00:00",
                          "nextValidatorsHash": "nextValidatorsHash",
                          "height": 5
                        }
                      },
                      "validatorSet": {
                        "totalVotingPower": 6,
                        "validators": [
                          {
                            "votingPower": 1,
                            "address": "address",
                            "proposerPriority": 1,
                            "pubKey": {
                              "bn254": "bn254",
                              "ed25519": "ed25519",
                              "secp256k1": "secp256k1"
                            }
                          },
                          {
                            "votingPower": 1,
                            "address": "address",
                            "proposerPriority": 1,
                            "pubKey": {
                              "bn254": "bn254",
                              "ed25519": "ed25519",
                              "secp256k1": "secp256k1"
                            }
                          }
                        ],
                        "proposer": {
                          "votingPower": 1,
                          "address": "address",
                          "proposerPriority": 1,
                          "pubKey": {
                            "bn254": "bn254",
                            "ed25519": "ed25519",
                            "secp256k1": "secp256k1"
                          }
                        }
                      }
                    },
                    "byzantineValidators": [
                      {
                        "votingPower": 1,
                        "address": "address",
                        "proposerPriority": 1,
                        "pubKey": {
                          "bn254": "bn254",
                          "ed25519": "ed25519",
                          "secp256k1": "secp256k1"
                        }
                      },
                      {
                        "votingPower": 1,
                        "address": "address",
                        "proposerPriority": 1,
                        "pubKey": {
                          "bn254": "bn254",
                          "ed25519": "ed25519",
                          "secp256k1": "secp256k1"
                        }
                      }
                    ],
                    "timestamp": "2000-01-23T04:56:07.000+00:00"
                  },
                  "duplicateVoteEvidence": {
                    "totalVotingPower": 3,
                    "voteA": {
                      "blockId": {
                        "partSetHeader": {
                          "total": 0,
                          "hash": "hash"
                        },
                        "hash": "hash"
                      },
                      "extension": "extension",
                      "round": 7,
                      "signature": "signature",
                      "validatorAddress": "validatorAddress",
                      "validatorIndex": 9,
                      "type": 5,
                      "extensionSignature": "extensionSignature",
                      "height": 2,
                      "timestamp": "2000-01-23T04:56:07.000+00:00"
                    },
                    "voteB": {
                      "blockId": {
                        "partSetHeader": {
                          "total": 0,
                          "hash": "hash"
                        },
                        "hash": "hash"
                      },
                      "extension": "extension",
                      "round": 7,
                      "signature": "signature",
                      "validatorAddress": "validatorAddress",
                      "validatorIndex": 9,
                      "type": 5,
                      "extensionSignature": "extensionSignature",
                      "height": 2,
                      "timestamp": "2000-01-23T04:56:07.000+00:00"
                    },
                    "validatorPower": 2,
                    "timestamp": "2000-01-23T04:56:07.000+00:00"
                  }
                },
                {
                  "lightClientAttackEvidence": {
                    "commonHeight": 7,
                    "totalVotingPower": 1,
                    "conflictingBlock": {
                      "signedHeader": {
                        "commit": {
                          "blockId": {
                            "partSetHeader": {
                              "total": 0,
                              "hash": "hash"
                            },
                            "hash": "hash"
                          },
                          "round": 7,
                          "signatures": [
                            {
                              "blockIdFlag": 1,
                              "signature": "signature",
                              "validatorAddress": "validatorAddress",
                              "timestamp": "2000-01-23T04:56:07.000+00:00"
                            },
                            {
                              "blockIdFlag": 1,
                              "signature": "signature",
                              "validatorAddress": "validatorAddress",
                              "timestamp": "2000-01-23T04:56:07.000+00:00"
                            }
                          ],
                          "height": 4
                        },
                        "header": {
                          "dataHash": "dataHash",
                          "consensusHash": "consensusHash",
                          "evidenceHash": "evidenceHash",
                          "proposerAddress": "proposerAddress",
                          "appHash": "appHash",
                          "version": {
                            "app": 1,
                            "block": 6
                          },
                          "lastResultsHash": "lastResultsHash",
                          "lastBlockId": {
                            "partSetHeader": {
                              "total": 0,
                              "hash": "hash"
                            },
                            "hash": "hash"
                          },
                          "chainId": "chainId",
                          "validatorsHash": "validatorsHash",
                          "lastCommitHash": "lastCommitHash",
                          "time": "2000-01-23T04:56:07.000+00:00",
                          "nextValidatorsHash": "nextValidatorsHash",
                          "height": 5
                        }
                      },
                      "validatorSet": {
                        "totalVotingPower": 6,
                        "validators": [
                          {
                            "votingPower": 1,
                            "address": "address",
                            "proposerPriority": 1,
                            "pubKey": {
                              "bn254": "bn254",
                              "ed25519": "ed25519",
                              "secp256k1": "secp256k1"
                            }
                          },
                          {
                            "votingPower": 1,
                            "address": "address",
                            "proposerPriority": 1,
                            "pubKey": {
                              "bn254": "bn254",
                              "ed25519": "ed25519",
                              "secp256k1": "secp256k1"
                            }
                          }
                        ],
                        "proposer": {
                          "votingPower": 1,
                          "address": "address",
                          "proposerPriority": 1,
                          "pubKey": {
                            "bn254": "bn254",
                            "ed25519": "ed25519",
                            "secp256k1": "secp256k1"
                          }
                        }
                      }
                    },
                    "byzantineValidators": [
                      {
                        "votingPower": 1,
                        "address": "address",
                        "proposerPriority": 1,
                        "pubKey": {
                          "bn254": "bn254",
                          "ed25519": "ed25519",
                          "secp256k1": "secp256k1"
                        }
                      },
                      {
                        "votingPower": 1,
                        "address": "address",
                        "proposerPriority": 1,
                        "pubKey": {
                          "bn254": "bn254",
                          "ed25519": "ed25519",
                          "secp256k1": "secp256k1"
                        }
                      }
                    ],
                    "timestamp": "2000-01-23T04:56:07.000+00:00"
                  },
                  "duplicateVoteEvidence": {
                    "totalVotingPower": 3,
                    "voteA": {
                      "blockId": {
                        "partSetHeader": {
                          "total": 0,
                          "hash": "hash"
                        },
                        "hash": "hash"
                      },
                      "extension": "extension",
                      "round": 7,
                      "signature": "signature",
                      "validatorAddress": "validatorAddress",
                      "validatorIndex": 9,
                      "type": 5,
                      "extensionSignature": "extensionSignature",
                      "height": 2,
                      "timestamp": "2000-01-23T04:56:07.000+00:00"
                    },
                    "voteB": {
                      "blockId": {
                        "partSetHeader": {
                          "total": 0,
                          "hash": "hash"
                        },
                        "hash": "hash"
                      },
                      "extension": "extension",
                      "round": 7,
                      "signature": "signature",
                      "validatorAddress": "validatorAddress",
                      "validatorIndex": 9,
                      "type": 5,
                      "extensionSignature": "extensionSignature",
                      "height": 2,
                      "timestamp": "2000-01-23T04:56:07.000+00:00"
                    },
                    "validatorPower": 2,
                    "timestamp": "2000-01-23T04:56:07.000+00:00"
                  }
                }
              ]
            },
            "header": {
              "dataHash": "dataHash",
              "consensusHash": "consensusHash",
              "evidenceHash": "evidenceHash",
              "proposerAddress": "proposerAddress",
              "appHash": "appHash",
              "version": {
                "app": 1,
                "block": 6
              },
              "lastResultsHash": "lastResultsHash",
              "lastBlockId": {
                "partSetHeader": {
                  "total": 0,
                  "hash": "hash"
                },
                "hash": "hash"
              },
              "chainId": "chainId",
              "validatorsHash": "validatorsHash",
              "lastCommitHash": "lastCommitHash",
              "time": "2000-01-23T04:56:07.000+00:00",
              "nextValidatorsHash": "nextValidatorsHash",
              "height": 5
            },
            "lastCommit": {
              "blockId": {
                "partSetHeader": {
                  "total": 0,
                  "hash": "hash"
                },
                "hash": "hash"
              },
              "round": 7,
              "signatures": [
                {
                  "blockIdFlag": 1,
                  "signature": "signature",
                  "validatorAddress": "validatorAddress",
                  "timestamp": "2000-01-23T04:56:07.000+00:00"
                },
                {
                  "blockIdFlag": 1,
                  "signature": "signature",
                  "validatorAddress": "validatorAddress",
                  "timestamp": "2000-01-23T04:56:07.000+00:00"
                }
              ],
              "height": 4
            }
          },
          "block": {
            "data": {
              "txs": ["txs", "txs"]
            },
            "evidence": {
              "evidence": [
                {
                  "lightClientAttackEvidence": {
                    "commonHeight": 7,
                    "totalVotingPower": 1,
                    "conflictingBlock": {
                      "signedHeader": {
                        "commit": {
                          "blockId": {
                            "partSetHeader": {
                              "total": 0,
                              "hash": "hash"
                            },
                            "hash": "hash"
                          },
                          "round": 7,
                          "signatures": [
                            {
                              "blockIdFlag": 1,
                              "signature": "signature",
                              "validatorAddress": "validatorAddress",
                              "timestamp": "2000-01-23T04:56:07.000+00:00"
                            },
                            {
                              "blockIdFlag": 1,
                              "signature": "signature",
                              "validatorAddress": "validatorAddress",
                              "timestamp": "2000-01-23T04:56:07.000+00:00"
                            }
                          ],
                          "height": 4
                        },
                        "header": {
                          "dataHash": "dataHash",
                          "consensusHash": "consensusHash",
                          "evidenceHash": "evidenceHash",
                          "proposerAddress": "proposerAddress",
                          "appHash": "appHash",
                          "version": {
                            "app": 1,
                            "block": 6
                          },
                          "lastResultsHash": "lastResultsHash",
                          "lastBlockId": {
                            "partSetHeader": {
                              "total": 0,
                              "hash": "hash"
                            },
                            "hash": "hash"
                          },
                          "chainId": "chainId",
                          "validatorsHash": "validatorsHash",
                          "lastCommitHash": "lastCommitHash",
                          "time": "2000-01-23T04:56:07.000+00:00",
                          "nextValidatorsHash": "nextValidatorsHash",
                          "height": 5
                        }
                      },
                      "validatorSet": {
                        "totalVotingPower": 6,
                        "validators": [
                          {
                            "votingPower": 1,
                            "address": "address",
                            "proposerPriority": 1,
                            "pubKey": {
                              "bn254": "bn254",
                              "ed25519": "ed25519",
                              "secp256k1": "secp256k1"
                            }
                          },
                          {
                            "votingPower": 1,
                            "address": "address",
                            "proposerPriority": 1,
                            "pubKey": {
                              "bn254": "bn254",
                              "ed25519": "ed25519",
                              "secp256k1": "secp256k1"
                            }
                          }
                        ],
                        "proposer": {
                          "votingPower": 1,
                          "address": "address",
                          "proposerPriority": 1,
                          "pubKey": {
                            "bn254": "bn254",
                            "ed25519": "ed25519",
                            "secp256k1": "secp256k1"
                          }
                        }
                      }
                    },
                    "byzantineValidators": [
                      {
                        "votingPower": 1,
                        "address": "address",
                        "proposerPriority": 1,
                        "pubKey": {
                          "bn254": "bn254",
                          "ed25519": "ed25519",
                          "secp256k1": "secp256k1"
                        }
                      },
                      {
                        "votingPower": 1,
                        "address": "address",
                        "proposerPriority": 1,
                        "pubKey": {
                          "bn254": "bn254",
                          "ed25519": "ed25519",
                          "secp256k1": "secp256k1"
                        }
                      }
                    ],
                    "timestamp": "2000-01-23T04:56:07.000+00:00"
                  },
                  "duplicateVoteEvidence": {
                    "totalVotingPower": 3,
                    "voteA": {
                      "blockId": {
                        "partSetHeader": {
                          "total": 0,
                          "hash": "hash"
                        },
                        "hash": "hash"
                      },
                      "extension": "extension",
                      "round": 7,
                      "signature": "signature",
                      "validatorAddress": "validatorAddress",
                      "validatorIndex": 9,
                      "type": 5,
                      "extensionSignature": "extensionSignature",
                      "height": 2,
                      "timestamp": "2000-01-23T04:56:07.000+00:00"
                    },
                    "voteB": {
                      "blockId": {
                        "partSetHeader": {
                          "total": 0,
                          "hash": "hash"
                        },
                        "hash": "hash"
                      },
                      "extension": "extension",
                      "round": 7,
                      "signature": "signature",
                      "validatorAddress": "validatorAddress",
                      "validatorIndex": 9,
                      "type": 5,
                      "extensionSignature": "extensionSignature",
                      "height": 2,
                      "timestamp": "2000-01-23T04:56:07.000+00:00"
                    },
                    "validatorPower": 2,
                    "timestamp": "2000-01-23T04:56:07.000+00:00"
                  }
                },
                {
                  "lightClientAttackEvidence": {
                    "commonHeight": 7,
                    "totalVotingPower": 1,
                    "conflictingBlock": {
                      "signedHeader": {
                        "commit": {
                          "blockId": {
                            "partSetHeader": {
                              "total": 0,
                              "hash": "hash"
                            },
                            "hash": "hash"
                          },
                          "round": 7,
                          "signatures": [
                            {
                              "blockIdFlag": 1,
                              "signature": "signature",
                              "validatorAddress": "validatorAddress",
                              "timestamp": "2000-01-23T04:56:07.000+00:00"
                            },
                            {
                              "blockIdFlag": 1,
                              "signature": "signature",
                              "validatorAddress": "validatorAddress",
                              "timestamp": "2000-01-23T04:56:07.000+00:00"
                            }
                          ],
                          "height": 4
                        },
                        "header": {
                          "dataHash": "dataHash",
                          "consensusHash": "consensusHash",
                          "evidenceHash": "evidenceHash",
                          "proposerAddress": "proposerAddress",
                          "appHash": "appHash",
                          "version": {
                            "app": 1,
                            "block": 6
                          },
                          "lastResultsHash": "lastResultsHash",
                          "lastBlockId": {
                            "partSetHeader": {
                              "total": 0,
                              "hash": "hash"
                            },
                            "hash": "hash"
                          },
                          "chainId": "chainId",
                          "validatorsHash": "validatorsHash",
                          "lastCommitHash": "lastCommitHash",
                          "time": "2000-01-23T04:56:07.000+00:00",
                          "nextValidatorsHash": "nextValidatorsHash",
                          "height": 5
                        }
                      },
                      "validatorSet": {
                        "totalVotingPower": 6,
                        "validators": [
                          {
                            "votingPower": 1,
                            "address": "address",
                            "proposerPriority": 1,
                            "pubKey": {
                              "bn254": "bn254",
                              "ed25519": "ed25519",
                              "secp256k1": "secp256k1"
                            }
                          },
                          {
                            "votingPower": 1,
                            "address": "address",
                            "proposerPriority": 1,
                            "pubKey": {
                              "bn254": "bn254",
                              "ed25519": "ed25519",
                              "secp256k1": "secp256k1"
                            }
                          }
                        ],
                        "proposer": {
                          "votingPower": 1,
                          "address": "address",
                          "proposerPriority": 1,
                          "pubKey": {
                            "bn254": "bn254",
                            "ed25519": "ed25519",
                            "secp256k1": "secp256k1"
                          }
                        }
                      }
                    },
                    "byzantineValidators": [
                      {
                        "votingPower": 1,
                        "address": "address",
                        "proposerPriority": 1,
                        "pubKey": {
                          "bn254": "bn254",
                          "ed25519": "ed25519",
                          "secp256k1": "secp256k1"
                        }
                      },
                      {
                        "votingPower": 1,
                        "address": "address",
                        "proposerPriority": 1,
                        "pubKey": {
                          "bn254": "bn254",
                          "ed25519": "ed25519",
                          "secp256k1": "secp256k1"
                        }
                      }
                    ],
                    "timestamp": "2000-01-23T04:56:07.000+00:00"
                  },
                  "duplicateVoteEvidence": {
                    "totalVotingPower": 3,
                    "voteA": {
                      "blockId": {
                        "partSetHeader": {
                          "total": 0,
                          "hash": "hash"
                        },
                        "hash": "hash"
                      },
                      "extension": "extension",
                      "round": 7,
                      "signature": "signature",
                      "validatorAddress": "validatorAddress",
                      "validatorIndex": 9,
                      "type": 5,
                      "extensionSignature": "extensionSignature",
                      "height": 2,
                      "timestamp": "2000-01-23T04:56:07.000+00:00"
                    },
                    "voteB": {
                      "blockId": {
                        "partSetHeader": {
                          "total": 0,
                          "hash": "hash"
                        },
                        "hash": "hash"
                      },
                      "extension": "extension",
                      "round": 7,
                      "signature": "signature",
                      "validatorAddress": "validatorAddress",
                      "validatorIndex": 9,
                      "type": 5,
                      "extensionSignature": "extensionSignature",
                      "height": 2,
                      "timestamp": "2000-01-23T04:56:07.000+00:00"
                    },
                    "validatorPower": 2,
                    "timestamp": "2000-01-23T04:56:07.000+00:00"
                  }
                }
              ]
            },
            "header": {
              "dataHash": "dataHash",
              "consensusHash": "consensusHash",
              "evidenceHash": "evidenceHash",
              "proposerAddress": "proposerAddress",
              "appHash": "appHash",
              "version": {
                "app": 1,
                "block": 6
              },
              "lastResultsHash": "lastResultsHash",
              "lastBlockId": {
                "partSetHeader": {
                  "total": 0,
                  "hash": "hash"
                },
                "hash": "hash"
              },
              "chainId": "chainId",
              "validatorsHash": "validatorsHash",
              "lastCommitHash": "lastCommitHash",
              "time": "2000-01-23T04:56:07.000+00:00",
              "nextValidatorsHash": "nextValidatorsHash",
              "height": 5
            },
            "lastCommit": {
              "blockId": {
                "partSetHeader": {
                  "total": 0,
                  "hash": "hash"
                },
                "hash": "hash"
              },
              "round": 7,
              "signatures": [
                {
                  "blockIdFlag": 1,
                  "signature": "signature",
                  "validatorAddress": "validatorAddress",
                  "timestamp": "2000-01-23T04:56:07.000+00:00"
                },
                {
                  "blockIdFlag": 1,
                  "signature": "signature",
                  "validatorAddress": "validatorAddress",
                  "timestamp": "2000-01-23T04:56:07.000+00:00"
                }
              ],
              "height": 4
            }
          }
        },
        "properties": {
          "blockId": {
            "$ref": "#/components/schemas/BlockID"
          },
          "block": {
            "$ref": "#/components/schemas/Block"
          },
          "sdkBlock": {
            "$ref": "#/components/schemas/Block"
          }
        },
        "type": "object"
      },
      "GetLatestValidatorSetResponse": {
        "description": "GetLatestValidatorSetResponse is the response type for the Query/GetValidatorSetByHeight RPC method.",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "blockHeight": 0,
          "validators": [
            {
              "votingPower": 1,
              "address": "address",
              "proposerPriority": 1,
              "pubKey": {
                "bn254": "bn254",
                "ed25519": "ed25519",
                "secp256k1": "secp256k1"
              }
            },
            {
              "votingPower": 1,
              "address": "address",
              "proposerPriority": 1,
              "pubKey": {
                "bn254": "bn254",
                "ed25519": "ed25519",
                "secp256k1": "secp256k1"
              }
            }
          ]
        },
        "properties": {
          "blockHeight": {
            "format": "int64",
            "type": "integer"
          },
          "validators": {
            "items": {
              "$ref": "#/components/schemas/Validator"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "GetNodeInfoResponse": {
        "description": "GetNodeInfoResponse is the response type for the Query/GetNodeInfo RPC method.",
        "example": {
          "applicationVersion": {
            "gitCommit": "gitCommit",
            "buildDeps": [
              {
                "path": "path",
                "sum": "sum",
                "version": "version"
              },
              {
                "path": "path",
                "sum": "sum",
                "version": "version"
              }
            ],
            "appName": "appName",
            "name": "name",
            "goVersion": "goVersion",
            "cosmosSdkVersion": "cosmosSdkVersion",
            "buildTags": "buildTags",
            "version": "version"
          },
          "defaultNodeInfo": {
            "other": {
              "rpcAddress": "rpcAddress",
              "txIndex": "txIndex"
            },
            "channels": "channels",
            "listenAddr": "listenAddr",
            "protocolVersion": {
              "app": 1,
              "block": 6,
              "p2p": 0
            },
            "defaultNodeId": "defaultNodeId",
            "moniker": "moniker",
            "version": "version",
            "network": "network"
          }
        },
        "properties": {
          "defaultNodeInfo": {
            "$ref": "#/components/schemas/DefaultNodeInfo"
          },
          "applicationVersion": {
            "$ref": "#/components/schemas/VersionInfo"
          }
        },
        "type": "object"
      },
      "GetSyncingResponse": {
        "description": "GetSyncingResponse is the response type for the Query/GetSyncing RPC method.",
        "example": {
          "syncing": true
        },
        "properties": {
          "syncing": {
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "GetValidatorSetByHeightResponse": {
        "description": "GetValidatorSetByHeightResponse is the response type for the Query/GetValidatorSetByHeight RPC method.",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "blockHeight": 0,
          "validators": [
            {
              "votingPower": 1,
              "address": "address",
              "proposerPriority": 1,
              "pubKey": {
                "bn254": "bn254",
                "ed25519": "ed25519",
                "secp256k1": "secp256k1"
              }
            },
            {
              "votingPower": 1,
              "address": "address",
              "proposerPriority": 1,
              "pubKey": {
                "bn254": "bn254",
                "ed25519": "ed25519",
                "secp256k1": "secp256k1"
              }
            }
          ]
        },
        "properties": {
          "blockHeight": {
            "format": "int64",
            "type": "integer"
          },
          "validators": {
            "items": {
              "$ref": "#/components/schemas/Validator"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "Header": {
        "description": "Header defines the structure of a block header.",
        "example": {
          "dataHash": "dataHash",
          "consensusHash": "consensusHash",
          "evidenceHash": "evidenceHash",
          "proposerAddress": "proposerAddress",
          "appHash": "appHash",
          "version": {
            "app": 1,
            "block": 6
          },
          "lastResultsHash": "lastResultsHash",
          "lastBlockId": {
            "partSetHeader": {
              "total": 0,
              "hash": "hash"
            },
            "hash": "hash"
          },
          "chainId": "chainId",
          "validatorsHash": "validatorsHash",
          "lastCommitHash": "lastCommitHash",
          "time": "2000-01-23T04:56:07.000+00:00",
          "nextValidatorsHash": "nextValidatorsHash",
          "height": 5
        },
        "properties": {
          "version": {
            "$ref": "#/components/schemas/Consensus"
          },
          "chainId": {
            "type": "string"
          },
          "height": {
            "format": "int64",
            "type": "integer"
          },
          "time": {
            "format": "date-time",
            "type": "string"
          },
          "lastBlockId": {
            "$ref": "#/components/schemas/BlockID"
          },
          "lastCommitHash": {
            "description": "hashes of block data",
            "format": "bytes",
            "type": "string"
          },
          "dataHash": {
            "format": "bytes",
            "type": "string"
          },
          "validatorsHash": {
            "description": "hashes from the app output from the prev block",
            "format": "bytes",
            "type": "string"
          },
          "nextValidatorsHash": {
            "format": "bytes",
            "type": "string"
          },
          "consensusHash": {
            "format": "bytes",
            "type": "string"
          },
          "appHash": {
            "format": "bytes",
            "type": "string"
          },
          "lastResultsHash": {
            "format": "bytes",
            "type": "string"
          },
          "evidenceHash": {
            "description": "consensus info",
            "format": "bytes",
            "type": "string"
          },
          "proposerAddress": {
            "format": "bytes",
            "type": "string"
          }
        },
        "type": "object"
      },
      "LightBlock": {
        "example": {
          "signedHeader": {
            "commit": {
              "blockId": {
                "partSetHeader": {
                  "total": 0,
                  "hash": "hash"
                },
                "hash": "hash"
              },
              "round": 7,
              "signatures": [
                {
                  "blockIdFlag": 1,
                  "signature": "signature",
                  "validatorAddress": "validatorAddress",
                  "timestamp": "2000-01-23T04:56:07.000+00:00"
                },
                {
                  "blockIdFlag": 1,
                  "signature": "signature",
                  "validatorAddress": "validatorAddress",
                  "timestamp": "2000-01-23T04:56:07.000+00:00"
                }
              ],
              "height": 4
            },
            "header": {
              "dataHash": "dataHash",
              "consensusHash": "consensusHash",
              "evidenceHash": "evidenceHash",
              "proposerAddress": "proposerAddress",
              "appHash": "appHash",
              "version": {
                "app": 1,
                "block": 6
              },
              "lastResultsHash": "lastResultsHash",
              "lastBlockId": {
                "partSetHeader": {
                  "total": 0,
                  "hash": "hash"
                },
                "hash": "hash"
              },
              "chainId": "chainId",
              "validatorsHash": "validatorsHash",
              "lastCommitHash": "lastCommitHash",
              "time": "2000-01-23T04:56:07.000+00:00",
              "nextValidatorsHash": "nextValidatorsHash",
              "height": 5
            }
          },
          "validatorSet": {
            "totalVotingPower": 6,
            "validators": [
              {
                "votingPower": 1,
                "address": "address",
                "proposerPriority": 1,
                "pubKey": {
                  "bn254": "bn254",
                  "ed25519": "ed25519",
                  "secp256k1": "secp256k1"
                }
              },
              {
                "votingPower": 1,
                "address": "address",
                "proposerPriority": 1,
                "pubKey": {
                  "bn254": "bn254",
                  "ed25519": "ed25519",
                  "secp256k1": "secp256k1"
                }
              }
            ],
            "proposer": {
              "votingPower": 1,
              "address": "address",
              "proposerPriority": 1,
              "pubKey": {
                "bn254": "bn254",
                "ed25519": "ed25519",
                "secp256k1": "secp256k1"
              }
            }
          }
        },
        "properties": {
          "signedHeader": {
            "$ref": "#/components/schemas/SignedHeader"
          },
          "validatorSet": {
            "$ref": "#/components/schemas/ValidatorSet"
          }
        },
        "type": "object"
      },
      "LightClientAttackEvidence": {
        "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.",
        "example": {
          "commonHeight": 7,
          "totalVotingPower": 1,
          "conflictingBlock": {
            "signedHeader": {
              "commit": {
                "blockId": {
                  "partSetHeader": {
                    "total": 0,
                    "hash": "hash"
                  },
                  "hash": "hash"
                },
                "round": 7,
                "signatures": [
                  {
                    "blockIdFlag": 1,
                    "signature": "signature",
                    "validatorAddress": "validatorAddress",
                    "timestamp": "2000-01-23T04:56:07.000+00:00"
                  },
                  {
                    "blockIdFlag": 1,
                    "signature": "signature",
                    "validatorAddress": "validatorAddress",
                    "timestamp": "2000-01-23T04:56:07.000+00:00"
                  }
                ],
                "height": 4
              },
              "header": {
                "dataHash": "dataHash",
                "consensusHash": "consensusHash",
                "evidenceHash": "evidenceHash",
                "proposerAddress": "proposerAddress",
                "appHash": "appHash",
                "version": {
                  "app": 1,
                  "block": 6
                },
                "lastResultsHash": "lastResultsHash",
                "lastBlockId": {
                  "partSetHeader": {
                    "total": 0,
                    "hash": "hash"
                  },
                  "hash": "hash"
                },
                "chainId": "chainId",
                "validatorsHash": "validatorsHash",
                "lastCommitHash": "lastCommitHash",
                "time": "2000-01-23T04:56:07.000+00:00",
                "nextValidatorsHash": "nextValidatorsHash",
                "height": 5
              }
            },
            "validatorSet": {
              "totalVotingPower": 6,
              "validators": [
                {
                  "votingPower": 1,
                  "address": "address",
                  "proposerPriority": 1,
                  "pubKey": {
                    "bn254": "bn254",
                    "ed25519": "ed25519",
                    "secp256k1": "secp256k1"
                  }
                },
                {
                  "votingPower": 1,
                  "address": "address",
                  "proposerPriority": 1,
                  "pubKey": {
                    "bn254": "bn254",
                    "ed25519": "ed25519",
                    "secp256k1": "secp256k1"
                  }
                }
              ],
              "proposer": {
                "votingPower": 1,
                "address": "address",
                "proposerPriority": 1,
                "pubKey": {
                  "bn254": "bn254",
                  "ed25519": "ed25519",
                  "secp256k1": "secp256k1"
                }
              }
            }
          },
          "byzantineValidators": [
            {
              "votingPower": 1,
              "address": "address",
              "proposerPriority": 1,
              "pubKey": {
                "bn254": "bn254",
                "ed25519": "ed25519",
                "secp256k1": "secp256k1"
              }
            },
            {
              "votingPower": 1,
              "address": "address",
              "proposerPriority": 1,
              "pubKey": {
                "bn254": "bn254",
                "ed25519": "ed25519",
                "secp256k1": "secp256k1"
              }
            }
          ],
          "timestamp": "2000-01-23T04:56:07.000+00:00"
        },
        "properties": {
          "conflictingBlock": {
            "$ref": "#/components/schemas/LightBlock"
          },
          "commonHeight": {
            "format": "int64",
            "type": "integer"
          },
          "byzantineValidators": {
            "items": {
              "$ref": "#/components/schemas/Validator"
            },
            "type": "array"
          },
          "totalVotingPower": {
            "format": "int64",
            "type": "integer"
          },
          "timestamp": {
            "format": "date-time",
            "type": "string"
          }
        },
        "type": "object"
      },
      "Module": {
        "description": "Module is the type for VersionInfo",
        "example": {
          "path": "path",
          "sum": "sum",
          "version": "version"
        },
        "properties": {
          "path": {
            "description": "module path",
            "type": "string"
          },
          "version": {
            "description": "module version",
            "type": "string"
          },
          "sum": {
            "description": "checksum",
            "type": "string"
          }
        },
        "type": "object"
      },
      "PartSetHeader": {
        "description": "PartsetHeader",
        "example": {
          "total": 0,
          "hash": "hash"
        },
        "properties": {
          "total": {
            "format": "uint32",
            "type": "integer"
          },
          "hash": {
            "format": "bytes",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ProofOp": {
        "description": "ProofOp defines an operation used for calculating Merkle root The data could be arbitrary format, providing necessary data for example neighbouring node hash",
        "example": {
          "data": "data",
          "type": "type",
          "key": "key"
        },
        "properties": {
          "type": {
            "type": "string"
          },
          "key": {
            "format": "bytes",
            "type": "string"
          },
          "data": {
            "format": "bytes",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ProofOps": {
        "description": "ProofOps is Merkle proof defined by the list of ProofOps. Note: This type is a duplicate of the ProofOps proto type defined in Tendermint.",
        "example": {
          "ops": [
            {
              "data": "data",
              "type": "type",
              "key": "key"
            },
            {
              "data": "data",
              "type": "type",
              "key": "key"
            }
          ]
        },
        "properties": {
          "ops": {
            "items": {
              "$ref": "#/components/schemas/ProofOp"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "ProtocolVersion": {
        "example": {
          "app": 1,
          "block": 6,
          "p2p": 0
        },
        "properties": {
          "p2p": {
            "format": "uint64",
            "type": "integer"
          },
          "block": {
            "format": "uint64",
            "type": "integer"
          },
          "app": {
            "format": "uint64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "SignedHeader": {
        "example": {
          "commit": {
            "blockId": {
              "partSetHeader": {
                "total": 0,
                "hash": "hash"
              },
              "hash": "hash"
            },
            "round": 7,
            "signatures": [
              {
                "blockIdFlag": 1,
                "signature": "signature",
                "validatorAddress": "validatorAddress",
                "timestamp": "2000-01-23T04:56:07.000+00:00"
              },
              {
                "blockIdFlag": 1,
                "signature": "signature",
                "validatorAddress": "validatorAddress",
                "timestamp": "2000-01-23T04:56:07.000+00:00"
              }
            ],
            "height": 4
          },
          "header": {
            "dataHash": "dataHash",
            "consensusHash": "consensusHash",
            "evidenceHash": "evidenceHash",
            "proposerAddress": "proposerAddress",
            "appHash": "appHash",
            "version": {
              "app": 1,
              "block": 6
            },
            "lastResultsHash": "lastResultsHash",
            "lastBlockId": {
              "partSetHeader": {
                "total": 0,
                "hash": "hash"
              },
              "hash": "hash"
            },
            "chainId": "chainId",
            "validatorsHash": "validatorsHash",
            "lastCommitHash": "lastCommitHash",
            "time": "2000-01-23T04:56:07.000+00:00",
            "nextValidatorsHash": "nextValidatorsHash",
            "height": 5
          }
        },
        "properties": {
          "header": {
            "$ref": "#/components/schemas/Header"
          },
          "commit": {
            "$ref": "#/components/schemas/Commit"
          }
        },
        "type": "object"
      },
      "Validator": {
        "example": {
          "votingPower": 1,
          "address": "address",
          "proposerPriority": 1,
          "pubKey": {
            "bn254": "bn254",
            "ed25519": "ed25519",
            "secp256k1": "secp256k1"
          }
        },
        "properties": {
          "address": {
            "format": "bytes",
            "type": "string"
          },
          "pubKey": {
            "$ref": "#/components/schemas/PublicKey"
          },
          "votingPower": {
            "format": "int64",
            "type": "integer"
          },
          "proposerPriority": {
            "format": "int64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "ValidatorSet": {
        "example": {
          "totalVotingPower": 6,
          "validators": [
            {
              "votingPower": 1,
              "address": "address",
              "proposerPriority": 1,
              "pubKey": {
                "bn254": "bn254",
                "ed25519": "ed25519",
                "secp256k1": "secp256k1"
              }
            },
            {
              "votingPower": 1,
              "address": "address",
              "proposerPriority": 1,
              "pubKey": {
                "bn254": "bn254",
                "ed25519": "ed25519",
                "secp256k1": "secp256k1"
              }
            }
          ],
          "proposer": {
            "votingPower": 1,
            "address": "address",
            "proposerPriority": 1,
            "pubKey": {
              "bn254": "bn254",
              "ed25519": "ed25519",
              "secp256k1": "secp256k1"
            }
          }
        },
        "properties": {
          "validators": {
            "items": {
              "$ref": "#/components/schemas/Validator"
            },
            "type": "array"
          },
          "proposer": {
            "$ref": "#/components/schemas/Validator"
          },
          "totalVotingPower": {
            "format": "int64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "VersionInfo": {
        "description": "VersionInfo is the type for the GetNodeInfoResponse message.",
        "example": {
          "gitCommit": "gitCommit",
          "buildDeps": [
            {
              "path": "path",
              "sum": "sum",
              "version": "version"
            },
            {
              "path": "path",
              "sum": "sum",
              "version": "version"
            }
          ],
          "appName": "appName",
          "name": "name",
          "goVersion": "goVersion",
          "cosmosSdkVersion": "cosmosSdkVersion",
          "buildTags": "buildTags",
          "version": "version"
        },
        "properties": {
          "name": {
            "type": "string"
          },
          "appName": {
            "type": "string"
          },
          "version": {
            "type": "string"
          },
          "gitCommit": {
            "type": "string"
          },
          "buildTags": {
            "type": "string"
          },
          "goVersion": {
            "type": "string"
          },
          "buildDeps": {
            "items": {
              "$ref": "#/components/schemas/Module"
            },
            "type": "array"
          },
          "cosmosSdkVersion": {
            "description": "Since: cosmos-sdk 0.43",
            "type": "string"
          }
        },
        "type": "object"
      },
      "Vote": {
        "description": "Vote represents a prevote or precommit vote from validators for consensus.",
        "example": {
          "blockId": {
            "partSetHeader": {
              "total": 0,
              "hash": "hash"
            },
            "hash": "hash"
          },
          "extension": "extension",
          "round": 7,
          "signature": "signature",
          "validatorAddress": "validatorAddress",
          "validatorIndex": 9,
          "type": 5,
          "extensionSignature": "extensionSignature",
          "height": 2,
          "timestamp": "2000-01-23T04:56:07.000+00:00"
        },
        "properties": {
          "type": {
            "format": "enum",
            "type": "integer"
          },
          "height": {
            "format": "int64",
            "type": "integer"
          },
          "round": {
            "format": "int32",
            "type": "integer"
          },
          "blockId": {
            "$ref": "#/components/schemas/BlockID"
          },
          "timestamp": {
            "format": "date-time",
            "type": "string"
          },
          "validatorAddress": {
            "format": "bytes",
            "type": "string"
          },
          "validatorIndex": {
            "format": "int32",
            "type": "integer"
          },
          "signature": {
            "description": "Vote signature by the validator if they participated in consensus for the associated block.",
            "format": "bytes",
            "type": "string"
          },
          "extension": {
            "description": "Vote extension provided by the application. Only valid for precommit messages.",
            "format": "bytes",
            "type": "string"
          },
          "extensionSignature": {
            "description": "Vote extension signature by the validator if they participated in consensus for the associated block. Only valid for precommit messages.",
            "format": "bytes",
            "type": "string"
          }
        },
        "type": "object"
      },
      "AccountResponse": {
        "description": "AccountResponse is the response type for the Query/Account RPC method.",
        "example": {
          "permission": {
            "level": 0,
            "limitTypeUrls": ["limitTypeUrls", "limitTypeUrls"]
          }
        },
        "properties": {
          "permission": {
            "$ref": "#/components/schemas/Permissions"
          }
        },
        "type": "object"
      },
      "AccountsResponse": {
        "description": "AccountsResponse is the response type for the Query/Accounts RPC method.",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "accounts": [
            {
              "address": "address",
              "permissions": {
                "level": 0,
                "limitTypeUrls": ["limitTypeUrls", "limitTypeUrls"]
              }
            },
            {
              "address": "address",
              "permissions": {
                "level": 0,
                "limitTypeUrls": ["limitTypeUrls", "limitTypeUrls"]
              }
            }
          ]
        },
        "properties": {
          "accounts": {
            "items": {
              "$ref": "#/components/schemas/GenesisAccountPermissions"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "DisabledListResponse": {
        "description": "DisabledListResponse is the response type for the Query/DisabledList RPC method.",
        "example": {
          "disabledList": ["disabledList", "disabledList"]
        },
        "properties": {
          "disabledList": {
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "GenesisAccountPermissions": {
        "description": "GenesisAccountPermissions is the account permissions for the circuit breaker in genesis",
        "example": {
          "address": "address",
          "permissions": {
            "level": 0,
            "limitTypeUrls": ["limitTypeUrls", "limitTypeUrls"]
          }
        },
        "properties": {
          "address": {
            "type": "string"
          },
          "permissions": {
            "$ref": "#/components/schemas/Permissions"
          }
        },
        "type": "object"
      },
      "Permissions": {
        "description": "Permissions are the permissions that an account has to trip or reset the circuit breaker.",
        "example": {
          "level": 0,
          "limitTypeUrls": ["limitTypeUrls", "limitTypeUrls"]
        },
        "properties": {
          "level": {
            "description": "level is the level of permissions granted to this account.",
            "format": "enum",
            "type": "integer"
          },
          "limitTypeUrls": {
            "description": "limit_type_urls is used with LEVEL_SOME_MSGS to limit the lists of Msg type URLs that the account can trip. It is an error to use limit_type_urls with a level other than LEVEL_SOME_MSGS.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "ABCIParams": {
        "description": "ABCIParams configure functionality specific to the Application Blockchain Interface.",
        "properties": {
          "voteExtensionsEnableHeight": {
            "description": "vote_extensions_enable_height configures the first height during which vote extensions will be enabled. During this specified height, and for all subsequent heights, precommit messages that do not contain valid extension data will be considered invalid. Prior to this height, vote extensions will not be used or accepted by validators on the network. Once enabled, vote extensions will be created by the application in ExtendVote, passed to the application for validation in VerifyVoteExtension and given to the application to use when proposing a block during PrepareProposal.",
            "format": "int64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "BlockParams": {
        "description": "BlockParams contains limits on the block size.",
        "properties": {
          "maxBytes": {
            "description": "Max block size, in bytes. Note: must be greater than 0",
            "format": "int64",
            "type": "integer"
          },
          "maxGas": {
            "description": "Max gas per block. Note: must be greater or equal to -1",
            "format": "int64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "ConsensusParams": {
        "description": "ConsensusParams contains consensus critical parameters that determine the validity of blocks.",
        "properties": {
          "block": {
            "$ref": "#/components/schemas/BlockParams"
          },
          "evidence": {
            "$ref": "#/components/schemas/EvidenceParams"
          },
          "validator": {
            "$ref": "#/components/schemas/ValidatorParams"
          },
          "version": {
            "$ref": "#/components/schemas/VersionParams"
          },
          "abci": {
            "$ref": "#/components/schemas/ABCIParams"
          }
        },
        "type": "object"
      },
      "Duration": {
        "description": "A Duration represents a signed, fixed-length span of time represented as a count of seconds and fractions of seconds at nanosecond resolution. It is independent of any calendar and concepts like \"day\" or \"month\". It is related to Timestamp in that the difference between two Timestamp values is a Duration and it can be added or subtracted from a Timestamp. Range is approximately +-10,000 years. # Examples Example 1: Compute Duration from two Timestamps in pseudo code.     Timestamp start = ...;     Timestamp end = ...;     Duration duration = ...;     duration.seconds = end.seconds - start.seconds;     duration.nanos = end.nanos - start.nanos;     if (duration.seconds < 0 && duration.nanos > 0) {       duration.seconds += 1;       duration.nanos -= 1000000000;     } else if (duration.seconds > 0 && duration.nanos < 0) {       duration.seconds -= 1;       duration.nanos += 1000000000;     } Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.     Timestamp start = ...;     Duration duration = ...;     Timestamp end = ...;     end.seconds = start.seconds + duration.seconds;     end.nanos = start.nanos + duration.nanos;     if (end.nanos < 0) {       end.seconds -= 1;       end.nanos += 1000000000;     } else if (end.nanos >= 1000000000) {       end.seconds += 1;       end.nanos -= 1000000000;     } Example 3: Compute Duration from datetime.timedelta in Python.     td = datetime.timedelta(days=3, minutes=10)     duration = Duration()     duration.FromTimedelta(td) # JSON Mapping In JSON format, the Duration type is encoded as a string rather than an object, where the string ends in the suffix \"s\" (indicating seconds) and is preceded by the number of seconds, with nanoseconds expressed as fractional seconds. For example, 3 seconds with 0 nanoseconds should be encoded in JSON format as \"3s\", while 3 seconds and 1 nanosecond should be expressed in JSON format as \"3.000000001s\", and 3 seconds and 1 microsecond should be expressed in JSON format as \"3.000001s\".",
        "properties": {
          "seconds": {
            "description": "Signed seconds of the span of time. Must be from -315,576,000,000 to +315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years",
            "format": "int64",
            "type": "integer"
          },
          "nanos": {
            "description": "Signed fractions of a second at nanosecond resolution of the span of time. Durations less than one second are represented with a 0 `seconds` field and a positive or negative `nanos` field. For durations of one second or more, a non-zero value for the `nanos` field must be of the same sign as the `seconds` field. Must be from -999,999,999 to +999,999,999 inclusive.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "EvidenceParams": {
        "description": "EvidenceParams determine how we handle evidence of malfeasance.",
        "properties": {
          "maxAgeNumBlocks": {
            "description": "Max age of evidence, in blocks. The basic formula for calculating this is: MaxAgeDuration / {average block time}.",
            "format": "int64",
            "type": "integer"
          },
          "maxAgeDuration": {
            "$ref": "#/components/schemas/Duration"
          },
          "maxBytes": {
            "description": "This sets the maximum size of total evidence in bytes that can be committed in a single block. and should fall comfortably under the max block bytes. Default is 1048576 or 1MB",
            "format": "int64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "ValidatorParams": {
        "description": "ValidatorParams restrict the public key types validators can use. NOTE: uses ABCI pubkey naming, not Amino names.",
        "properties": {
          "pubKeyTypes": {
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "VersionParams": {
        "description": "VersionParams contains the ABCI application version.",
        "properties": {
          "app": {
            "format": "uint64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "DecCoin": {
        "description": "DecCoin defines a token with a denomination and a decimal amount. NOTE: The amount field is an Dec which implements the custom method signatures required by gogoproto.",
        "example": {
          "amount": "amount",
          "denom": "denom"
        },
        "properties": {
          "denom": {
            "type": "string"
          },
          "amount": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "DelegationDelegatorReward": {
        "description": "DelegationDelegatorReward represents the properties of a delegator's delegation reward.",
        "example": {
          "reward": [
            {
              "amount": "amount",
              "denom": "denom"
            },
            {
              "amount": "amount",
              "denom": "denom"
            }
          ],
          "validatorAddress": "validatorAddress"
        },
        "properties": {
          "validatorAddress": {
            "type": "string"
          },
          "reward": {
            "items": {
              "$ref": "#/components/schemas/DecCoin"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "QueryCommunityPoolResponse": {
        "description": "QueryCommunityPoolResponse is the response type for the Query/CommunityPool RPC method.",
        "example": {
          "pool": [
            {
              "amount": "amount",
              "denom": "denom"
            },
            {
              "amount": "amount",
              "denom": "denom"
            }
          ]
        },
        "properties": {
          "pool": {
            "description": "pool defines community pool's coins.",
            "items": {
              "$ref": "#/components/schemas/DecCoin"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "QueryDelegationRewardsResponse": {
        "description": "QueryDelegationRewardsResponse is the response type for the Query/DelegationRewards RPC method.",
        "example": {
          "rewards": [
            {
              "amount": "amount",
              "denom": "denom"
            },
            {
              "amount": "amount",
              "denom": "denom"
            }
          ]
        },
        "properties": {
          "rewards": {
            "description": "rewards defines the rewards accrued by a delegation.",
            "items": {
              "$ref": "#/components/schemas/DecCoin"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "QueryDelegationTotalRewardsResponse": {
        "description": "QueryDelegationTotalRewardsResponse is the response type for the Query/DelegationTotalRewards RPC method.",
        "example": {
          "total": [
            {
              "amount": "amount",
              "denom": "denom"
            },
            {
              "amount": "amount",
              "denom": "denom"
            }
          ],
          "rewards": [
            {
              "reward": [
                {
                  "amount": "amount",
                  "denom": "denom"
                },
                {
                  "amount": "amount",
                  "denom": "denom"
                }
              ],
              "validatorAddress": "validatorAddress"
            },
            {
              "reward": [
                {
                  "amount": "amount",
                  "denom": "denom"
                },
                {
                  "amount": "amount",
                  "denom": "denom"
                }
              ],
              "validatorAddress": "validatorAddress"
            }
          ]
        },
        "properties": {
          "rewards": {
            "description": "rewards defines all the rewards accrued by a delegator.",
            "items": {
              "$ref": "#/components/schemas/DelegationDelegatorReward"
            },
            "type": "array"
          },
          "total": {
            "description": "total defines the sum of all the rewards.",
            "items": {
              "$ref": "#/components/schemas/DecCoin"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "QueryDelegatorValidatorsResponse": {
        "description": "QueryDelegatorValidatorsResponse is response type for the Query/DelegatorValidators RPC method.",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "validators": [
            {
              "votingPower": 1,
              "address": "address",
              "proposerPriority": 1,
              "pubKey": {
                "bn254": "bn254",
                "ed25519": "ed25519",
                "secp256k1": "secp256k1"
              }
            },
            {
              "votingPower": 1,
              "address": "address",
              "proposerPriority": 1,
              "pubKey": {
                "bn254": "bn254",
                "ed25519": "ed25519",
                "secp256k1": "secp256k1"
              }
            }
          ]
        },
        "properties": {
          "validators": {
            "description": "validators defines the validators' info of a delegator.",
            "items": {
              "$ref": "#/components/schemas/Validator"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryDelegatorWithdrawAddressResponse": {
        "description": "QueryDelegatorWithdrawAddressResponse is the response type for the Query/DelegatorWithdrawAddress RPC method.",
        "example": {
          "withdrawAddress": "withdrawAddress"
        },
        "properties": {
          "withdrawAddress": {
            "description": "withdraw_address defines the delegator address to query for.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "QueryValidatorCommissionResponse": {
        "description": "QueryValidatorCommissionResponse is the response type for the Query/ValidatorCommission RPC method",
        "example": {
          "commission": {
            "commission": [
              {
                "amount": "amount",
                "denom": "denom"
              },
              {
                "amount": "amount",
                "denom": "denom"
              }
            ]
          }
        },
        "properties": {
          "commission": {
            "$ref": "#/components/schemas/ValidatorAccumulatedCommission"
          }
        },
        "type": "object"
      },
      "QueryValidatorDistributionInfoResponse": {
        "description": "QueryValidatorDistributionInfoResponse is the response type for the Query/ValidatorDistributionInfo RPC method.",
        "example": {
          "operatorAddress": "operatorAddress",
          "commission": [
            {
              "amount": "amount",
              "denom": "denom"
            },
            {
              "amount": "amount",
              "denom": "denom"
            }
          ],
          "selfBondRewards": [
            {
              "amount": "amount",
              "denom": "denom"
            },
            {
              "amount": "amount",
              "denom": "denom"
            }
          ]
        },
        "properties": {
          "operatorAddress": {
            "description": "operator_address defines the validator operator address.",
            "type": "string"
          },
          "selfBondRewards": {
            "description": "self_bond_rewards defines the self delegations rewards.",
            "items": {
              "$ref": "#/components/schemas/DecCoin"
            },
            "type": "array"
          },
          "commission": {
            "description": "commission defines the commission the validator received.",
            "items": {
              "$ref": "#/components/schemas/DecCoin"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "QueryValidatorOutstandingRewardsResponse": {
        "description": "QueryValidatorOutstandingRewardsResponse is the response type for the Query/ValidatorOutstandingRewards RPC method.",
        "example": {
          "rewards": {
            "rewards": [
              {
                "amount": "amount",
                "denom": "denom"
              },
              {
                "amount": "amount",
                "denom": "denom"
              }
            ]
          }
        },
        "properties": {
          "rewards": {
            "$ref": "#/components/schemas/ValidatorOutstandingRewards"
          }
        },
        "type": "object"
      },
      "QueryValidatorSlashesResponse": {
        "description": "QueryValidatorSlashesResponse is the response type for the Query/ValidatorSlashes RPC method.",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "slashes": [
            {
              "validatorPeriod": 0,
              "fraction": "fraction"
            },
            {
              "validatorPeriod": 0,
              "fraction": "fraction"
            }
          ]
        },
        "properties": {
          "slashes": {
            "description": "slashes defines the slashes the validator received.",
            "items": {
              "$ref": "#/components/schemas/ValidatorSlashEvent"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "ValidatorAccumulatedCommission": {
        "description": "ValidatorAccumulatedCommission represents accumulated commission for a validator kept as a running counter, can be withdrawn at any time.",
        "example": {
          "commission": [
            {
              "amount": "amount",
              "denom": "denom"
            },
            {
              "amount": "amount",
              "denom": "denom"
            }
          ]
        },
        "properties": {
          "commission": {
            "items": {
              "$ref": "#/components/schemas/DecCoin"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "ValidatorOutstandingRewards": {
        "description": "ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards for a validator inexpensive to track, allows simple sanity checks.",
        "example": {
          "rewards": [
            {
              "amount": "amount",
              "denom": "denom"
            },
            {
              "amount": "amount",
              "denom": "denom"
            }
          ]
        },
        "properties": {
          "rewards": {
            "items": {
              "$ref": "#/components/schemas/DecCoin"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "ValidatorSlashEvent": {
        "description": "ValidatorSlashEvent represents a validator slash event. Height is implicit within the store key. This is needed to calculate appropriate amount of staking tokens for delegations which are withdrawn after a slash has occurred.",
        "example": {
          "validatorPeriod": 0,
          "fraction": "fraction"
        },
        "properties": {
          "validatorPeriod": {
            "format": "uint64",
            "type": "integer"
          },
          "fraction": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "QueryAllEvidenceResponse": {
        "description": "QueryAllEvidenceResponse is the response type for the Query/AllEvidence RPC method.",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "evidence": [
            {
              "@type": "@type"
            },
            {
              "@type": "@type"
            }
          ]
        },
        "properties": {
          "evidence": {
            "description": "evidence returns all evidences.",
            "items": {
              "$ref": "#/components/schemas/GoogleProtobufAny"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryEvidenceResponse": {
        "description": "QueryEvidenceResponse is the response type for the Query/Evidence RPC method.",
        "example": {
          "evidence": {
            "@type": "@type"
          }
        },
        "properties": {
          "evidence": {
            "$ref": "#/components/schemas/GoogleProtobufAny"
          }
        },
        "type": "object"
      },
      "QueryAllowanceResponse": {
        "description": "QueryAllowanceResponse is the response type for the Query/Allowance RPC method.",
        "example": {
          "allowance": {
            "grantee": "grantee",
            "allowance": {
              "@type": "@type"
            },
            "granter": "granter"
          }
        },
        "properties": {
          "allowance": {
            "$ref": "#/components/schemas/Grant"
          }
        },
        "type": "object"
      },
      "QueryAllowancesByGranterResponse": {
        "description": "QueryAllowancesByGranterResponse is the response type for the Query/AllowancesByGranter RPC method. Since: cosmos-sdk 0.46",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "allowances": [
            {
              "grantee": "grantee",
              "allowance": {
                "@type": "@type"
              },
              "granter": "granter"
            },
            {
              "grantee": "grantee",
              "allowance": {
                "@type": "@type"
              },
              "granter": "granter"
            }
          ]
        },
        "properties": {
          "allowances": {
            "description": "allowances that have been issued by the granter.",
            "items": {
              "$ref": "#/components/schemas/Grant"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryAllowancesResponse": {
        "description": "QueryAllowancesResponse is the response type for the Query/Allowances RPC method.",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "allowances": [
            {
              "grantee": "grantee",
              "allowance": {
                "@type": "@type"
              },
              "granter": "granter"
            },
            {
              "grantee": "grantee",
              "allowance": {
                "@type": "@type"
              },
              "granter": "granter"
            }
          ]
        },
        "properties": {
          "allowances": {
            "description": "allowances are allowance's granted for grantee by granter.",
            "items": {
              "$ref": "#/components/schemas/Grant"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "Deposit": {
        "description": "Deposit defines an amount deposited by an account address to an active proposal.",
        "example": {
          "amount": [
            {
              "amount": "amount",
              "denom": "denom"
            },
            {
              "amount": "amount",
              "denom": "denom"
            }
          ],
          "depositor": "depositor",
          "proposalId": 0
        },
        "properties": {
          "proposalId": {
            "description": "proposal_id defines the unique id of the proposal.",
            "format": "uint64",
            "type": "integer"
          },
          "depositor": {
            "description": "depositor defines the deposit addresses from the proposals.",
            "type": "string"
          },
          "amount": {
            "description": "amount to be deposited by depositor.",
            "items": {
              "$ref": "#/components/schemas/Coin"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "DepositParams": {
        "description": "DepositParams defines the params for deposits on governance proposals.",
        "properties": {
          "minDeposit": {
            "description": "Minimum deposit for a proposal to enter voting period.",
            "items": {
              "$ref": "#/components/schemas/Coin"
            },
            "type": "array"
          },
          "maxDepositPeriod": {
            "$ref": "#/components/schemas/Duration"
          }
        },
        "type": "object"
      },
      "Proposal": {
        "description": "Proposal defines a group proposal. Any member of a group can submit a proposal for a group policy to decide upon. A proposal consists of a set of `sdk.Msg`s that will be executed if the proposal passes as well as some optional metadata associated with the proposal.",
        "example": {
          "summary": "summary",
          "metadata": "metadata",
          "votingPeriodEnd": "2000-01-23T04:56:07.000+00:00",
          "proposers": ["proposers", "proposers"],
          "groupPolicyVersion": 1,
          "title": "title",
          "groupPolicyAddress": "groupPolicyAddress",
          "executorResult": 5,
          "finalTallyResult": {
            "noCount": "noCount",
            "noWithVetoCount": "noWithVetoCount",
            "yesCount": "yesCount",
            "abstainCount": "abstainCount"
          },
          "submitTime": "2000-01-23T04:56:07.000+00:00",
          "groupVersion": 6,
          "messages": [
            {
              "@type": "@type"
            },
            {
              "@type": "@type"
            }
          ],
          "id": 0,
          "status": 5
        },
        "properties": {
          "id": {
            "description": "id is the unique id of the proposal.",
            "format": "uint64",
            "type": "integer"
          },
          "groupPolicyAddress": {
            "description": "group_policy_address is the account address of group policy.",
            "type": "string"
          },
          "metadata": {
            "description": "metadata is any arbitrary metadata attached to the proposal. the recommended format of the metadata is to be found here: https://docs.cosmos.network/v0.47/modules/group#proposal-4",
            "type": "string"
          },
          "proposers": {
            "description": "proposers are the account addresses of the proposers.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "submitTime": {
            "description": "submit_time is a timestamp specifying when a proposal was submitted.",
            "format": "date-time",
            "type": "string"
          },
          "groupVersion": {
            "description": "group_version tracks the version of the group at proposal submission. This field is here for informational purposes only.",
            "format": "uint64",
            "type": "integer"
          },
          "groupPolicyVersion": {
            "description": "group_policy_version tracks the version of the group policy at proposal submission. When a decision policy is changed, existing proposals from previous policy versions will become invalid with the `ABORTED` status. This field is here for informational purposes only.",
            "format": "uint64",
            "type": "integer"
          },
          "status": {
            "description": "status represents the high level position in the life cycle of the proposal. Initial value is Submitted.",
            "format": "enum",
            "type": "integer"
          },
          "finalTallyResult": {
            "$ref": "#/components/schemas/TallyResult"
          },
          "votingPeriodEnd": {
            "description": "voting_period_end is the timestamp before which voting must be done. Unless a successful MsgExec is called before (to execute a proposal whose tally is successful before the voting period ends), tallying will be done at this point, and the `final_tally_result`and `status` fields will be accordingly updated.",
            "format": "date-time",
            "type": "string"
          },
          "executorResult": {
            "description": "executor_result is the final result of the proposal execution. Initial value is NotRun.",
            "format": "enum",
            "type": "integer"
          },
          "messages": {
            "description": "messages is a list of `sdk.Msg`s that will be executed if the proposal passes.",
            "items": {
              "$ref": "#/components/schemas/GoogleProtobufAny"
            },
            "type": "array"
          },
          "title": {
            "description": "title is the title of the proposal Since: cosmos-sdk 0.47",
            "type": "string"
          },
          "summary": {
            "description": "summary is a short summary of the proposal Since: cosmos-sdk 0.47",
            "type": "string"
          }
        },
        "type": "object"
      },
      "QueryConstitutionResponse": {
        "description": "QueryConstitutionResponse is the response type for the Query/Constitution RPC method",
        "example": {
          "constitution": "constitution"
        },
        "properties": {
          "constitution": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "QueryDepositResponse": {
        "description": "QueryDepositResponse is the response type for the Query/Deposit RPC method.",
        "example": {
          "deposit": {
            "amount": [
              {
                "amount": "amount",
                "denom": "denom"
              },
              {
                "amount": "amount",
                "denom": "denom"
              }
            ],
            "depositor": "depositor",
            "proposalId": 0
          }
        },
        "properties": {
          "deposit": {
            "$ref": "#/components/schemas/Deposit"
          }
        },
        "type": "object"
      },
      "QueryDepositsResponse": {
        "description": "QueryDepositsResponse is the response type for the Query/Deposits RPC method.",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "deposits": [
            {
              "amount": [
                {
                  "amount": "amount",
                  "denom": "denom"
                },
                {
                  "amount": "amount",
                  "denom": "denom"
                }
              ],
              "depositor": "depositor",
              "proposalId": 0
            },
            {
              "amount": [
                {
                  "amount": "amount",
                  "denom": "denom"
                },
                {
                  "amount": "amount",
                  "denom": "denom"
                }
              ],
              "depositor": "depositor",
              "proposalId": 0
            }
          ]
        },
        "properties": {
          "deposits": {
            "description": "deposits defines the requested deposits.",
            "items": {
              "$ref": "#/components/schemas/Deposit"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryProposalResponse": {
        "description": "QueryProposalResponse is the Query/Proposal response type.",
        "example": {
          "proposal": {
            "summary": "summary",
            "metadata": "metadata",
            "votingPeriodEnd": "2000-01-23T04:56:07.000+00:00",
            "proposers": ["proposers", "proposers"],
            "groupPolicyVersion": 1,
            "title": "title",
            "groupPolicyAddress": "groupPolicyAddress",
            "executorResult": 5,
            "finalTallyResult": {
              "noCount": "noCount",
              "noWithVetoCount": "noWithVetoCount",
              "yesCount": "yesCount",
              "abstainCount": "abstainCount"
            },
            "submitTime": "2000-01-23T04:56:07.000+00:00",
            "groupVersion": 6,
            "messages": [
              {
                "@type": "@type"
              },
              {
                "@type": "@type"
              }
            ],
            "id": 0,
            "status": 5
          }
        },
        "properties": {
          "proposal": {
            "$ref": "#/components/schemas/Proposal"
          }
        },
        "type": "object"
      },
      "QueryProposalsResponse": {
        "description": "QueryProposalsResponse is the response type for the Query/Proposals RPC method.",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "proposals": [
            {
              "summary": "summary",
              "metadata": "metadata",
              "votingPeriodEnd": "2000-01-23T04:56:07.000+00:00",
              "proposers": ["proposers", "proposers"],
              "groupPolicyVersion": 1,
              "title": "title",
              "groupPolicyAddress": "groupPolicyAddress",
              "executorResult": 5,
              "finalTallyResult": {
                "noCount": "noCount",
                "noWithVetoCount": "noWithVetoCount",
                "yesCount": "yesCount",
                "abstainCount": "abstainCount"
              },
              "submitTime": "2000-01-23T04:56:07.000+00:00",
              "groupVersion": 6,
              "messages": [
                {
                  "@type": "@type"
                },
                {
                  "@type": "@type"
                }
              ],
              "id": 0,
              "status": 5
            },
            {
              "summary": "summary",
              "metadata": "metadata",
              "votingPeriodEnd": "2000-01-23T04:56:07.000+00:00",
              "proposers": ["proposers", "proposers"],
              "groupPolicyVersion": 1,
              "title": "title",
              "groupPolicyAddress": "groupPolicyAddress",
              "executorResult": 5,
              "finalTallyResult": {
                "noCount": "noCount",
                "noWithVetoCount": "noWithVetoCount",
                "yesCount": "yesCount",
                "abstainCount": "abstainCount"
              },
              "submitTime": "2000-01-23T04:56:07.000+00:00",
              "groupVersion": 6,
              "messages": [
                {
                  "@type": "@type"
                },
                {
                  "@type": "@type"
                }
              ],
              "id": 0,
              "status": 5
            }
          ]
        },
        "properties": {
          "proposals": {
            "description": "proposals defines all the requested governance proposals.",
            "items": {
              "$ref": "#/components/schemas/Proposal"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryTallyResultResponse": {
        "description": "QueryTallyResultResponse is the Query/TallyResult response type.",
        "example": {
          "tally": {
            "noCount": "noCount",
            "noWithVetoCount": "noWithVetoCount",
            "yesCount": "yesCount",
            "abstainCount": "abstainCount"
          }
        },
        "properties": {
          "tally": {
            "$ref": "#/components/schemas/TallyResult"
          }
        },
        "type": "object"
      },
      "QueryVoteResponse": {
        "description": "QueryVoteResponse is the response type for the Query/Vote RPC method.",
        "example": {
          "vote": {
            "blockId": {
              "partSetHeader": {
                "total": 0,
                "hash": "hash"
              },
              "hash": "hash"
            },
            "extension": "extension",
            "round": 7,
            "signature": "signature",
            "validatorAddress": "validatorAddress",
            "validatorIndex": 9,
            "type": 5,
            "extensionSignature": "extensionSignature",
            "height": 2,
            "timestamp": "2000-01-23T04:56:07.000+00:00"
          }
        },
        "properties": {
          "vote": {
            "$ref": "#/components/schemas/Vote"
          }
        },
        "type": "object"
      },
      "QueryVotesResponse": {
        "description": "QueryVotesResponse is the response type for the Query/Votes RPC method.",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "votes": [
            {
              "blockId": {
                "partSetHeader": {
                  "total": 0,
                  "hash": "hash"
                },
                "hash": "hash"
              },
              "extension": "extension",
              "round": 7,
              "signature": "signature",
              "validatorAddress": "validatorAddress",
              "validatorIndex": 9,
              "type": 5,
              "extensionSignature": "extensionSignature",
              "height": 2,
              "timestamp": "2000-01-23T04:56:07.000+00:00"
            },
            {
              "blockId": {
                "partSetHeader": {
                  "total": 0,
                  "hash": "hash"
                },
                "hash": "hash"
              },
              "extension": "extension",
              "round": 7,
              "signature": "signature",
              "validatorAddress": "validatorAddress",
              "validatorIndex": 9,
              "type": 5,
              "extensionSignature": "extensionSignature",
              "height": 2,
              "timestamp": "2000-01-23T04:56:07.000+00:00"
            }
          ]
        },
        "properties": {
          "votes": {
            "description": "votes defines the queried votes.",
            "items": {
              "$ref": "#/components/schemas/Vote"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "TallyParams": {
        "description": "TallyParams defines the params for tallying votes on governance proposals.",
        "properties": {
          "quorum": {
            "description": "Minimum percentage of total stake needed to vote for a result to be considered valid.",
            "format": "bytes",
            "type": "string"
          },
          "threshold": {
            "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.",
            "format": "bytes",
            "type": "string"
          },
          "vetoThreshold": {
            "description": "Minimum value of Veto votes to Total votes ratio for proposal to be vetoed. Default value: 1/3.",
            "format": "bytes",
            "type": "string"
          }
        },
        "type": "object"
      },
      "TallyResult": {
        "description": "TallyResult represents the sum of weighted votes for each vote option.",
        "example": {
          "noCount": "noCount",
          "noWithVetoCount": "noWithVetoCount",
          "yesCount": "yesCount",
          "abstainCount": "abstainCount"
        },
        "properties": {
          "yesCount": {
            "description": "yes_count is the weighted sum of yes votes.",
            "type": "string"
          },
          "abstainCount": {
            "description": "abstain_count is the weighted sum of abstainers.",
            "type": "string"
          },
          "noCount": {
            "description": "no_count is the weighted sum of no votes.",
            "type": "string"
          },
          "noWithVetoCount": {
            "description": "no_with_veto_count is the weighted sum of veto.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "VotingParams": {
        "description": "VotingParams defines the params for voting on governance proposals.",
        "properties": {
          "votingPeriod": {
            "$ref": "#/components/schemas/Duration"
          }
        },
        "type": "object"
      },
      "WeightedVoteOption": {
        "description": "WeightedVoteOption defines a unit of vote for vote split. Since: cosmos-sdk 0.43",
        "properties": {
          "option": {
            "description": "option defines the valid vote options, it must not contain duplicate vote options.",
            "format": "enum",
            "type": "integer"
          },
          "weight": {
            "description": "weight is the vote weight associated with the vote option.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "GroupInfo": {
        "description": "GroupInfo represents the high-level on-chain information for a group.",
        "example": {
          "createdAt": "2000-01-23T04:56:07.000+00:00",
          "metadata": "metadata",
          "totalWeight": "totalWeight",
          "admin": "admin",
          "id": 0,
          "version": 6
        },
        "properties": {
          "id": {
            "description": "id is the unique ID of the group.",
            "format": "uint64",
            "type": "integer"
          },
          "admin": {
            "description": "admin is the account address of the group's admin.",
            "type": "string"
          },
          "metadata": {
            "description": "metadata is any arbitrary metadata to attached to the group. the recommended format of the metadata is to be found here: https://docs.cosmos.network/v0.47/modules/group#group-1",
            "type": "string"
          },
          "version": {
            "description": "version is used to track changes to a group's membership structure that would break existing proposals. Whenever any members weight is changed, or any member is added or removed this version is incremented and will cause proposals based on older versions of this group to fail",
            "format": "uint64",
            "type": "integer"
          },
          "totalWeight": {
            "description": "total_weight is the sum of the group members' weights.",
            "type": "string"
          },
          "createdAt": {
            "description": "created_at is a timestamp specifying when a group was created.",
            "format": "date-time",
            "type": "string"
          }
        },
        "type": "object"
      },
      "GroupMember": {
        "description": "GroupMember represents the relationship between a group and a member.",
        "example": {
          "groupId": 0,
          "member": {
            "metadata": "metadata",
            "addedAt": "2000-01-23T04:56:07.000+00:00",
            "address": "address",
            "weight": "weight"
          }
        },
        "properties": {
          "groupId": {
            "description": "group_id is the unique ID of the group.",
            "format": "uint64",
            "type": "integer"
          },
          "member": {
            "$ref": "#/components/schemas/Member"
          }
        },
        "type": "object"
      },
      "GroupPolicyInfo": {
        "description": "GroupPolicyInfo represents the high-level on-chain information for a group policy.",
        "example": {
          "createdAt": "2000-01-23T04:56:07.000+00:00",
          "metadata": "metadata",
          "address": "address",
          "groupId": 0,
          "decisionPolicy": {
            "@type": "@type"
          },
          "admin": "admin",
          "version": 6
        },
        "properties": {
          "address": {
            "description": "address is the account address of group policy.",
            "type": "string"
          },
          "groupId": {
            "description": "group_id is the unique ID of the group.",
            "format": "uint64",
            "type": "integer"
          },
          "admin": {
            "description": "admin is the account address of the group admin.",
            "type": "string"
          },
          "metadata": {
            "description": "metadata is any arbitrary metadata attached to the group policy. the recommended format of the metadata is to be found here: https://docs.cosmos.network/v0.47/modules/group#decision-policy-1",
            "type": "string"
          },
          "version": {
            "description": "version is used to track changes to a group's GroupPolicyInfo structure that would create a different result on a running proposal.",
            "format": "uint64",
            "type": "integer"
          },
          "decisionPolicy": {
            "$ref": "#/components/schemas/GoogleProtobufAny"
          },
          "createdAt": {
            "description": "created_at is a timestamp specifying when a group policy was created.",
            "format": "date-time",
            "type": "string"
          }
        },
        "type": "object"
      },
      "Member": {
        "description": "Member represents a group member with an account address, non-zero weight, metadata and added_at timestamp.",
        "example": {
          "metadata": "metadata",
          "addedAt": "2000-01-23T04:56:07.000+00:00",
          "address": "address",
          "weight": "weight"
        },
        "properties": {
          "address": {
            "description": "address is the member's account address.",
            "type": "string"
          },
          "weight": {
            "description": "weight is the member's voting weight that should be greater than 0.",
            "type": "string"
          },
          "metadata": {
            "description": "metadata is any arbitrary metadata attached to the member.",
            "type": "string"
          },
          "addedAt": {
            "description": "added_at is a timestamp specifying when a member was added.",
            "format": "date-time",
            "type": "string"
          }
        },
        "type": "object"
      },
      "QueryGroupInfoResponse": {
        "description": "QueryGroupInfoResponse is the Query/GroupInfo response type.",
        "example": {
          "info": {
            "createdAt": "2000-01-23T04:56:07.000+00:00",
            "metadata": "metadata",
            "totalWeight": "totalWeight",
            "admin": "admin",
            "id": 0,
            "version": 6
          }
        },
        "properties": {
          "info": {
            "$ref": "#/components/schemas/GroupInfo"
          }
        },
        "type": "object"
      },
      "QueryGroupMembersResponse": {
        "description": "QueryGroupMembersResponse is the Query/GroupMembersResponse response type.",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "members": [
            {
              "groupId": 0,
              "member": {
                "metadata": "metadata",
                "addedAt": "2000-01-23T04:56:07.000+00:00",
                "address": "address",
                "weight": "weight"
              }
            },
            {
              "groupId": 0,
              "member": {
                "metadata": "metadata",
                "addedAt": "2000-01-23T04:56:07.000+00:00",
                "address": "address",
                "weight": "weight"
              }
            }
          ]
        },
        "properties": {
          "members": {
            "description": "members are the members of the group with given group_id.",
            "items": {
              "$ref": "#/components/schemas/GroupMember"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryGroupPoliciesByAdminResponse": {
        "description": "QueryGroupPoliciesByAdminResponse is the Query/GroupPoliciesByAdmin response type.",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "groupPolicies": [
            {
              "createdAt": "2000-01-23T04:56:07.000+00:00",
              "metadata": "metadata",
              "address": "address",
              "groupId": 0,
              "decisionPolicy": {
                "@type": "@type"
              },
              "admin": "admin",
              "version": 6
            },
            {
              "createdAt": "2000-01-23T04:56:07.000+00:00",
              "metadata": "metadata",
              "address": "address",
              "groupId": 0,
              "decisionPolicy": {
                "@type": "@type"
              },
              "admin": "admin",
              "version": 6
            }
          ]
        },
        "properties": {
          "groupPolicies": {
            "description": "group_policies are the group policies info with provided admin.",
            "items": {
              "$ref": "#/components/schemas/GroupPolicyInfo"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryGroupPoliciesByGroupResponse": {
        "description": "QueryGroupPoliciesByGroupResponse is the Query/GroupPoliciesByGroup response type.",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "groupPolicies": [
            {
              "createdAt": "2000-01-23T04:56:07.000+00:00",
              "metadata": "metadata",
              "address": "address",
              "groupId": 0,
              "decisionPolicy": {
                "@type": "@type"
              },
              "admin": "admin",
              "version": 6
            },
            {
              "createdAt": "2000-01-23T04:56:07.000+00:00",
              "metadata": "metadata",
              "address": "address",
              "groupId": 0,
              "decisionPolicy": {
                "@type": "@type"
              },
              "admin": "admin",
              "version": 6
            }
          ]
        },
        "properties": {
          "groupPolicies": {
            "description": "group_policies are the group policies info associated with the provided group.",
            "items": {
              "$ref": "#/components/schemas/GroupPolicyInfo"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryGroupPolicyInfoResponse": {
        "description": "QueryGroupPolicyInfoResponse is the Query/GroupPolicyInfo response type.",
        "example": {
          "info": {
            "createdAt": "2000-01-23T04:56:07.000+00:00",
            "metadata": "metadata",
            "address": "address",
            "groupId": 0,
            "decisionPolicy": {
              "@type": "@type"
            },
            "admin": "admin",
            "version": 6
          }
        },
        "properties": {
          "info": {
            "$ref": "#/components/schemas/GroupPolicyInfo"
          }
        },
        "type": "object"
      },
      "QueryGroupsByAdminResponse": {
        "description": "QueryGroupsByAdminResponse is the Query/GroupsByAdminResponse response type.",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "groups": [
            {
              "createdAt": "2000-01-23T04:56:07.000+00:00",
              "metadata": "metadata",
              "totalWeight": "totalWeight",
              "admin": "admin",
              "id": 0,
              "version": 6
            },
            {
              "createdAt": "2000-01-23T04:56:07.000+00:00",
              "metadata": "metadata",
              "totalWeight": "totalWeight",
              "admin": "admin",
              "id": 0,
              "version": 6
            }
          ]
        },
        "properties": {
          "groups": {
            "description": "groups are the groups info with the provided admin.",
            "items": {
              "$ref": "#/components/schemas/GroupInfo"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryGroupsByMemberResponse": {
        "description": "QueryGroupsByMemberResponse is the Query/GroupsByMember response type.",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "groups": [
            {
              "createdAt": "2000-01-23T04:56:07.000+00:00",
              "metadata": "metadata",
              "totalWeight": "totalWeight",
              "admin": "admin",
              "id": 0,
              "version": 6
            },
            {
              "createdAt": "2000-01-23T04:56:07.000+00:00",
              "metadata": "metadata",
              "totalWeight": "totalWeight",
              "admin": "admin",
              "id": 0,
              "version": 6
            }
          ]
        },
        "properties": {
          "groups": {
            "description": "groups are the groups info with the provided group member.",
            "items": {
              "$ref": "#/components/schemas/GroupInfo"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryGroupsResponse": {
        "description": "QueryGroupsResponse is the Query/Groups response type. Since: cosmos-sdk 0.47.1",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "groups": [
            {
              "createdAt": "2000-01-23T04:56:07.000+00:00",
              "metadata": "metadata",
              "totalWeight": "totalWeight",
              "admin": "admin",
              "id": 0,
              "version": 6
            },
            {
              "createdAt": "2000-01-23T04:56:07.000+00:00",
              "metadata": "metadata",
              "totalWeight": "totalWeight",
              "admin": "admin",
              "id": 0,
              "version": 6
            }
          ]
        },
        "properties": {
          "groups": {
            "description": "`groups` is all the groups present in state.",
            "items": {
              "$ref": "#/components/schemas/GroupInfo"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryProposalsByGroupPolicyResponse": {
        "description": "QueryProposalsByGroupPolicyResponse is the Query/ProposalByGroupPolicy response type.",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "proposals": [
            {
              "summary": "summary",
              "metadata": "metadata",
              "votingPeriodEnd": "2000-01-23T04:56:07.000+00:00",
              "proposers": ["proposers", "proposers"],
              "groupPolicyVersion": 1,
              "title": "title",
              "groupPolicyAddress": "groupPolicyAddress",
              "executorResult": 5,
              "finalTallyResult": {
                "noCount": "noCount",
                "noWithVetoCount": "noWithVetoCount",
                "yesCount": "yesCount",
                "abstainCount": "abstainCount"
              },
              "submitTime": "2000-01-23T04:56:07.000+00:00",
              "groupVersion": 6,
              "messages": [
                {
                  "@type": "@type"
                },
                {
                  "@type": "@type"
                }
              ],
              "id": 0,
              "status": 5
            },
            {
              "summary": "summary",
              "metadata": "metadata",
              "votingPeriodEnd": "2000-01-23T04:56:07.000+00:00",
              "proposers": ["proposers", "proposers"],
              "groupPolicyVersion": 1,
              "title": "title",
              "groupPolicyAddress": "groupPolicyAddress",
              "executorResult": 5,
              "finalTallyResult": {
                "noCount": "noCount",
                "noWithVetoCount": "noWithVetoCount",
                "yesCount": "yesCount",
                "abstainCount": "abstainCount"
              },
              "submitTime": "2000-01-23T04:56:07.000+00:00",
              "groupVersion": 6,
              "messages": [
                {
                  "@type": "@type"
                },
                {
                  "@type": "@type"
                }
              ],
              "id": 0,
              "status": 5
            }
          ]
        },
        "properties": {
          "proposals": {
            "description": "proposals are the proposals with given group policy.",
            "items": {
              "$ref": "#/components/schemas/Proposal"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryVoteByProposalVoterResponse": {
        "description": "QueryVoteByProposalVoterResponse is the Query/VoteByProposalVoter response type.",
        "example": {
          "vote": {
            "blockId": {
              "partSetHeader": {
                "total": 0,
                "hash": "hash"
              },
              "hash": "hash"
            },
            "extension": "extension",
            "round": 7,
            "signature": "signature",
            "validatorAddress": "validatorAddress",
            "validatorIndex": 9,
            "type": 5,
            "extensionSignature": "extensionSignature",
            "height": 2,
            "timestamp": "2000-01-23T04:56:07.000+00:00"
          }
        },
        "properties": {
          "vote": {
            "$ref": "#/components/schemas/Vote"
          }
        },
        "type": "object"
      },
      "QueryVotesByProposalResponse": {
        "description": "QueryVotesByProposalResponse is the Query/VotesByProposal response type.",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "votes": [
            {
              "blockId": {
                "partSetHeader": {
                  "total": 0,
                  "hash": "hash"
                },
                "hash": "hash"
              },
              "extension": "extension",
              "round": 7,
              "signature": "signature",
              "validatorAddress": "validatorAddress",
              "validatorIndex": 9,
              "type": 5,
              "extensionSignature": "extensionSignature",
              "height": 2,
              "timestamp": "2000-01-23T04:56:07.000+00:00"
            },
            {
              "blockId": {
                "partSetHeader": {
                  "total": 0,
                  "hash": "hash"
                },
                "hash": "hash"
              },
              "extension": "extension",
              "round": 7,
              "signature": "signature",
              "validatorAddress": "validatorAddress",
              "validatorIndex": 9,
              "type": 5,
              "extensionSignature": "extensionSignature",
              "height": 2,
              "timestamp": "2000-01-23T04:56:07.000+00:00"
            }
          ]
        },
        "properties": {
          "votes": {
            "description": "votes are the list of votes for given proposal_id.",
            "items": {
              "$ref": "#/components/schemas/Vote"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryVotesByVoterResponse": {
        "description": "QueryVotesByVoterResponse is the Query/VotesByVoter response type.",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "votes": [
            {
              "blockId": {
                "partSetHeader": {
                  "total": 0,
                  "hash": "hash"
                },
                "hash": "hash"
              },
              "extension": "extension",
              "round": 7,
              "signature": "signature",
              "validatorAddress": "validatorAddress",
              "validatorIndex": 9,
              "type": 5,
              "extensionSignature": "extensionSignature",
              "height": 2,
              "timestamp": "2000-01-23T04:56:07.000+00:00"
            },
            {
              "blockId": {
                "partSetHeader": {
                  "total": 0,
                  "hash": "hash"
                },
                "hash": "hash"
              },
              "extension": "extension",
              "round": 7,
              "signature": "signature",
              "validatorAddress": "validatorAddress",
              "validatorIndex": 9,
              "type": 5,
              "extensionSignature": "extensionSignature",
              "height": 2,
              "timestamp": "2000-01-23T04:56:07.000+00:00"
            }
          ]
        },
        "properties": {
          "votes": {
            "description": "votes are the list of votes by given voter.",
            "items": {
              "$ref": "#/components/schemas/Vote"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryAnnualProvisionsResponse": {
        "description": "QueryAnnualProvisionsResponse is the response type for the Query/AnnualProvisions RPC method.",
        "example": {
          "annualProvisions": "annualProvisions"
        },
        "properties": {
          "annualProvisions": {
            "description": "annual_provisions is the current minting annual provisions value.",
            "format": "bytes",
            "type": "string"
          }
        },
        "type": "object"
      },
      "QueryInflationResponse": {
        "description": "QueryInflationResponse is the response type for the Query/Inflation RPC method.",
        "example": {
          "inflation": "inflation"
        },
        "properties": {
          "inflation": {
            "description": "inflation is the current minting inflation value.",
            "format": "bytes",
            "type": "string"
          }
        },
        "type": "object"
      },
      "Class": {
        "description": "Class defines the class of the nft type.",
        "example": {
          "symbol": "symbol",
          "uriHash": "uriHash",
          "data": {
            "@type": "@type"
          },
          "name": "name",
          "description": "description",
          "id": "id",
          "uri": "uri"
        },
        "properties": {
          "id": {
            "description": "id defines the unique identifier of the NFT classification, similar to the contract address of ERC721",
            "type": "string"
          },
          "name": {
            "description": "name defines the human-readable name of the NFT classification. Optional",
            "type": "string"
          },
          "symbol": {
            "description": "symbol is an abbreviated name for nft classification. Optional",
            "type": "string"
          },
          "description": {
            "description": "description is a brief description of nft classification. Optional",
            "type": "string"
          },
          "uri": {
            "description": "uri for the class metadata stored off chain. It can define schema for Class and NFT `Data` attributes. Optional",
            "type": "string"
          },
          "uriHash": {
            "description": "uri_hash is a hash of the document pointed by uri. Optional",
            "type": "string"
          },
          "data": {
            "$ref": "#/components/schemas/GoogleProtobufAny"
          }
        },
        "type": "object"
      },
      "NFT": {
        "description": "NFT defines the NFT.",
        "example": {
          "uriHash": "uriHash",
          "classId": "classId",
          "data": {
            "@type": "@type"
          },
          "id": "id",
          "uri": "uri"
        },
        "properties": {
          "classId": {
            "description": "class_id associated with the NFT, similar to the contract address of ERC721",
            "type": "string"
          },
          "id": {
            "description": "id is a unique identifier of the NFT",
            "type": "string"
          },
          "uri": {
            "description": "uri for the NFT metadata stored off chain",
            "type": "string"
          },
          "uriHash": {
            "description": "uri_hash is a hash of the document pointed by uri",
            "type": "string"
          },
          "data": {
            "$ref": "#/components/schemas/GoogleProtobufAny"
          }
        },
        "type": "object"
      },
      "QueryClassResponse": {
        "description": "QueryClassResponse is the response type for the Query/Class RPC method",
        "example": {
          "class": {
            "symbol": "symbol",
            "uriHash": "uriHash",
            "data": {
              "@type": "@type"
            },
            "name": "name",
            "description": "description",
            "id": "id",
            "uri": "uri"
          }
        },
        "properties": {
          "class": {
            "$ref": "#/components/schemas/Class"
          }
        },
        "type": "object"
      },
      "QueryClassesResponse": {
        "description": "QueryClassesResponse is the response type for the Query/Classes RPC method",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "classes": [
            {
              "symbol": "symbol",
              "uriHash": "uriHash",
              "data": {
                "@type": "@type"
              },
              "name": "name",
              "description": "description",
              "id": "id",
              "uri": "uri"
            },
            {
              "symbol": "symbol",
              "uriHash": "uriHash",
              "data": {
                "@type": "@type"
              },
              "name": "name",
              "description": "description",
              "id": "id",
              "uri": "uri"
            }
          ]
        },
        "properties": {
          "classes": {
            "description": "class defines the class of the nft type.",
            "items": {
              "$ref": "#/components/schemas/Class"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryNFTResponse": {
        "description": "QueryNFTResponse is the response type for the Query/NFT RPC method",
        "example": {
          "nft": {
            "uriHash": "uriHash",
            "classId": "classId",
            "data": {
              "@type": "@type"
            },
            "id": "id",
            "uri": "uri"
          }
        },
        "properties": {
          "nft": {
            "$ref": "#/components/schemas/NFT"
          }
        },
        "type": "object"
      },
      "QueryNFTsResponse": {
        "description": "QueryNFTsResponse is the response type for the Query/NFTs RPC methods",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "nfts": [
            {
              "uriHash": "uriHash",
              "classId": "classId",
              "data": {
                "@type": "@type"
              },
              "id": "id",
              "uri": "uri"
            },
            {
              "uriHash": "uriHash",
              "classId": "classId",
              "data": {
                "@type": "@type"
              },
              "id": "id",
              "uri": "uri"
            }
          ]
        },
        "properties": {
          "nfts": {
            "description": "NFT defines the NFT",
            "items": {
              "$ref": "#/components/schemas/NFT"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryOwnerResponse": {
        "description": "QueryOwnerResponse is the response type for the Query/Owner RPC method",
        "example": {
          "owner": "owner"
        },
        "properties": {
          "owner": {
            "description": "owner is the owner address of the nft",
            "type": "string"
          }
        },
        "type": "object"
      },
      "QuerySupplyResponse": {
        "description": "QuerySupplyResponse is the response type for the Query/Supply RPC method",
        "example": {
          "amount": 0
        },
        "properties": {
          "amount": {
            "description": "amount is the number of all NFTs from the given class",
            "format": "uint64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "ParamChange": {
        "description": "ParamChange defines an individual parameter change, for use in ParameterChangeProposal.",
        "properties": {
          "subspace": {
            "type": "string"
          },
          "key": {
            "type": "string"
          },
          "value": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "QuerySubspacesResponse": {
        "description": "QuerySubspacesResponse defines the response types for querying for all registered subspaces and all keys for a subspace. Since: cosmos-sdk 0.46",
        "example": {
          "subspaces": [
            {
              "subspace": "subspace",
              "keys": ["keys", "keys"]
            },
            {
              "subspace": "subspace",
              "keys": ["keys", "keys"]
            }
          ]
        },
        "properties": {
          "subspaces": {
            "items": {
              "$ref": "#/components/schemas/Subspace"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "Subspace": {
        "description": "Subspace defines a parameter subspace name and all the keys that exist for the subspace. Since: cosmos-sdk 0.46",
        "example": {
          "subspace": "subspace",
          "keys": ["keys", "keys"]
        },
        "properties": {
          "subspace": {
            "type": "string"
          },
          "keys": {
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "QuerySigningInfoResponse": {
        "description": "QuerySigningInfoResponse is the response type for the Query/SigningInfo RPC method",
        "example": {
          "valSigningInfo": {
            "address": "address",
            "indexOffset": 6,
            "jailedUntil": "2000-01-23T04:56:07.000+00:00",
            "tombstoned": true,
            "startHeight": 0,
            "missedBlocksCounter": 1
          }
        },
        "properties": {
          "valSigningInfo": {
            "$ref": "#/components/schemas/ValidatorSigningInfo"
          }
        },
        "type": "object"
      },
      "QuerySigningInfosResponse": {
        "description": "QuerySigningInfosResponse is the response type for the Query/SigningInfos RPC method",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "info": [
            {
              "address": "address",
              "indexOffset": 6,
              "jailedUntil": "2000-01-23T04:56:07.000+00:00",
              "tombstoned": true,
              "startHeight": 0,
              "missedBlocksCounter": 1
            },
            {
              "address": "address",
              "indexOffset": 6,
              "jailedUntil": "2000-01-23T04:56:07.000+00:00",
              "tombstoned": true,
              "startHeight": 0,
              "missedBlocksCounter": 1
            }
          ]
        },
        "properties": {
          "info": {
            "description": "info is the signing info of all validators",
            "items": {
              "$ref": "#/components/schemas/ValidatorSigningInfo"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "ValidatorSigningInfo": {
        "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their liveness activity.",
        "example": {
          "address": "address",
          "indexOffset": 6,
          "jailedUntil": "2000-01-23T04:56:07.000+00:00",
          "tombstoned": true,
          "startHeight": 0,
          "missedBlocksCounter": 1
        },
        "properties": {
          "address": {
            "type": "string"
          },
          "startHeight": {
            "description": "Height at which validator was first a candidate OR was un-jailed",
            "format": "int64",
            "type": "integer"
          },
          "indexOffset": {
            "description": "Index which is incremented every time a validator is bonded in a block and _may_ have signed a pre-commit or not. This in conjunction with the signed_blocks_window param determines the index in the missed block bitmap.",
            "format": "int64",
            "type": "integer"
          },
          "jailedUntil": {
            "description": "Timestamp until which the validator is jailed due to liveness downtime.",
            "format": "date-time",
            "type": "string"
          },
          "tombstoned": {
            "description": "Whether or not a validator has been tombstoned (killed out of validator set). It is set once the validator commits an equivocation or for any other configured misbehavior.",
            "type": "boolean"
          },
          "missedBlocksCounter": {
            "description": "A counter of missed (unsigned) blocks. It is used to avoid unnecessary reads in the missed block bitmap.",
            "format": "int64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "Delegation": {
        "description": "Delegation represents the bond with tokens held by an account. It is owned by one delegator, and is associated with the voting power of one validator.",
        "example": {
          "shares": "shares",
          "validatorAddress": "validatorAddress",
          "delegatorAddress": "delegatorAddress"
        },
        "properties": {
          "delegatorAddress": {
            "description": "delegator_address is the encoded address of the delegator.",
            "type": "string"
          },
          "validatorAddress": {
            "description": "validator_address is the encoded address of the validator.",
            "type": "string"
          },
          "shares": {
            "description": "shares define the delegation shares received.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "DelegationResponse": {
        "description": "DelegationResponse is equivalent to Delegation except that it contains a balance in addition to shares which is more suitable for client responses.",
        "example": {
          "balance": {
            "amount": "amount",
            "denom": "denom"
          },
          "delegation": {
            "shares": "shares",
            "validatorAddress": "validatorAddress",
            "delegatorAddress": "delegatorAddress"
          }
        },
        "properties": {
          "delegation": {
            "$ref": "#/components/schemas/Delegation"
          },
          "balance": {
            "$ref": "#/components/schemas/Coin"
          }
        },
        "type": "object"
      },
      "HistoricalInfo": {
        "description": "HistoricalInfo contains header and validator information for a given block. It is stored as part of staking module's state, which persists the `n` most recent HistoricalInfo (`n` is set by the staking module's `historical_entries` parameter).",
        "example": {
          "valset": [
            {
              "votingPower": 1,
              "address": "address",
              "proposerPriority": 1,
              "pubKey": {
                "bn254": "bn254",
                "ed25519": "ed25519",
                "secp256k1": "secp256k1"
              }
            },
            {
              "votingPower": 1,
              "address": "address",
              "proposerPriority": 1,
              "pubKey": {
                "bn254": "bn254",
                "ed25519": "ed25519",
                "secp256k1": "secp256k1"
              }
            }
          ],
          "header": {
            "dataHash": "dataHash",
            "consensusHash": "consensusHash",
            "evidenceHash": "evidenceHash",
            "proposerAddress": "proposerAddress",
            "appHash": "appHash",
            "version": {
              "app": 1,
              "block": 6
            },
            "lastResultsHash": "lastResultsHash",
            "lastBlockId": {
              "partSetHeader": {
                "total": 0,
                "hash": "hash"
              },
              "hash": "hash"
            },
            "chainId": "chainId",
            "validatorsHash": "validatorsHash",
            "lastCommitHash": "lastCommitHash",
            "time": "2000-01-23T04:56:07.000+00:00",
            "nextValidatorsHash": "nextValidatorsHash",
            "height": 5
          }
        },
        "properties": {
          "header": {
            "$ref": "#/components/schemas/Header"
          },
          "valset": {
            "items": {
              "$ref": "#/components/schemas/Validator"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "Pool": {
        "description": "Pool is used for tracking bonded and not-bonded token supply of the bond denomination.",
        "example": {
          "notBondedTokens": "notBondedTokens",
          "bondedTokens": "bondedTokens"
        },
        "properties": {
          "notBondedTokens": {
            "type": "string"
          },
          "bondedTokens": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "PublicKey": {
        "description": "PublicKey defines the keys available for use with Validators",
        "example": {
          "bn254": "bn254",
          "ed25519": "ed25519",
          "secp256k1": "secp256k1"
        },
        "properties": {
          "ed25519": {
            "format": "bytes",
            "type": "string"
          },
          "secp256k1": {
            "format": "bytes",
            "type": "string"
          },
          "bn254": {
            "format": "bytes",
            "type": "string"
          }
        },
        "type": "object"
      },
      "QueryDelegationResponse": {
        "description": "QueryDelegationResponse is response type for the Query/Delegation RPC method.",
        "example": {
          "delegationResponse": {
            "balance": {
              "amount": "amount",
              "denom": "denom"
            },
            "delegation": {
              "shares": "shares",
              "validatorAddress": "validatorAddress",
              "delegatorAddress": "delegatorAddress"
            }
          }
        },
        "properties": {
          "delegationResponse": {
            "$ref": "#/components/schemas/DelegationResponse"
          }
        },
        "type": "object"
      },
      "QueryDelegatorDelegationsResponse": {
        "description": "QueryDelegatorDelegationsResponse is response type for the Query/DelegatorDelegations RPC method.",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "delegationResponses": [
            {
              "balance": {
                "amount": "amount",
                "denom": "denom"
              },
              "delegation": {
                "shares": "shares",
                "validatorAddress": "validatorAddress",
                "delegatorAddress": "delegatorAddress"
              }
            },
            {
              "balance": {
                "amount": "amount",
                "denom": "denom"
              },
              "delegation": {
                "shares": "shares",
                "validatorAddress": "validatorAddress",
                "delegatorAddress": "delegatorAddress"
              }
            }
          ]
        },
        "properties": {
          "delegationResponses": {
            "description": "delegation_responses defines all the delegations' info of a delegator.",
            "items": {
              "$ref": "#/components/schemas/DelegationResponse"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryDelegatorUnbondingDelegationsResponse": {
        "description": "QueryUnbondingDelegatorDelegationsResponse is response type for the Query/UnbondingDelegatorDelegations RPC method.",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "unbondingResponses": [
            {
              "entries": [
                {
                  "completionTime": "2000-01-23T04:56:07.000+00:00",
                  "creationHeight": 0,
                  "balance": "balance",
                  "initialBalance": "initialBalance",
                  "unbondingId": 6,
                  "unbondingOnHoldRefCount": 1
                },
                {
                  "completionTime": "2000-01-23T04:56:07.000+00:00",
                  "creationHeight": 0,
                  "balance": "balance",
                  "initialBalance": "initialBalance",
                  "unbondingId": 6,
                  "unbondingOnHoldRefCount": 1
                }
              ],
              "validatorAddress": "validatorAddress",
              "delegatorAddress": "delegatorAddress"
            },
            {
              "entries": [
                {
                  "completionTime": "2000-01-23T04:56:07.000+00:00",
                  "creationHeight": 0,
                  "balance": "balance",
                  "initialBalance": "initialBalance",
                  "unbondingId": 6,
                  "unbondingOnHoldRefCount": 1
                },
                {
                  "completionTime": "2000-01-23T04:56:07.000+00:00",
                  "creationHeight": 0,
                  "balance": "balance",
                  "initialBalance": "initialBalance",
                  "unbondingId": 6,
                  "unbondingOnHoldRefCount": 1
                }
              ],
              "validatorAddress": "validatorAddress",
              "delegatorAddress": "delegatorAddress"
            }
          ]
        },
        "properties": {
          "unbondingResponses": {
            "items": {
              "$ref": "#/components/schemas/UnbondingDelegation"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryDelegatorValidatorResponse": {
        "description": "QueryDelegatorValidatorResponse response type for the Query/DelegatorValidator RPC method.",
        "example": {
          "validator": {
            "votingPower": 1,
            "address": "address",
            "proposerPriority": 1,
            "pubKey": {
              "bn254": "bn254",
              "ed25519": "ed25519",
              "secp256k1": "secp256k1"
            }
          }
        },
        "properties": {
          "validator": {
            "$ref": "#/components/schemas/Validator"
          }
        },
        "type": "object"
      },
      "QueryHistoricalInfoResponse": {
        "description": "QueryHistoricalInfoResponse is response type for the Query/HistoricalInfo RPC method.",
        "example": {
          "hist": {
            "valset": [
              {
                "votingPower": 1,
                "address": "address",
                "proposerPriority": 1,
                "pubKey": {
                  "bn254": "bn254",
                  "ed25519": "ed25519",
                  "secp256k1": "secp256k1"
                }
              },
              {
                "votingPower": 1,
                "address": "address",
                "proposerPriority": 1,
                "pubKey": {
                  "bn254": "bn254",
                  "ed25519": "ed25519",
                  "secp256k1": "secp256k1"
                }
              }
            ],
            "header": {
              "dataHash": "dataHash",
              "consensusHash": "consensusHash",
              "evidenceHash": "evidenceHash",
              "proposerAddress": "proposerAddress",
              "appHash": "appHash",
              "version": {
                "app": 1,
                "block": 6
              },
              "lastResultsHash": "lastResultsHash",
              "lastBlockId": {
                "partSetHeader": {
                  "total": 0,
                  "hash": "hash"
                },
                "hash": "hash"
              },
              "chainId": "chainId",
              "validatorsHash": "validatorsHash",
              "lastCommitHash": "lastCommitHash",
              "time": "2000-01-23T04:56:07.000+00:00",
              "nextValidatorsHash": "nextValidatorsHash",
              "height": 5
            }
          }
        },
        "properties": {
          "hist": {
            "$ref": "#/components/schemas/HistoricalInfo"
          }
        },
        "type": "object"
      },
      "QueryPoolResponse": {
        "description": "QueryPoolResponse is response type for the Query/Pool RPC method.",
        "example": {
          "pool": {
            "notBondedTokens": "notBondedTokens",
            "bondedTokens": "bondedTokens"
          }
        },
        "properties": {
          "pool": {
            "$ref": "#/components/schemas/Pool"
          }
        },
        "type": "object"
      },
      "QueryRedelegationsResponse": {
        "description": "QueryRedelegationsResponse is response type for the Query/Redelegations RPC method.",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "redelegationResponses": [
            {
              "redelegation": {
                "validatorDstAddress": "validatorDstAddress",
                "entries": [
                  {
                    "sharesDst": "sharesDst",
                    "completionTime": "2000-01-23T04:56:07.000+00:00",
                    "creationHeight": 0,
                    "initialBalance": "initialBalance",
                    "unbondingId": 6,
                    "unbondingOnHoldRefCount": 1
                  },
                  {
                    "sharesDst": "sharesDst",
                    "completionTime": "2000-01-23T04:56:07.000+00:00",
                    "creationHeight": 0,
                    "initialBalance": "initialBalance",
                    "unbondingId": 6,
                    "unbondingOnHoldRefCount": 1
                  }
                ],
                "validatorSrcAddress": "validatorSrcAddress",
                "delegatorAddress": "delegatorAddress"
              },
              "entries": [
                {
                  "balance": "balance",
                  "redelegationEntry": {
                    "sharesDst": "sharesDst",
                    "completionTime": "2000-01-23T04:56:07.000+00:00",
                    "creationHeight": 0,
                    "initialBalance": "initialBalance",
                    "unbondingId": 6,
                    "unbondingOnHoldRefCount": 1
                  }
                },
                {
                  "balance": "balance",
                  "redelegationEntry": {
                    "sharesDst": "sharesDst",
                    "completionTime": "2000-01-23T04:56:07.000+00:00",
                    "creationHeight": 0,
                    "initialBalance": "initialBalance",
                    "unbondingId": 6,
                    "unbondingOnHoldRefCount": 1
                  }
                }
              ]
            },
            {
              "redelegation": {
                "validatorDstAddress": "validatorDstAddress",
                "entries": [
                  {
                    "sharesDst": "sharesDst",
                    "completionTime": "2000-01-23T04:56:07.000+00:00",
                    "creationHeight": 0,
                    "initialBalance": "initialBalance",
                    "unbondingId": 6,
                    "unbondingOnHoldRefCount": 1
                  },
                  {
                    "sharesDst": "sharesDst",
                    "completionTime": "2000-01-23T04:56:07.000+00:00",
                    "creationHeight": 0,
                    "initialBalance": "initialBalance",
                    "unbondingId": 6,
                    "unbondingOnHoldRefCount": 1
                  }
                ],
                "validatorSrcAddress": "validatorSrcAddress",
                "delegatorAddress": "delegatorAddress"
              },
              "entries": [
                {
                  "balance": "balance",
                  "redelegationEntry": {
                    "sharesDst": "sharesDst",
                    "completionTime": "2000-01-23T04:56:07.000+00:00",
                    "creationHeight": 0,
                    "initialBalance": "initialBalance",
                    "unbondingId": 6,
                    "unbondingOnHoldRefCount": 1
                  }
                },
                {
                  "balance": "balance",
                  "redelegationEntry": {
                    "sharesDst": "sharesDst",
                    "completionTime": "2000-01-23T04:56:07.000+00:00",
                    "creationHeight": 0,
                    "initialBalance": "initialBalance",
                    "unbondingId": 6,
                    "unbondingOnHoldRefCount": 1
                  }
                }
              ]
            }
          ]
        },
        "properties": {
          "redelegationResponses": {
            "items": {
              "$ref": "#/components/schemas/RedelegationResponse"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryUnbondingDelegationResponse": {
        "description": "QueryDelegationResponse is response type for the Query/UnbondingDelegation RPC method.",
        "example": {
          "unbond": {
            "entries": [
              {
                "completionTime": "2000-01-23T04:56:07.000+00:00",
                "creationHeight": 0,
                "balance": "balance",
                "initialBalance": "initialBalance",
                "unbondingId": 6,
                "unbondingOnHoldRefCount": 1
              },
              {
                "completionTime": "2000-01-23T04:56:07.000+00:00",
                "creationHeight": 0,
                "balance": "balance",
                "initialBalance": "initialBalance",
                "unbondingId": 6,
                "unbondingOnHoldRefCount": 1
              }
            ],
            "validatorAddress": "validatorAddress",
            "delegatorAddress": "delegatorAddress"
          }
        },
        "properties": {
          "unbond": {
            "$ref": "#/components/schemas/UnbondingDelegation"
          }
        },
        "type": "object"
      },
      "QueryValidatorDelegationsResponse": {
        "description": "QueryValidatorDelegationsResponse is response type for the Query/ValidatorDelegations RPC method",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "delegationResponses": [
            {
              "balance": {
                "amount": "amount",
                "denom": "denom"
              },
              "delegation": {
                "shares": "shares",
                "validatorAddress": "validatorAddress",
                "delegatorAddress": "delegatorAddress"
              }
            },
            {
              "balance": {
                "amount": "amount",
                "denom": "denom"
              },
              "delegation": {
                "shares": "shares",
                "validatorAddress": "validatorAddress",
                "delegatorAddress": "delegatorAddress"
              }
            }
          ]
        },
        "properties": {
          "delegationResponses": {
            "items": {
              "$ref": "#/components/schemas/DelegationResponse"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryValidatorResponse": {
        "description": "QueryValidatorResponse is response type for the Query/Validator RPC method",
        "example": {
          "validator": {
            "votingPower": 1,
            "address": "address",
            "proposerPriority": 1,
            "pubKey": {
              "bn254": "bn254",
              "ed25519": "ed25519",
              "secp256k1": "secp256k1"
            }
          }
        },
        "properties": {
          "validator": {
            "$ref": "#/components/schemas/Validator"
          }
        },
        "type": "object"
      },
      "QueryValidatorUnbondingDelegationsResponse": {
        "description": "QueryValidatorUnbondingDelegationsResponse is response type for the Query/ValidatorUnbondingDelegations RPC method.",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "unbondingResponses": [
            {
              "entries": [
                {
                  "completionTime": "2000-01-23T04:56:07.000+00:00",
                  "creationHeight": 0,
                  "balance": "balance",
                  "initialBalance": "initialBalance",
                  "unbondingId": 6,
                  "unbondingOnHoldRefCount": 1
                },
                {
                  "completionTime": "2000-01-23T04:56:07.000+00:00",
                  "creationHeight": 0,
                  "balance": "balance",
                  "initialBalance": "initialBalance",
                  "unbondingId": 6,
                  "unbondingOnHoldRefCount": 1
                }
              ],
              "validatorAddress": "validatorAddress",
              "delegatorAddress": "delegatorAddress"
            },
            {
              "entries": [
                {
                  "completionTime": "2000-01-23T04:56:07.000+00:00",
                  "creationHeight": 0,
                  "balance": "balance",
                  "initialBalance": "initialBalance",
                  "unbondingId": 6,
                  "unbondingOnHoldRefCount": 1
                },
                {
                  "completionTime": "2000-01-23T04:56:07.000+00:00",
                  "creationHeight": 0,
                  "balance": "balance",
                  "initialBalance": "initialBalance",
                  "unbondingId": 6,
                  "unbondingOnHoldRefCount": 1
                }
              ],
              "validatorAddress": "validatorAddress",
              "delegatorAddress": "delegatorAddress"
            }
          ]
        },
        "properties": {
          "unbondingResponses": {
            "items": {
              "$ref": "#/components/schemas/UnbondingDelegation"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "QueryValidatorsResponse": {
        "description": "QueryValidatorsResponse is response type for the Query/Validators RPC method",
        "example": {
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "validators": [
            {
              "votingPower": 1,
              "address": "address",
              "proposerPriority": 1,
              "pubKey": {
                "bn254": "bn254",
                "ed25519": "ed25519",
                "secp256k1": "secp256k1"
              }
            },
            {
              "votingPower": 1,
              "address": "address",
              "proposerPriority": 1,
              "pubKey": {
                "bn254": "bn254",
                "ed25519": "ed25519",
                "secp256k1": "secp256k1"
              }
            }
          ]
        },
        "properties": {
          "validators": {
            "description": "validators contains all the queried validators.",
            "items": {
              "$ref": "#/components/schemas/Validator"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "Redelegation": {
        "description": "Redelegation contains the list of a particular delegator's redelegating bonds from a particular source validator to a particular destination validator.",
        "example": {
          "validatorDstAddress": "validatorDstAddress",
          "entries": [
            {
              "sharesDst": "sharesDst",
              "completionTime": "2000-01-23T04:56:07.000+00:00",
              "creationHeight": 0,
              "initialBalance": "initialBalance",
              "unbondingId": 6,
              "unbondingOnHoldRefCount": 1
            },
            {
              "sharesDst": "sharesDst",
              "completionTime": "2000-01-23T04:56:07.000+00:00",
              "creationHeight": 0,
              "initialBalance": "initialBalance",
              "unbondingId": 6,
              "unbondingOnHoldRefCount": 1
            }
          ],
          "validatorSrcAddress": "validatorSrcAddress",
          "delegatorAddress": "delegatorAddress"
        },
        "properties": {
          "delegatorAddress": {
            "description": "delegator_address is the bech32-encoded address of the delegator.",
            "type": "string"
          },
          "validatorSrcAddress": {
            "description": "validator_src_address is the validator redelegation source operator address.",
            "type": "string"
          },
          "validatorDstAddress": {
            "description": "validator_dst_address is the validator redelegation destination operator address.",
            "type": "string"
          },
          "entries": {
            "description": "entries are the redelegation entries.",
            "items": {
              "$ref": "#/components/schemas/RedelegationEntry"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "RedelegationEntry": {
        "description": "RedelegationEntry defines a redelegation object with relevant metadata.",
        "example": {
          "sharesDst": "sharesDst",
          "completionTime": "2000-01-23T04:56:07.000+00:00",
          "creationHeight": 0,
          "initialBalance": "initialBalance",
          "unbondingId": 6,
          "unbondingOnHoldRefCount": 1
        },
        "properties": {
          "creationHeight": {
            "description": "creation_height  defines the height which the redelegation took place.",
            "format": "int64",
            "type": "integer"
          },
          "completionTime": {
            "description": "completion_time defines the unix time for redelegation completion.",
            "format": "date-time",
            "type": "string"
          },
          "initialBalance": {
            "description": "initial_balance defines the initial balance when redelegation started.",
            "type": "string"
          },
          "sharesDst": {
            "description": "shares_dst is the amount of destination-validator shares created by redelegation.",
            "type": "string"
          },
          "unbondingId": {
            "description": "Incrementing id that uniquely identifies this entry",
            "format": "uint64",
            "type": "integer"
          },
          "unbondingOnHoldRefCount": {
            "description": "Strictly positive if this entry's unbonding has been stopped by external modules",
            "format": "int64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "RedelegationEntryResponse": {
        "description": "RedelegationEntryResponse is equivalent to a RedelegationEntry except that it contains a balance in addition to shares which is more suitable for client responses.",
        "example": {
          "balance": "balance",
          "redelegationEntry": {
            "sharesDst": "sharesDst",
            "completionTime": "2000-01-23T04:56:07.000+00:00",
            "creationHeight": 0,
            "initialBalance": "initialBalance",
            "unbondingId": 6,
            "unbondingOnHoldRefCount": 1
          }
        },
        "properties": {
          "redelegationEntry": {
            "$ref": "#/components/schemas/RedelegationEntry"
          },
          "balance": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "RedelegationResponse": {
        "description": "RedelegationResponse is equivalent to a Redelegation except that its entries contain a balance in addition to shares which is more suitable for client responses.",
        "example": {
          "redelegation": {
            "validatorDstAddress": "validatorDstAddress",
            "entries": [
              {
                "sharesDst": "sharesDst",
                "completionTime": "2000-01-23T04:56:07.000+00:00",
                "creationHeight": 0,
                "initialBalance": "initialBalance",
                "unbondingId": 6,
                "unbondingOnHoldRefCount": 1
              },
              {
                "sharesDst": "sharesDst",
                "completionTime": "2000-01-23T04:56:07.000+00:00",
                "creationHeight": 0,
                "initialBalance": "initialBalance",
                "unbondingId": 6,
                "unbondingOnHoldRefCount": 1
              }
            ],
            "validatorSrcAddress": "validatorSrcAddress",
            "delegatorAddress": "delegatorAddress"
          },
          "entries": [
            {
              "balance": "balance",
              "redelegationEntry": {
                "sharesDst": "sharesDst",
                "completionTime": "2000-01-23T04:56:07.000+00:00",
                "creationHeight": 0,
                "initialBalance": "initialBalance",
                "unbondingId": 6,
                "unbondingOnHoldRefCount": 1
              }
            },
            {
              "balance": "balance",
              "redelegationEntry": {
                "sharesDst": "sharesDst",
                "completionTime": "2000-01-23T04:56:07.000+00:00",
                "creationHeight": 0,
                "initialBalance": "initialBalance",
                "unbondingId": 6,
                "unbondingOnHoldRefCount": 1
              }
            }
          ]
        },
        "properties": {
          "redelegation": {
            "$ref": "#/components/schemas/Redelegation"
          },
          "entries": {
            "items": {
              "$ref": "#/components/schemas/RedelegationEntryResponse"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "UnbondingDelegation": {
        "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds for a single validator in an time-ordered list.",
        "example": {
          "entries": [
            {
              "completionTime": "2000-01-23T04:56:07.000+00:00",
              "creationHeight": 0,
              "balance": "balance",
              "initialBalance": "initialBalance",
              "unbondingId": 6,
              "unbondingOnHoldRefCount": 1
            },
            {
              "completionTime": "2000-01-23T04:56:07.000+00:00",
              "creationHeight": 0,
              "balance": "balance",
              "initialBalance": "initialBalance",
              "unbondingId": 6,
              "unbondingOnHoldRefCount": 1
            }
          ],
          "validatorAddress": "validatorAddress",
          "delegatorAddress": "delegatorAddress"
        },
        "properties": {
          "delegatorAddress": {
            "description": "delegator_address is the encoded address of the delegator.",
            "type": "string"
          },
          "validatorAddress": {
            "description": "validator_address is the encoded address of the validator.",
            "type": "string"
          },
          "entries": {
            "description": "entries are the unbonding delegation entries.",
            "items": {
              "$ref": "#/components/schemas/UnbondingDelegationEntry"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "UnbondingDelegationEntry": {
        "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata.",
        "example": {
          "completionTime": "2000-01-23T04:56:07.000+00:00",
          "creationHeight": 0,
          "balance": "balance",
          "initialBalance": "initialBalance",
          "unbondingId": 6,
          "unbondingOnHoldRefCount": 1
        },
        "properties": {
          "creationHeight": {
            "description": "creation_height is the height which the unbonding took place.",
            "format": "int64",
            "type": "integer"
          },
          "completionTime": {
            "description": "completion_time is the unix time for unbonding completion.",
            "format": "date-time",
            "type": "string"
          },
          "initialBalance": {
            "description": "initial_balance defines the tokens initially scheduled to receive at completion.",
            "type": "string"
          },
          "balance": {
            "description": "balance defines the tokens to receive at completion.",
            "type": "string"
          },
          "unbondingId": {
            "description": "Incrementing id that uniquely identifies this entry",
            "format": "uint64",
            "type": "integer"
          },
          "unbondingOnHoldRefCount": {
            "description": "Strictly positive if this entry's unbonding has been stopped by external modules",
            "format": "int64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "ABCIMessageLog": {
        "description": "ABCIMessageLog defines a structure containing an indexed tx ABCI message log.",
        "example": {
          "log": "log",
          "msgIndex": 1,
          "events": [
            {
              "attributes": [
                {
                  "value": "value",
                  "key": "key"
                },
                {
                  "value": "value",
                  "key": "key"
                }
              ],
              "type": "type"
            },
            {
              "attributes": [
                {
                  "value": "value",
                  "key": "key"
                },
                {
                  "value": "value",
                  "key": "key"
                }
              ],
              "type": "type"
            }
          ]
        },
        "properties": {
          "msgIndex": {
            "format": "uint32",
            "type": "integer"
          },
          "log": {
            "type": "string"
          },
          "events": {
            "description": "Events contains a slice of Event objects that were emitted during some execution.",
            "items": {
              "$ref": "#/components/schemas/StringEvent"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "Attribute": {
        "description": "Attribute defines an attribute wrapper where the key and value are strings instead of raw bytes.",
        "example": {
          "value": "value",
          "key": "key"
        },
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "AuthInfo": {
        "description": "AuthInfo describes the fee and signer modes that are used to sign a transaction.",
        "example": {
          "signerInfos": [
            {
              "sequence": 5,
              "publicKey": {
                "@type": "@type"
              },
              "modeInfo": {
                "single": {
                  "mode": 6
                },
                "multi": {
                  "modeInfos": [null, null],
                  "bitarray": {
                    "extraBitsStored": 1,
                    "elems": "elems"
                  }
                }
              }
            },
            {
              "sequence": 5,
              "publicKey": {
                "@type": "@type"
              },
              "modeInfo": {
                "single": {
                  "mode": 6
                },
                "multi": {
                  "modeInfos": [null, null],
                  "bitarray": {
                    "extraBitsStored": 1,
                    "elems": "elems"
                  }
                }
              }
            }
          ],
          "fee": {
            "gasLimit": 5,
            "amount": [
              {
                "amount": "amount",
                "denom": "denom"
              },
              {
                "amount": "amount",
                "denom": "denom"
              }
            ],
            "payer": "payer",
            "granter": "granter"
          },
          "tip": {
            "amount": [
              {
                "amount": "amount",
                "denom": "denom"
              },
              {
                "amount": "amount",
                "denom": "denom"
              }
            ],
            "tipper": "tipper"
          }
        },
        "properties": {
          "signerInfos": {
            "description": "signer_infos defines the signing modes for the required signers. The number and order of elements must match the required signers from TxBody's messages. The first element is the primary signer and the one which pays the fee.",
            "items": {
              "$ref": "#/components/schemas/SignerInfo"
            },
            "type": "array"
          },
          "fee": {
            "$ref": "#/components/schemas/Fee"
          },
          "tip": {
            "$ref": "#/components/schemas/Tip"
          }
        },
        "type": "object"
      },
      "BroadcastTxRequest": {
        "description": "BroadcastTxRequest is the request type for the Service.BroadcastTxRequest RPC method.",
        "example": {
          "mode": 0,
          "txBytes": "txBytes"
        },
        "properties": {
          "txBytes": {
            "description": "tx_bytes is the raw transaction.",
            "format": "bytes",
            "type": "string"
          },
          "mode": {
            "format": "enum",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "BroadcastTxResponse": {
        "description": "BroadcastTxResponse is the response type for the Service.BroadcastTx method.",
        "example": {
          "txResponse": {
            "code": 6,
            "data": "data",
            "tx": {
              "@type": "@type"
            },
            "rawLog": "rawLog",
            "txhash": "txhash",
            "gasWanted": 5,
            "gasUsed": 5,
            "codespace": "codespace",
            "logs": [
              {
                "log": "log",
                "msgIndex": 1,
                "events": [
                  {
                    "attributes": [
                      {
                        "value": "value",
                        "key": "key"
                      },
                      {
                        "value": "value",
                        "key": "key"
                      }
                    ],
                    "type": "type"
                  },
                  {
                    "attributes": [
                      {
                        "value": "value",
                        "key": "key"
                      },
                      {
                        "value": "value",
                        "key": "key"
                      }
                    ],
                    "type": "type"
                  }
                ]
              },
              {
                "log": "log",
                "msgIndex": 1,
                "events": [
                  {
                    "attributes": [
                      {
                        "value": "value",
                        "key": "key"
                      },
                      {
                        "value": "value",
                        "key": "key"
                      }
                    ],
                    "type": "type"
                  },
                  {
                    "attributes": [
                      {
                        "value": "value",
                        "key": "key"
                      },
                      {
                        "value": "value",
                        "key": "key"
                      }
                    ],
                    "type": "type"
                  }
                ]
              }
            ],
            "events": [
              {
                "attributes": [
                  {
                    "index": true,
                    "value": "value",
                    "key": "key"
                  },
                  {
                    "index": true,
                    "value": "value",
                    "key": "key"
                  }
                ],
                "type": "type"
              },
              {
                "attributes": [
                  {
                    "index": true,
                    "value": "value",
                    "key": "key"
                  },
                  {
                    "index": true,
                    "value": "value",
                    "key": "key"
                  }
                ],
                "type": "type"
              }
            ],
            "height": 0,
            "info": "info",
            "timestamp": "timestamp"
          }
        },
        "properties": {
          "txResponse": {
            "$ref": "#/components/schemas/TxResponse"
          }
        },
        "type": "object"
      },
      "CompactBitArray": {
        "description": "CompactBitArray is an implementation of a space efficient bit array. This is used to ensure that the encoded data takes up a minimal amount of space after proto encoding. This is not thread safe, and is not intended for concurrent usage.",
        "example": {
          "extraBitsStored": 1,
          "elems": "elems"
        },
        "properties": {
          "extraBitsStored": {
            "format": "uint32",
            "type": "integer"
          },
          "elems": {
            "format": "bytes",
            "type": "string"
          }
        },
        "type": "object"
      },
      "Event": {
        "description": "Event allows application developers to attach additional information to ResponseFinalizeBlock and ResponseCheckTx. Later, transactions may be queried using these events.",
        "example": {
          "attributes": [
            {
              "index": true,
              "value": "value",
              "key": "key"
            },
            {
              "index": true,
              "value": "value",
              "key": "key"
            }
          ],
          "type": "type"
        },
        "properties": {
          "type": {
            "type": "string"
          },
          "attributes": {
            "items": {
              "$ref": "#/components/schemas/EventAttribute"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "EventAttribute": {
        "description": "EventAttribute is a single key-value pair, associated with an event.",
        "example": {
          "index": true,
          "value": "value",
          "key": "key"
        },
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "type": "string"
          },
          "index": {
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "Fee": {
        "description": "Fee includes the amount of coins paid in fees and the maximum gas to be used by the transaction. The ratio yields an effective \"gasprice\", which must be above some miminum to be accepted into the mempool.",
        "example": {
          "gasLimit": 5,
          "amount": [
            {
              "amount": "amount",
              "denom": "denom"
            },
            {
              "amount": "amount",
              "denom": "denom"
            }
          ],
          "payer": "payer",
          "granter": "granter"
        },
        "properties": {
          "amount": {
            "description": "amount is the amount of coins to be paid as a fee",
            "items": {
              "$ref": "#/components/schemas/Coin"
            },
            "type": "array"
          },
          "gasLimit": {
            "description": "gas_limit is the maximum gas that can be used in transaction processing before an out of gas error occurs",
            "format": "uint64",
            "type": "integer"
          },
          "payer": {
            "description": "if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees. the payer must be a tx signer (and thus have signed this field in AuthInfo). setting this field does *not* change the ordering of required signers for the transaction.",
            "type": "string"
          },
          "granter": {
            "description": "if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used to pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does not support fee grants, this will fail",
            "type": "string"
          }
        },
        "type": "object"
      },
      "GasInfo": {
        "description": "GasInfo defines tx execution gas context.",
        "example": {
          "gasUsed": 6,
          "gasWanted": 0
        },
        "properties": {
          "gasWanted": {
            "description": "GasWanted is the maximum units of work we allow this tx to perform.",
            "format": "uint64",
            "type": "integer"
          },
          "gasUsed": {
            "description": "GasUsed is the amount of gas actually consumed.",
            "format": "uint64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "GetBlockWithTxsResponse": {
        "description": "GetBlockWithTxsResponse is the response type for the Service.GetBlockWithTxs method. Since: cosmos-sdk 0.45.2",
        "example": {
          "blockId": {
            "partSetHeader": {
              "total": 0,
              "hash": "hash"
            },
            "hash": "hash"
          },
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "block": {
            "data": {
              "txs": ["txs", "txs"]
            },
            "evidence": {
              "evidence": [
                {
                  "lightClientAttackEvidence": {
                    "commonHeight": 7,
                    "totalVotingPower": 1,
                    "conflictingBlock": {
                      "signedHeader": {
                        "commit": {
                          "blockId": {
                            "partSetHeader": {
                              "total": 0,
                              "hash": "hash"
                            },
                            "hash": "hash"
                          },
                          "round": 7,
                          "signatures": [
                            {
                              "blockIdFlag": 1,
                              "signature": "signature",
                              "validatorAddress": "validatorAddress",
                              "timestamp": "2000-01-23T04:56:07.000+00:00"
                            },
                            {
                              "blockIdFlag": 1,
                              "signature": "signature",
                              "validatorAddress": "validatorAddress",
                              "timestamp": "2000-01-23T04:56:07.000+00:00"
                            }
                          ],
                          "height": 4
                        },
                        "header": {
                          "dataHash": "dataHash",
                          "consensusHash": "consensusHash",
                          "evidenceHash": "evidenceHash",
                          "proposerAddress": "proposerAddress",
                          "appHash": "appHash",
                          "version": {
                            "app": 1,
                            "block": 6
                          },
                          "lastResultsHash": "lastResultsHash",
                          "lastBlockId": {
                            "partSetHeader": {
                              "total": 0,
                              "hash": "hash"
                            },
                            "hash": "hash"
                          },
                          "chainId": "chainId",
                          "validatorsHash": "validatorsHash",
                          "lastCommitHash": "lastCommitHash",
                          "time": "2000-01-23T04:56:07.000+00:00",
                          "nextValidatorsHash": "nextValidatorsHash",
                          "height": 5
                        }
                      },
                      "validatorSet": {
                        "totalVotingPower": 6,
                        "validators": [
                          {
                            "votingPower": 1,
                            "address": "address",
                            "proposerPriority": 1,
                            "pubKey": {
                              "bn254": "bn254",
                              "ed25519": "ed25519",
                              "secp256k1": "secp256k1"
                            }
                          },
                          {
                            "votingPower": 1,
                            "address": "address",
                            "proposerPriority": 1,
                            "pubKey": {
                              "bn254": "bn254",
                              "ed25519": "ed25519",
                              "secp256k1": "secp256k1"
                            }
                          }
                        ],
                        "proposer": {
                          "votingPower": 1,
                          "address": "address",
                          "proposerPriority": 1,
                          "pubKey": {
                            "bn254": "bn254",
                            "ed25519": "ed25519",
                            "secp256k1": "secp256k1"
                          }
                        }
                      }
                    },
                    "byzantineValidators": [
                      {
                        "votingPower": 1,
                        "address": "address",
                        "proposerPriority": 1,
                        "pubKey": {
                          "bn254": "bn254",
                          "ed25519": "ed25519",
                          "secp256k1": "secp256k1"
                        }
                      },
                      {
                        "votingPower": 1,
                        "address": "address",
                        "proposerPriority": 1,
                        "pubKey": {
                          "bn254": "bn254",
                          "ed25519": "ed25519",
                          "secp256k1": "secp256k1"
                        }
                      }
                    ],
                    "timestamp": "2000-01-23T04:56:07.000+00:00"
                  },
                  "duplicateVoteEvidence": {
                    "totalVotingPower": 3,
                    "voteA": {
                      "blockId": {
                        "partSetHeader": {
                          "total": 0,
                          "hash": "hash"
                        },
                        "hash": "hash"
                      },
                      "extension": "extension",
                      "round": 7,
                      "signature": "signature",
                      "validatorAddress": "validatorAddress",
                      "validatorIndex": 9,
                      "type": 5,
                      "extensionSignature": "extensionSignature",
                      "height": 2,
                      "timestamp": "2000-01-23T04:56:07.000+00:00"
                    },
                    "voteB": {
                      "blockId": {
                        "partSetHeader": {
                          "total": 0,
                          "hash": "hash"
                        },
                        "hash": "hash"
                      },
                      "extension": "extension",
                      "round": 7,
                      "signature": "signature",
                      "validatorAddress": "validatorAddress",
                      "validatorIndex": 9,
                      "type": 5,
                      "extensionSignature": "extensionSignature",
                      "height": 2,
                      "timestamp": "2000-01-23T04:56:07.000+00:00"
                    },
                    "validatorPower": 2,
                    "timestamp": "2000-01-23T04:56:07.000+00:00"
                  }
                },
                {
                  "lightClientAttackEvidence": {
                    "commonHeight": 7,
                    "totalVotingPower": 1,
                    "conflictingBlock": {
                      "signedHeader": {
                        "commit": {
                          "blockId": {
                            "partSetHeader": {
                              "total": 0,
                              "hash": "hash"
                            },
                            "hash": "hash"
                          },
                          "round": 7,
                          "signatures": [
                            {
                              "blockIdFlag": 1,
                              "signature": "signature",
                              "validatorAddress": "validatorAddress",
                              "timestamp": "2000-01-23T04:56:07.000+00:00"
                            },
                            {
                              "blockIdFlag": 1,
                              "signature": "signature",
                              "validatorAddress": "validatorAddress",
                              "timestamp": "2000-01-23T04:56:07.000+00:00"
                            }
                          ],
                          "height": 4
                        },
                        "header": {
                          "dataHash": "dataHash",
                          "consensusHash": "consensusHash",
                          "evidenceHash": "evidenceHash",
                          "proposerAddress": "proposerAddress",
                          "appHash": "appHash",
                          "version": {
                            "app": 1,
                            "block": 6
                          },
                          "lastResultsHash": "lastResultsHash",
                          "lastBlockId": {
                            "partSetHeader": {
                              "total": 0,
                              "hash": "hash"
                            },
                            "hash": "hash"
                          },
                          "chainId": "chainId",
                          "validatorsHash": "validatorsHash",
                          "lastCommitHash": "lastCommitHash",
                          "time": "2000-01-23T04:56:07.000+00:00",
                          "nextValidatorsHash": "nextValidatorsHash",
                          "height": 5
                        }
                      },
                      "validatorSet": {
                        "totalVotingPower": 6,
                        "validators": [
                          {
                            "votingPower": 1,
                            "address": "address",
                            "proposerPriority": 1,
                            "pubKey": {
                              "bn254": "bn254",
                              "ed25519": "ed25519",
                              "secp256k1": "secp256k1"
                            }
                          },
                          {
                            "votingPower": 1,
                            "address": "address",
                            "proposerPriority": 1,
                            "pubKey": {
                              "bn254": "bn254",
                              "ed25519": "ed25519",
                              "secp256k1": "secp256k1"
                            }
                          }
                        ],
                        "proposer": {
                          "votingPower": 1,
                          "address": "address",
                          "proposerPriority": 1,
                          "pubKey": {
                            "bn254": "bn254",
                            "ed25519": "ed25519",
                            "secp256k1": "secp256k1"
                          }
                        }
                      }
                    },
                    "byzantineValidators": [
                      {
                        "votingPower": 1,
                        "address": "address",
                        "proposerPriority": 1,
                        "pubKey": {
                          "bn254": "bn254",
                          "ed25519": "ed25519",
                          "secp256k1": "secp256k1"
                        }
                      },
                      {
                        "votingPower": 1,
                        "address": "address",
                        "proposerPriority": 1,
                        "pubKey": {
                          "bn254": "bn254",
                          "ed25519": "ed25519",
                          "secp256k1": "secp256k1"
                        }
                      }
                    ],
                    "timestamp": "2000-01-23T04:56:07.000+00:00"
                  },
                  "duplicateVoteEvidence": {
                    "totalVotingPower": 3,
                    "voteA": {
                      "blockId": {
                        "partSetHeader": {
                          "total": 0,
                          "hash": "hash"
                        },
                        "hash": "hash"
                      },
                      "extension": "extension",
                      "round": 7,
                      "signature": "signature",
                      "validatorAddress": "validatorAddress",
                      "validatorIndex": 9,
                      "type": 5,
                      "extensionSignature": "extensionSignature",
                      "height": 2,
                      "timestamp": "2000-01-23T04:56:07.000+00:00"
                    },
                    "voteB": {
                      "blockId": {
                        "partSetHeader": {
                          "total": 0,
                          "hash": "hash"
                        },
                        "hash": "hash"
                      },
                      "extension": "extension",
                      "round": 7,
                      "signature": "signature",
                      "validatorAddress": "validatorAddress",
                      "validatorIndex": 9,
                      "type": 5,
                      "extensionSignature": "extensionSignature",
                      "height": 2,
                      "timestamp": "2000-01-23T04:56:07.000+00:00"
                    },
                    "validatorPower": 2,
                    "timestamp": "2000-01-23T04:56:07.000+00:00"
                  }
                }
              ]
            },
            "header": {
              "dataHash": "dataHash",
              "consensusHash": "consensusHash",
              "evidenceHash": "evidenceHash",
              "proposerAddress": "proposerAddress",
              "appHash": "appHash",
              "version": {
                "app": 1,
                "block": 6
              },
              "lastResultsHash": "lastResultsHash",
              "lastBlockId": {
                "partSetHeader": {
                  "total": 0,
                  "hash": "hash"
                },
                "hash": "hash"
              },
              "chainId": "chainId",
              "validatorsHash": "validatorsHash",
              "lastCommitHash": "lastCommitHash",
              "time": "2000-01-23T04:56:07.000+00:00",
              "nextValidatorsHash": "nextValidatorsHash",
              "height": 5
            },
            "lastCommit": {
              "blockId": {
                "partSetHeader": {
                  "total": 0,
                  "hash": "hash"
                },
                "hash": "hash"
              },
              "round": 7,
              "signatures": [
                {
                  "blockIdFlag": 1,
                  "signature": "signature",
                  "validatorAddress": "validatorAddress",
                  "timestamp": "2000-01-23T04:56:07.000+00:00"
                },
                {
                  "blockIdFlag": 1,
                  "signature": "signature",
                  "validatorAddress": "validatorAddress",
                  "timestamp": "2000-01-23T04:56:07.000+00:00"
                }
              ],
              "height": 4
            }
          },
          "txs": [
            {
              "body": {
                "timeoutHeight": 0,
                "messages": [
                  {
                    "@type": "@type"
                  },
                  {
                    "@type": "@type"
                  }
                ],
                "memo": "memo",
                "extensionOptions": [
                  {
                    "@type": "@type"
                  },
                  {
                    "@type": "@type"
                  }
                ],
                "nonCriticalExtensionOptions": [
                  {
                    "@type": "@type"
                  },
                  {
                    "@type": "@type"
                  }
                ]
              },
              "signatures": ["signatures", "signatures"],
              "authInfo": {
                "signerInfos": [
                  {
                    "sequence": 5,
                    "publicKey": {
                      "@type": "@type"
                    },
                    "modeInfo": {
                      "single": {
                        "mode": 6
                      },
                      "multi": {
                        "modeInfos": [null, null],
                        "bitarray": {
                          "extraBitsStored": 1,
                          "elems": "elems"
                        }
                      }
                    }
                  },
                  {
                    "sequence": 5,
                    "publicKey": {
                      "@type": "@type"
                    },
                    "modeInfo": {
                      "single": {
                        "mode": 6
                      },
                      "multi": {
                        "modeInfos": [null, null],
                        "bitarray": {
                          "extraBitsStored": 1,
                          "elems": "elems"
                        }
                      }
                    }
                  }
                ],
                "fee": {
                  "gasLimit": 5,
                  "amount": [
                    {
                      "amount": "amount",
                      "denom": "denom"
                    },
                    {
                      "amount": "amount",
                      "denom": "denom"
                    }
                  ],
                  "payer": "payer",
                  "granter": "granter"
                },
                "tip": {
                  "amount": [
                    {
                      "amount": "amount",
                      "denom": "denom"
                    },
                    {
                      "amount": "amount",
                      "denom": "denom"
                    }
                  ],
                  "tipper": "tipper"
                }
              }
            },
            {
              "body": {
                "timeoutHeight": 0,
                "messages": [
                  {
                    "@type": "@type"
                  },
                  {
                    "@type": "@type"
                  }
                ],
                "memo": "memo",
                "extensionOptions": [
                  {
                    "@type": "@type"
                  },
                  {
                    "@type": "@type"
                  }
                ],
                "nonCriticalExtensionOptions": [
                  {
                    "@type": "@type"
                  },
                  {
                    "@type": "@type"
                  }
                ]
              },
              "signatures": ["signatures", "signatures"],
              "authInfo": {
                "signerInfos": [
                  {
                    "sequence": 5,
                    "publicKey": {
                      "@type": "@type"
                    },
                    "modeInfo": {
                      "single": {
                        "mode": 6
                      },
                      "multi": {
                        "modeInfos": [null, null],
                        "bitarray": {
                          "extraBitsStored": 1,
                          "elems": "elems"
                        }
                      }
                    }
                  },
                  {
                    "sequence": 5,
                    "publicKey": {
                      "@type": "@type"
                    },
                    "modeInfo": {
                      "single": {
                        "mode": 6
                      },
                      "multi": {
                        "modeInfos": [null, null],
                        "bitarray": {
                          "extraBitsStored": 1,
                          "elems": "elems"
                        }
                      }
                    }
                  }
                ],
                "fee": {
                  "gasLimit": 5,
                  "amount": [
                    {
                      "amount": "amount",
                      "denom": "denom"
                    },
                    {
                      "amount": "amount",
                      "denom": "denom"
                    }
                  ],
                  "payer": "payer",
                  "granter": "granter"
                },
                "tip": {
                  "amount": [
                    {
                      "amount": "amount",
                      "denom": "denom"
                    },
                    {
                      "amount": "amount",
                      "denom": "denom"
                    }
                  ],
                  "tipper": "tipper"
                }
              }
            }
          ]
        },
        "properties": {
          "txs": {
            "description": "txs are the transactions in the block.",
            "items": {
              "$ref": "#/components/schemas/Tx"
            },
            "type": "array"
          },
          "blockId": {
            "$ref": "#/components/schemas/BlockID"
          },
          "block": {
            "$ref": "#/components/schemas/Block"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          }
        },
        "type": "object"
      },
      "GetTxResponse": {
        "description": "GetTxResponse is the response type for the Service.GetTx method.",
        "example": {
          "tx": {
            "body": {
              "timeoutHeight": 0,
              "messages": [
                {
                  "@type": "@type"
                },
                {
                  "@type": "@type"
                }
              ],
              "memo": "memo",
              "extensionOptions": [
                {
                  "@type": "@type"
                },
                {
                  "@type": "@type"
                }
              ],
              "nonCriticalExtensionOptions": [
                {
                  "@type": "@type"
                },
                {
                  "@type": "@type"
                }
              ]
            },
            "signatures": ["signatures", "signatures"],
            "authInfo": {
              "signerInfos": [
                {
                  "sequence": 5,
                  "publicKey": {
                    "@type": "@type"
                  },
                  "modeInfo": {
                    "single": {
                      "mode": 6
                    },
                    "multi": {
                      "modeInfos": [null, null],
                      "bitarray": {
                        "extraBitsStored": 1,
                        "elems": "elems"
                      }
                    }
                  }
                },
                {
                  "sequence": 5,
                  "publicKey": {
                    "@type": "@type"
                  },
                  "modeInfo": {
                    "single": {
                      "mode": 6
                    },
                    "multi": {
                      "modeInfos": [null, null],
                      "bitarray": {
                        "extraBitsStored": 1,
                        "elems": "elems"
                      }
                    }
                  }
                }
              ],
              "fee": {
                "gasLimit": 5,
                "amount": [
                  {
                    "amount": "amount",
                    "denom": "denom"
                  },
                  {
                    "amount": "amount",
                    "denom": "denom"
                  }
                ],
                "payer": "payer",
                "granter": "granter"
              },
              "tip": {
                "amount": [
                  {
                    "amount": "amount",
                    "denom": "denom"
                  },
                  {
                    "amount": "amount",
                    "denom": "denom"
                  }
                ],
                "tipper": "tipper"
              }
            }
          },
          "txResponse": {
            "code": 6,
            "data": "data",
            "tx": {
              "@type": "@type"
            },
            "rawLog": "rawLog",
            "txhash": "txhash",
            "gasWanted": 5,
            "gasUsed": 5,
            "codespace": "codespace",
            "logs": [
              {
                "log": "log",
                "msgIndex": 1,
                "events": [
                  {
                    "attributes": [
                      {
                        "value": "value",
                        "key": "key"
                      },
                      {
                        "value": "value",
                        "key": "key"
                      }
                    ],
                    "type": "type"
                  },
                  {
                    "attributes": [
                      {
                        "value": "value",
                        "key": "key"
                      },
                      {
                        "value": "value",
                        "key": "key"
                      }
                    ],
                    "type": "type"
                  }
                ]
              },
              {
                "log": "log",
                "msgIndex": 1,
                "events": [
                  {
                    "attributes": [
                      {
                        "value": "value",
                        "key": "key"
                      },
                      {
                        "value": "value",
                        "key": "key"
                      }
                    ],
                    "type": "type"
                  },
                  {
                    "attributes": [
                      {
                        "value": "value",
                        "key": "key"
                      },
                      {
                        "value": "value",
                        "key": "key"
                      }
                    ],
                    "type": "type"
                  }
                ]
              }
            ],
            "events": [
              {
                "attributes": [
                  {
                    "index": true,
                    "value": "value",
                    "key": "key"
                  },
                  {
                    "index": true,
                    "value": "value",
                    "key": "key"
                  }
                ],
                "type": "type"
              },
              {
                "attributes": [
                  {
                    "index": true,
                    "value": "value",
                    "key": "key"
                  },
                  {
                    "index": true,
                    "value": "value",
                    "key": "key"
                  }
                ],
                "type": "type"
              }
            ],
            "height": 0,
            "info": "info",
            "timestamp": "timestamp"
          }
        },
        "properties": {
          "tx": {
            "$ref": "#/components/schemas/Tx"
          },
          "txResponse": {
            "$ref": "#/components/schemas/TxResponse"
          }
        },
        "type": "object"
      },
      "GetTxsEventResponse": {
        "description": "GetTxsEventResponse is the response type for the Service.TxsByEvents RPC method.",
        "example": {
          "total": 2,
          "pagination": {
            "total": 0,
            "nextKey": "nextKey"
          },
          "txResponses": [
            {
              "code": 6,
              "data": "data",
              "tx": {
                "@type": "@type"
              },
              "rawLog": "rawLog",
              "txhash": "txhash",
              "gasWanted": 5,
              "gasUsed": 5,
              "codespace": "codespace",
              "logs": [
                {
                  "log": "log",
                  "msgIndex": 1,
                  "events": [
                    {
                      "attributes": [
                        {
                          "value": "value",
                          "key": "key"
                        },
                        {
                          "value": "value",
                          "key": "key"
                        }
                      ],
                      "type": "type"
                    },
                    {
                      "attributes": [
                        {
                          "value": "value",
                          "key": "key"
                        },
                        {
                          "value": "value",
                          "key": "key"
                        }
                      ],
                      "type": "type"
                    }
                  ]
                },
                {
                  "log": "log",
                  "msgIndex": 1,
                  "events": [
                    {
                      "attributes": [
                        {
                          "value": "value",
                          "key": "key"
                        },
                        {
                          "value": "value",
                          "key": "key"
                        }
                      ],
                      "type": "type"
                    },
                    {
                      "attributes": [
                        {
                          "value": "value",
                          "key": "key"
                        },
                        {
                          "value": "value",
                          "key": "key"
                        }
                      ],
                      "type": "type"
                    }
                  ]
                }
              ],
              "events": [
                {
                  "attributes": [
                    {
                      "index": true,
                      "value": "value",
                      "key": "key"
                    },
                    {
                      "index": true,
                      "value": "value",
                      "key": "key"
                    }
                  ],
                  "type": "type"
                },
                {
                  "attributes": [
                    {
                      "index": true,
                      "value": "value",
                      "key": "key"
                    },
                    {
                      "index": true,
                      "value": "value",
                      "key": "key"
                    }
                  ],
                  "type": "type"
                }
              ],
              "height": 0,
              "info": "info",
              "timestamp": "timestamp"
            },
            {
              "code": 6,
              "data": "data",
              "tx": {
                "@type": "@type"
              },
              "rawLog": "rawLog",
              "txhash": "txhash",
              "gasWanted": 5,
              "gasUsed": 5,
              "codespace": "codespace",
              "logs": [
                {
                  "log": "log",
                  "msgIndex": 1,
                  "events": [
                    {
                      "attributes": [
                        {
                          "value": "value",
                          "key": "key"
                        },
                        {
                          "value": "value",
                          "key": "key"
                        }
                      ],
                      "type": "type"
                    },
                    {
                      "attributes": [
                        {
                          "value": "value",
                          "key": "key"
                        },
                        {
                          "value": "value",
                          "key": "key"
                        }
                      ],
                      "type": "type"
                    }
                  ]
                },
                {
                  "log": "log",
                  "msgIndex": 1,
                  "events": [
                    {
                      "attributes": [
                        {
                          "value": "value",
                          "key": "key"
                        },
                        {
                          "value": "value",
                          "key": "key"
                        }
                      ],
                      "type": "type"
                    },
                    {
                      "attributes": [
                        {
                          "value": "value",
                          "key": "key"
                        },
                        {
                          "value": "value",
                          "key": "key"
                        }
                      ],
                      "type": "type"
                    }
                  ]
                }
              ],
              "events": [
                {
                  "attributes": [
                    {
                      "index": true,
                      "value": "value",
                      "key": "key"
                    },
                    {
                      "index": true,
                      "value": "value",
                      "key": "key"
                    }
                  ],
                  "type": "type"
                },
                {
                  "attributes": [
                    {
                      "index": true,
                      "value": "value",
                      "key": "key"
                    },
                    {
                      "index": true,
                      "value": "value",
                      "key": "key"
                    }
                  ],
                  "type": "type"
                }
              ],
              "height": 0,
              "info": "info",
              "timestamp": "timestamp"
            }
          ],
          "txs": [
            {
              "body": {
                "timeoutHeight": 0,
                "messages": [
                  {
                    "@type": "@type"
                  },
                  {
                    "@type": "@type"
                  }
                ],
                "memo": "memo",
                "extensionOptions": [
                  {
                    "@type": "@type"
                  },
                  {
                    "@type": "@type"
                  }
                ],
                "nonCriticalExtensionOptions": [
                  {
                    "@type": "@type"
                  },
                  {
                    "@type": "@type"
                  }
                ]
              },
              "signatures": ["signatures", "signatures"],
              "authInfo": {
                "signerInfos": [
                  {
                    "sequence": 5,
                    "publicKey": {
                      "@type": "@type"
                    },
                    "modeInfo": {
                      "single": {
                        "mode": 6
                      },
                      "multi": {
                        "modeInfos": [null, null],
                        "bitarray": {
                          "extraBitsStored": 1,
                          "elems": "elems"
                        }
                      }
                    }
                  },
                  {
                    "sequence": 5,
                    "publicKey": {
                      "@type": "@type"
                    },
                    "modeInfo": {
                      "single": {
                        "mode": 6
                      },
                      "multi": {
                        "modeInfos": [null, null],
                        "bitarray": {
                          "extraBitsStored": 1,
                          "elems": "elems"
                        }
                      }
                    }
                  }
                ],
                "fee": {
                  "gasLimit": 5,
                  "amount": [
                    {
                      "amount": "amount",
                      "denom": "denom"
                    },
                    {
                      "amount": "amount",
                      "denom": "denom"
                    }
                  ],
                  "payer": "payer",
                  "granter": "granter"
                },
                "tip": {
                  "amount": [
                    {
                      "amount": "amount",
                      "denom": "denom"
                    },
                    {
                      "amount": "amount",
                      "denom": "denom"
                    }
                  ],
                  "tipper": "tipper"
                }
              }
            },
            {
              "body": {
                "timeoutHeight": 0,
                "messages": [
                  {
                    "@type": "@type"
                  },
                  {
                    "@type": "@type"
                  }
                ],
                "memo": "memo",
                "extensionOptions": [
                  {
                    "@type": "@type"
                  },
                  {
                    "@type": "@type"
                  }
                ],
                "nonCriticalExtensionOptions": [
                  {
                    "@type": "@type"
                  },
                  {
                    "@type": "@type"
                  }
                ]
              },
              "signatures": ["signatures", "signatures"],
              "authInfo": {
                "signerInfos": [
                  {
                    "sequence": 5,
                    "publicKey": {
                      "@type": "@type"
                    },
                    "modeInfo": {
                      "single": {
                        "mode": 6
                      },
                      "multi": {
                        "modeInfos": [null, null],
                        "bitarray": {
                          "extraBitsStored": 1,
                          "elems": "elems"
                        }
                      }
                    }
                  },
                  {
                    "sequence": 5,
                    "publicKey": {
                      "@type": "@type"
                    },
                    "modeInfo": {
                      "single": {
                        "mode": 6
                      },
                      "multi": {
                        "modeInfos": [null, null],
                        "bitarray": {
                          "extraBitsStored": 1,
                          "elems": "elems"
                        }
                      }
                    }
                  }
                ],
                "fee": {
                  "gasLimit": 5,
                  "amount": [
                    {
                      "amount": "amount",
                      "denom": "denom"
                    },
                    {
                      "amount": "amount",
                      "denom": "denom"
                    }
                  ],
                  "payer": "payer",
                  "granter": "granter"
                },
                "tip": {
                  "amount": [
                    {
                      "amount": "amount",
                      "denom": "denom"
                    },
                    {
                      "amount": "amount",
                      "denom": "denom"
                    }
                  ],
                  "tipper": "tipper"
                }
              }
            }
          ]
        },
        "properties": {
          "txs": {
            "description": "txs is the list of queried transactions.",
            "items": {
              "$ref": "#/components/schemas/Tx"
            },
            "type": "array"
          },
          "txResponses": {
            "description": "tx_responses is the list of queried TxResponses.",
            "items": {
              "$ref": "#/components/schemas/TxResponse"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PageResponse"
          },
          "total": {
            "description": "total is total number of results available",
            "format": "uint64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "ModeInfo": {
        "description": "ModeInfo describes the signing mode of a single or nested multisig signer.",
        "example": {
          "single": {
            "mode": 6
          },
          "multi": {
            "modeInfos": [null, null],
            "bitarray": {
              "extraBitsStored": 1,
              "elems": "elems"
            }
          }
        },
        "properties": {
          "single": {
            "$ref": "#/components/schemas/ModeInfo_Single"
          },
          "multi": {
            "$ref": "#/components/schemas/ModeInfo_Multi"
          }
        },
        "type": "object"
      },
      "ModeInfo_Multi": {
        "description": "Multi is the mode info for a multisig public key",
        "example": {
          "modeInfos": [null, null],
          "bitarray": {
            "extraBitsStored": 1,
            "elems": "elems"
          }
        },
        "properties": {
          "bitarray": {
            "$ref": "#/components/schemas/CompactBitArray"
          },
          "modeInfos": {
            "description": "mode_infos is the corresponding modes of the signers of the multisig which could include nested multisig public keys",
            "items": {
              "$ref": "#/components/schemas/ModeInfo"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "ModeInfo_Single": {
        "description": "Single is the mode info for a single signer. It is structured as a message to allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the future",
        "example": {
          "mode": 6
        },
        "properties": {
          "mode": {
            "description": "mode is the signing mode of the single signer",
            "format": "enum",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "Result": {
        "description": "Result is the union of ResponseFormat and ResponseCheckTx.",
        "example": {
          "data": "data",
          "log": "log",
          "msgResponses": [
            {
              "@type": "@type"
            },
            {
              "@type": "@type"
            }
          ],
          "events": [
            {
              "attributes": [
                {
                  "index": true,
                  "value": "value",
                  "key": "key"
                },
                {
                  "index": true,
                  "value": "value",
                  "key": "key"
                }
              ],
              "type": "type"
            },
            {
              "attributes": [
                {
                  "index": true,
                  "value": "value",
                  "key": "key"
                },
                {
                  "index": true,
                  "value": "value",
                  "key": "key"
                }
              ],
              "type": "type"
            }
          ]
        },
        "properties": {
          "data": {
            "description": "Data is any data returned from message or handler execution. It MUST be length prefixed in order to separate data from multiple message executions. Deprecated. This field is still populated, but prefer msg_response instead because it also contains the Msg response typeURL.",
            "format": "bytes",
            "type": "string"
          },
          "log": {
            "description": "Log contains the log information from message or handler execution.",
            "type": "string"
          },
          "events": {
            "description": "Events contains a slice of Event objects that were emitted during message or handler execution.",
            "items": {
              "$ref": "#/components/schemas/Event"
            },
            "type": "array"
          },
          "msgResponses": {
            "description": "msg_responses contains the Msg handler responses type packed in Anys. Since: cosmos-sdk 0.46",
            "items": {
              "$ref": "#/components/schemas/GoogleProtobufAny"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "SignerInfo": {
        "description": "SignerInfo describes the public key and signing mode of a single top-level signer.",
        "example": {
          "sequence": 5,
          "publicKey": {
            "@type": "@type"
          },
          "modeInfo": {
            "single": {
              "mode": 6
            },
            "multi": {
              "modeInfos": [null, null],
              "bitarray": {
                "extraBitsStored": 1,
                "elems": "elems"
              }
            }
          }
        },
        "properties": {
          "publicKey": {
            "$ref": "#/components/schemas/GoogleProtobufAny"
          },
          "modeInfo": {
            "$ref": "#/components/schemas/ModeInfo"
          },
          "sequence": {
            "description": "sequence is the sequence of the account, which describes the number of committed transactions signed by a given address. It is used to prevent replay attacks.",
            "format": "uint64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "SimulateRequest": {
        "description": "SimulateRequest is the request type for the Service.Simulate RPC method.",
        "example": {
          "tx": {
            "body": {
              "timeoutHeight": 0,
              "messages": [
                {
                  "@type": "@type"
                },
                {
                  "@type": "@type"
                }
              ],
              "memo": "memo",
              "extensionOptions": [
                {
                  "@type": "@type"
                },
                {
                  "@type": "@type"
                }
              ],
              "nonCriticalExtensionOptions": [
                {
                  "@type": "@type"
                },
                {
                  "@type": "@type"
                }
              ]
            },
            "signatures": ["signatures", "signatures"],
            "authInfo": {
              "signerInfos": [
                {
                  "sequence": 5,
                  "publicKey": {
                    "@type": "@type"
                  },
                  "modeInfo": {
                    "single": {
                      "mode": 6
                    },
                    "multi": {
                      "modeInfos": [null, null],
                      "bitarray": {
                        "extraBitsStored": 1,
                        "elems": "elems"
                      }
                    }
                  }
                },
                {
                  "sequence": 5,
                  "publicKey": {
                    "@type": "@type"
                  },
                  "modeInfo": {
                    "single": {
                      "mode": 6
                    },
                    "multi": {
                      "modeInfos": [null, null],
                      "bitarray": {
                        "extraBitsStored": 1,
                        "elems": "elems"
                      }
                    }
                  }
                }
              ],
              "fee": {
                "gasLimit": 5,
                "amount": [
                  {
                    "amount": "amount",
                    "denom": "denom"
                  },
                  {
                    "amount": "amount",
                    "denom": "denom"
                  }
                ],
                "payer": "payer",
                "granter": "granter"
              },
              "tip": {
                "amount": [
                  {
                    "amount": "amount",
                    "denom": "denom"
                  },
                  {
                    "amount": "amount",
                    "denom": "denom"
                  }
                ],
                "tipper": "tipper"
              }
            }
          },
          "txBytes": "txBytes"
        },
        "properties": {
          "tx": {
            "$ref": "#/components/schemas/Tx"
          },
          "txBytes": {
            "description": "tx_bytes is the raw transaction. Since: cosmos-sdk 0.43",
            "format": "bytes",
            "type": "string"
          }
        },
        "type": "object"
      },
      "SimulateResponse": {
        "description": "SimulateResponse is the response type for the Service.SimulateRPC method.",
        "example": {
          "result": {
            "data": "data",
            "log": "log",
            "msgResponses": [
              {
                "@type": "@type"
              },
              {
                "@type": "@type"
              }
            ],
            "events": [
              {
                "attributes": [
                  {
                    "index": true,
                    "value": "value",
                    "key": "key"
                  },
                  {
                    "index": true,
                    "value": "value",
                    "key": "key"
                  }
                ],
                "type": "type"
              },
              {
                "attributes": [
                  {
                    "index": true,
                    "value": "value",
                    "key": "key"
                  },
                  {
                    "index": true,
                    "value": "value",
                    "key": "key"
                  }
                ],
                "type": "type"
              }
            ]
          },
          "gasInfo": {
            "gasUsed": 6,
            "gasWanted": 0
          }
        },
        "properties": {
          "gasInfo": {
            "$ref": "#/components/schemas/GasInfo"
          },
          "result": {
            "$ref": "#/components/schemas/Result"
          }
        },
        "type": "object"
      },
      "StringEvent": {
        "description": "StringEvent defines en Event object wrapper where all the attributes contain key/value pairs that are strings instead of raw bytes.",
        "example": {
          "attributes": [
            {
              "value": "value",
              "key": "key"
            },
            {
              "value": "value",
              "key": "key"
            }
          ],
          "type": "type"
        },
        "properties": {
          "type": {
            "type": "string"
          },
          "attributes": {
            "items": {
              "$ref": "#/components/schemas/Attribute"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "Tip": {
        "description": "Tip is the tip used for meta-transactions. Since: cosmos-sdk 0.46",
        "example": {
          "amount": [
            {
              "amount": "amount",
              "denom": "denom"
            },
            {
              "amount": "amount",
              "denom": "denom"
            }
          ],
          "tipper": "tipper"
        },
        "properties": {
          "amount": {
            "description": "amount is the amount of the tip",
            "items": {
              "$ref": "#/components/schemas/Coin"
            },
            "type": "array"
          },
          "tipper": {
            "description": "tipper is the address of the account paying for the tip",
            "type": "string"
          }
        },
        "type": "object"
      },
      "Tx": {
        "description": "Tx is the standard type used for broadcasting transactions.",
        "example": {
          "body": {
            "timeoutHeight": 0,
            "messages": [
              {
                "@type": "@type"
              },
              {
                "@type": "@type"
              }
            ],
            "memo": "memo",
            "extensionOptions": [
              {
                "@type": "@type"
              },
              {
                "@type": "@type"
              }
            ],
            "nonCriticalExtensionOptions": [
              {
                "@type": "@type"
              },
              {
                "@type": "@type"
              }
            ]
          },
          "signatures": ["signatures", "signatures"],
          "authInfo": {
            "signerInfos": [
              {
                "sequence": 5,
                "publicKey": {
                  "@type": "@type"
                },
                "modeInfo": {
                  "single": {
                    "mode": 6
                  },
                  "multi": {
                    "modeInfos": [null, null],
                    "bitarray": {
                      "extraBitsStored": 1,
                      "elems": "elems"
                    }
                  }
                }
              },
              {
                "sequence": 5,
                "publicKey": {
                  "@type": "@type"
                },
                "modeInfo": {
                  "single": {
                    "mode": 6
                  },
                  "multi": {
                    "modeInfos": [null, null],
                    "bitarray": {
                      "extraBitsStored": 1,
                      "elems": "elems"
                    }
                  }
                }
              }
            ],
            "fee": {
              "gasLimit": 5,
              "amount": [
                {
                  "amount": "amount",
                  "denom": "denom"
                },
                {
                  "amount": "amount",
                  "denom": "denom"
                }
              ],
              "payer": "payer",
              "granter": "granter"
            },
            "tip": {
              "amount": [
                {
                  "amount": "amount",
                  "denom": "denom"
                },
                {
                  "amount": "amount",
                  "denom": "denom"
                }
              ],
              "tipper": "tipper"
            }
          }
        },
        "properties": {
          "body": {
            "$ref": "#/components/schemas/TxBody"
          },
          "authInfo": {
            "$ref": "#/components/schemas/AuthInfo"
          },
          "signatures": {
            "description": "signatures is a list of signatures that matches the length and order of AuthInfo's signer_infos to allow connecting signature meta information like public key and signing mode by position.",
            "items": {
              "format": "bytes",
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "TxBody": {
        "description": "TxBody is the body of a transaction that all signers sign over.",
        "example": {
          "timeoutHeight": 0,
          "messages": [
            {
              "@type": "@type"
            },
            {
              "@type": "@type"
            }
          ],
          "memo": "memo",
          "extensionOptions": [
            {
              "@type": "@type"
            },
            {
              "@type": "@type"
            }
          ],
          "nonCriticalExtensionOptions": [
            {
              "@type": "@type"
            },
            {
              "@type": "@type"
            }
          ]
        },
        "properties": {
          "messages": {
            "description": "messages is a list of messages to be executed. The required signers of those messages define the number and order of elements in AuthInfo's signer_infos and Tx's signatures. Each required signer address is added to the list only the first time it occurs. By convention, the first required signer (usually from the first message) is referred to as the primary signer and pays the fee for the whole transaction.",
            "items": {
              "$ref": "#/components/schemas/GoogleProtobufAny"
            },
            "type": "array"
          },
          "memo": {
            "description": "memo is any arbitrary note/comment to be added to the transaction. WARNING: in clients, any publicly exposed text should not be called memo, but should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122).",
            "type": "string"
          },
          "timeoutHeight": {
            "description": "timeout is the block height after which this transaction will not be processed by the chain",
            "format": "uint64",
            "type": "integer"
          },
          "extensionOptions": {
            "description": "extension_options are arbitrary options that can be added by chains when the default options are not sufficient. If any of these are present and can't be handled, the transaction will be rejected",
            "items": {
              "$ref": "#/components/schemas/GoogleProtobufAny"
            },
            "type": "array"
          },
          "nonCriticalExtensionOptions": {
            "description": "extension_options are arbitrary options that can be added by chains when the default options are not sufficient. If any of these are present and can't be handled, they will be ignored",
            "items": {
              "$ref": "#/components/schemas/GoogleProtobufAny"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "TxDecodeAminoRequest": {
        "description": "TxDecodeAminoRequest is the request type for the Service.TxDecodeAmino RPC method. Since: cosmos-sdk 0.47",
        "example": {
          "aminoBinary": "aminoBinary"
        },
        "properties": {
          "aminoBinary": {
            "format": "bytes",
            "type": "string"
          }
        },
        "type": "object"
      },
      "TxDecodeAminoResponse": {
        "description": "TxDecodeAminoResponse is the response type for the Service.TxDecodeAmino RPC method. Since: cosmos-sdk 0.47",
        "example": {
          "aminoJson": "aminoJson"
        },
        "properties": {
          "aminoJson": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "TxDecodeRequest": {
        "description": "TxDecodeRequest is the request type for the Service.TxDecode RPC method. Since: cosmos-sdk 0.47",
        "example": {
          "txBytes": "txBytes"
        },
        "properties": {
          "txBytes": {
            "description": "tx_bytes is the raw transaction.",
            "format": "bytes",
            "type": "string"
          }
        },
        "type": "object"
      },
      "TxDecodeResponse": {
        "description": "TxDecodeResponse is the response type for the Service.TxDecode method. Since: cosmos-sdk 0.47",
        "example": {
          "tx": {
            "body": {
              "timeoutHeight": 0,
              "messages": [
                {
                  "@type": "@type"
                },
                {
                  "@type": "@type"
                }
              ],
              "memo": "memo",
              "extensionOptions": [
                {
                  "@type": "@type"
                },
                {
                  "@type": "@type"
                }
              ],
              "nonCriticalExtensionOptions": [
                {
                  "@type": "@type"
                },
                {
                  "@type": "@type"
                }
              ]
            },
            "signatures": ["signatures", "signatures"],
            "authInfo": {
              "signerInfos": [
                {
                  "sequence": 5,
                  "publicKey": {
                    "@type": "@type"
                  },
                  "modeInfo": {
                    "single": {
                      "mode": 6
                    },
                    "multi": {
                      "modeInfos": [null, null],
                      "bitarray": {
                        "extraBitsStored": 1,
                        "elems": "elems"
                      }
                    }
                  }
                },
                {
                  "sequence": 5,
                  "publicKey": {
                    "@type": "@type"
                  },
                  "modeInfo": {
                    "single": {
                      "mode": 6
                    },
                    "multi": {
                      "modeInfos": [null, null],
                      "bitarray": {
                        "extraBitsStored": 1,
                        "elems": "elems"
                      }
                    }
                  }
                }
              ],
              "fee": {
                "gasLimit": 5,
                "amount": [
                  {
                    "amount": "amount",
                    "denom": "denom"
                  },
                  {
                    "amount": "amount",
                    "denom": "denom"
                  }
                ],
                "payer": "payer",
                "granter": "granter"
              },
              "tip": {
                "amount": [
                  {
                    "amount": "amount",
                    "denom": "denom"
                  },
                  {
                    "amount": "amount",
                    "denom": "denom"
                  }
                ],
                "tipper": "tipper"
              }
            }
          }
        },
        "properties": {
          "tx": {
            "$ref": "#/components/schemas/Tx"
          }
        },
        "type": "object"
      },
      "TxEncodeAminoRequest": {
        "description": "TxEncodeAminoRequest is the request type for the Service.TxEncodeAmino RPC method. Since: cosmos-sdk 0.47",
        "example": {
          "aminoJson": "aminoJson"
        },
        "properties": {
          "aminoJson": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "TxEncodeAminoResponse": {
        "description": "TxEncodeAminoResponse is the response type for the Service.TxEncodeAmino RPC method. Since: cosmos-sdk 0.47",
        "example": {
          "aminoBinary": "aminoBinary"
        },
        "properties": {
          "aminoBinary": {
            "format": "bytes",
            "type": "string"
          }
        },
        "type": "object"
      },
      "TxEncodeRequest": {
        "description": "TxEncodeRequest is the request type for the Service.TxEncode RPC method. Since: cosmos-sdk 0.47",
        "example": {
          "tx": {
            "body": {
              "timeoutHeight": 0,
              "messages": [
                {
                  "@type": "@type"
                },
                {
                  "@type": "@type"
                }
              ],
              "memo": "memo",
              "extensionOptions": [
                {
                  "@type": "@type"
                },
                {
                  "@type": "@type"
                }
              ],
              "nonCriticalExtensionOptions": [
                {
                  "@type": "@type"
                },
                {
                  "@type": "@type"
                }
              ]
            },
            "signatures": ["signatures", "signatures"],
            "authInfo": {
              "signerInfos": [
                {
                  "sequence": 5,
                  "publicKey": {
                    "@type": "@type"
                  },
                  "modeInfo": {
                    "single": {
                      "mode": 6
                    },
                    "multi": {
                      "modeInfos": [null, null],
                      "bitarray": {
                        "extraBitsStored": 1,
                        "elems": "elems"
                      }
                    }
                  }
                },
                {
                  "sequence": 5,
                  "publicKey": {
                    "@type": "@type"
                  },
                  "modeInfo": {
                    "single": {
                      "mode": 6
                    },
                    "multi": {
                      "modeInfos": [null, null],
                      "bitarray": {
                        "extraBitsStored": 1,
                        "elems": "elems"
                      }
                    }
                  }
                }
              ],
              "fee": {
                "gasLimit": 5,
                "amount": [
                  {
                    "amount": "amount",
                    "denom": "denom"
                  },
                  {
                    "amount": "amount",
                    "denom": "denom"
                  }
                ],
                "payer": "payer",
                "granter": "granter"
              },
              "tip": {
                "amount": [
                  {
                    "amount": "amount",
                    "denom": "denom"
                  },
                  {
                    "amount": "amount",
                    "denom": "denom"
                  }
                ],
                "tipper": "tipper"
              }
            }
          }
        },
        "properties": {
          "tx": {
            "$ref": "#/components/schemas/Tx"
          }
        },
        "type": "object"
      },
      "TxEncodeResponse": {
        "description": "TxEncodeResponse is the response type for the Service.TxEncode method. Since: cosmos-sdk 0.47",
        "example": {
          "txBytes": "txBytes"
        },
        "properties": {
          "txBytes": {
            "description": "tx_bytes is the encoded transaction bytes.",
            "format": "bytes",
            "type": "string"
          }
        },
        "type": "object"
      },
      "TxResponse": {
        "description": "TxResponse defines a structure containing relevant tx data and metadata. The tags are stringified and the log is JSON decoded.",
        "example": {
          "code": 6,
          "data": "data",
          "tx": {
            "@type": "@type"
          },
          "rawLog": "rawLog",
          "txhash": "txhash",
          "gasWanted": 5,
          "gasUsed": 5,
          "codespace": "codespace",
          "logs": [
            {
              "log": "log",
              "msgIndex": 1,
              "events": [
                {
                  "attributes": [
                    {
                      "value": "value",
                      "key": "key"
                    },
                    {
                      "value": "value",
                      "key": "key"
                    }
                  ],
                  "type": "type"
                },
                {
                  "attributes": [
                    {
                      "value": "value",
                      "key": "key"
                    },
                    {
                      "value": "value",
                      "key": "key"
                    }
                  ],
                  "type": "type"
                }
              ]
            },
            {
              "log": "log",
              "msgIndex": 1,
              "events": [
                {
                  "attributes": [
                    {
                      "value": "value",
                      "key": "key"
                    },
                    {
                      "value": "value",
                      "key": "key"
                    }
                  ],
                  "type": "type"
                },
                {
                  "attributes": [
                    {
                      "value": "value",
                      "key": "key"
                    },
                    {
                      "value": "value",
                      "key": "key"
                    }
                  ],
                  "type": "type"
                }
              ]
            }
          ],
          "events": [
            {
              "attributes": [
                {
                  "index": true,
                  "value": "value",
                  "key": "key"
                },
                {
                  "index": true,
                  "value": "value",
                  "key": "key"
                }
              ],
              "type": "type"
            },
            {
              "attributes": [
                {
                  "index": true,
                  "value": "value",
                  "key": "key"
                },
                {
                  "index": true,
                  "value": "value",
                  "key": "key"
                }
              ],
              "type": "type"
            }
          ],
          "height": 0,
          "info": "info",
          "timestamp": "timestamp"
        },
        "properties": {
          "height": {
            "description": "The block height",
            "format": "int64",
            "type": "integer"
          },
          "txhash": {
            "description": "The transaction hash.",
            "type": "string"
          },
          "codespace": {
            "description": "Namespace for the Code",
            "type": "string"
          },
          "code": {
            "description": "Response code.",
            "format": "uint32",
            "type": "integer"
          },
          "data": {
            "description": "Result bytes, if any.",
            "type": "string"
          },
          "rawLog": {
            "description": "The output of the application's logger (raw string). May be non-deterministic.",
            "type": "string"
          },
          "logs": {
            "description": "The output of the application's logger (typed). May be non-deterministic.",
            "items": {
              "$ref": "#/components/schemas/ABCIMessageLog"
            },
            "type": "array"
          },
          "info": {
            "description": "Additional information. May be non-deterministic.",
            "type": "string"
          },
          "gasWanted": {
            "description": "Amount of gas requested for transaction.",
            "format": "int64",
            "type": "integer"
          },
          "gasUsed": {
            "description": "Amount of gas consumed by transaction.",
            "format": "int64",
            "type": "integer"
          },
          "tx": {
            "$ref": "#/components/schemas/GoogleProtobufAny"
          },
          "timestamp": {
            "description": "Time of the previous block. For heights > 1, it's the weighted median of the timestamps of the valid votes in the block.LastCommit. For height == 1, it's genesis time.",
            "type": "string"
          },
          "events": {
            "description": "Events defines all the events emitted by processing a transaction. Note, these events include those emitted by processing all the messages and those emitted from the ante. Whereas Logs contains the events, with additional metadata, emitted only by processing the messages. Since: cosmos-sdk 0.42.11, 0.44.5, 0.45",
            "items": {
              "$ref": "#/components/schemas/Event"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "ModuleVersion": {
        "description": "ModuleVersion specifies a module and its consensus version. Since: cosmos-sdk 0.43",
        "example": {
          "name": "name",
          "version": 0
        },
        "properties": {
          "name": {
            "description": "name of the app module",
            "type": "string"
          },
          "version": {
            "description": "consensus version of the app module",
            "format": "uint64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "Plan": {
        "description": "Plan specifies information about a planned upgrade and when it should occur.",
        "example": {
          "name": "name",
          "time": "2000-01-23T04:56:07.000+00:00",
          "height": 0,
          "info": "info",
          "upgradedClientState": {
            "@type": "@type"
          }
        },
        "properties": {
          "name": {
            "description": "Sets the name for the upgrade. This name will be used by the upgraded version of the software to apply any special \"on-upgrade\" commands during the first BeginBlock method after the upgrade is applied. It is also used to detect whether a software version can handle a given upgrade. If no upgrade handler with this name has been set in the software, it will be assumed that the software is out-of-date when the upgrade Time or Height is reached and the software will exit.",
            "type": "string"
          },
          "time": {
            "description": "Deprecated: Time based upgrades have been deprecated. Time based upgrade logic has been removed from the SDK. If this field is not empty, an error will be thrown.",
            "format": "date-time",
            "type": "string"
          },
          "height": {
            "description": "The height at which the upgrade must be performed.",
            "format": "int64",
            "type": "integer"
          },
          "info": {
            "description": "Any application specific upgrade info to be included on-chain such as a git commit that validators could automatically upgrade to",
            "type": "string"
          },
          "upgradedClientState": {
            "$ref": "#/components/schemas/GoogleProtobufAny"
          }
        },
        "type": "object"
      },
      "QueryAppliedPlanResponse": {
        "description": "QueryAppliedPlanResponse is the response type for the Query/AppliedPlan RPC method.",
        "example": {
          "height": 0
        },
        "properties": {
          "height": {
            "description": "height is the block height at which the plan was applied.",
            "format": "int64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "QueryAuthorityResponse": {
        "description": "QueryAuthorityResponse is the response type for Query/Authority Since: cosmos-sdk 0.46",
        "example": {
          "address": "address"
        },
        "properties": {
          "address": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "QueryCurrentPlanResponse": {
        "description": "QueryCurrentPlanResponse is the response type for the Query/CurrentPlan RPC method.",
        "example": {
          "plan": {
            "name": "name",
            "time": "2000-01-23T04:56:07.000+00:00",
            "height": 0,
            "info": "info",
            "upgradedClientState": {
              "@type": "@type"
            }
          }
        },
        "properties": {
          "plan": {
            "$ref": "#/components/schemas/Plan"
          }
        },
        "type": "object"
      },
      "QueryModuleVersionsResponse": {
        "description": "QueryModuleVersionsResponse is the response type for the Query/ModuleVersions RPC method. Since: cosmos-sdk 0.43",
        "example": {
          "moduleVersions": [
            {
              "name": "name",
              "version": 0
            },
            {
              "name": "name",
              "version": 0
            }
          ]
        },
        "properties": {
          "moduleVersions": {
            "description": "module_versions is a list of module names with their consensus versions.",
            "items": {
              "$ref": "#/components/schemas/ModuleVersion"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "QueryUpgradedConsensusStateResponse": {
        "description": "QueryUpgradedConsensusStateResponse is the response type for the Query/UpgradedConsensusState RPC method.",
        "example": {
          "upgradedConsensusState": "upgradedConsensusState"
        },
        "properties": {
          "upgradedConsensusState": {
            "description": "Since: cosmos-sdk 0.43",
            "format": "bytes",
            "type": "string"
          }
        },
        "type": "object"
      },
      "DenomAuthorityMetadata": {
        "description": "DenomAuthorityMetadata specifies metadata for addresses that have specific capabilities over a token factory denom. Right now there is only one Admin permission, but is planned to be extended to the future.",
        "example": {
          "admin": "admin"
        },
        "properties": {
          "admin": {
            "description": "Can be empty for no admin, or a valid address",
            "type": "string"
          }
        },
        "type": "object"
      },
      "QueryDenomAuthorityMetadataResponse": {
        "description": "QueryDenomAuthorityMetadataResponse defines the response structure for the DenomAuthorityMetadata gRPC query.",
        "example": {
          "authorityMetadata": {
            "admin": "admin"
          }
        },
        "properties": {
          "authorityMetadata": {
            "$ref": "#/components/schemas/DenomAuthorityMetadata"
          }
        },
        "type": "object"
      },
      "QueryDenomsFromCreatorResponse": {
        "description": "QueryDenomsFromCreatorRequest defines the response structure for the DenomsFromCreator gRPC query.",
        "example": {
          "denoms": ["denoms", "denoms"]
        },
        "properties": {
          "denoms": {
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "cosmos.base.query.v1beta1.PageRequest": {
        "description": "message SomeRequest {\n         Foo some_parameter = 1;\n         PageRequest pagination = 2;\n }",
        "properties": {
          "key": {
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string"
          },
          "offset": {
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "format": "uint64",
            "type": "string"
          },
          "limit": {
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "format": "uint64",
            "type": "string"
          },
          "count_total": {
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "type": "boolean"
          },
          "reverse": {
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "type": "boolean"
          }
        },
        "title": "PageRequest is to be embedded in gRPC request messages for efficient\npagination. Ex:",
        "type": "object"
      },
      "cosmos.base.query.v1beta1.PageResponse": {
        "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }",
        "properties": {
          "next_key": {
            "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string"
          },
          "total": {
            "format": "uint64",
            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
            "type": "string"
          }
        },
        "type": "object"
      },
      "cosmos.base.v1beta1.Coin": {
        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
        "properties": {
          "denom": {
            "type": "string"
          },
          "amount": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "google.protobuf.Any": {
        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
        "properties": {
          "type_url": {
            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
            "type": "string"
          },
          "value": {
            "description": "Must be a valid serialized protocol buffer of the above specified type.",
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string"
          }
        },
        "type": "object"
      },
      "grpc.gateway.runtime.Error": {
        "properties": {
          "error": {
            "type": "string"
          },
          "code": {
            "format": "int32",
            "type": "integer"
          },
          "message": {
            "type": "string"
          },
          "details": {
            "items": {
              "$ref": "#/components/schemas/FeeEnabledChannel_default_response_details_inner"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "ibc.applications.transfer.v1.DenomTrace": {
        "description": "DenomTrace contains the base denomination for ICS20 fungible tokens and the\nsource tracing information path.",
        "properties": {
          "path": {
            "description": "path defines the chain of port/channel identifiers used for tracing the\nsource of the fungible token.",
            "type": "string"
          },
          "base_denom": {
            "description": "base denomination of the relayed fungible token.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ibc.applications.transfer.v1.Params": {
        "description": "Params defines the set of IBC transfer parameters.\nNOTE: To prevent a single token from being transferred, set the\nTransfersEnabled parameter to true and then set the bank module's SendEnabled\nparameter for the denomination to false.",
        "properties": {
          "send_enabled": {
            "description": "send_enabled enables or disables all cross-chain token transfers from this\nchain.",
            "type": "boolean"
          },
          "receive_enabled": {
            "description": "receive_enabled enables or disables all cross-chain token transfers to this\nchain.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "ibc.applications.transfer.v1.QueryDenomHashResponse": {
        "description": "QueryDenomHashResponse is the response type for the Query/DenomHash RPC\nmethod.",
        "properties": {
          "hash": {
            "description": "hash (in hex format) of the denomination trace information.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ibc.applications.transfer.v1.QueryDenomTraceResponse": {
        "description": "QueryDenomTraceResponse is the response type for the Query/DenomTrace RPC\nmethod.",
        "properties": {
          "denom_trace": {
            "$ref": "#/components/schemas/DenomTraces_200_response_denom_traces_inner"
          }
        },
        "type": "object"
      },
      "ibc.applications.transfer.v1.QueryDenomTracesResponse": {
        "description": "QueryConnectionsResponse is the response type for the Query/DenomTraces RPC\nmethod.",
        "properties": {
          "denom_traces": {
            "description": "denom_traces returns all denominations trace information.",
            "items": {
              "$ref": "#/components/schemas/DenomTraces_200_response_denom_traces_inner"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/DenomTraces_200_response_pagination"
          }
        },
        "type": "object"
      },
      "ibc.applications.transfer.v1.QueryEscrowAddressResponse": {
        "description": "QueryEscrowAddressResponse is the response type of the EscrowAddress RPC method.",
        "properties": {
          "escrow_address": {
            "title": "the escrow account address",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ibc.applications.transfer.v1.QueryParamsResponse": {
        "description": "QueryParamsResponse is the response type for the Query/Params RPC method.",
        "properties": {
          "params": {
            "$ref": "#/components/schemas/TransferParams_200_response_params"
          }
        },
        "type": "object"
      },
      "ibc.applications.transfer.v1.QueryTotalEscrowForDenomResponse": {
        "description": "QueryTotalEscrowForDenomResponse is the response type for TotalEscrowForDenom RPC method.",
        "properties": {
          "amount": {
            "$ref": "#/components/schemas/TotalEscrowForDenom_200_response_amount"
          }
        },
        "type": "object"
      },
      "ibc.applications.interchain_accounts.controller.v1.Params": {
        "description": "Params defines the set of on-chain interchain accounts parameters.\nThe following parameters may be used to disable the controller submodule.",
        "properties": {
          "controller_enabled": {
            "description": "controller_enabled enables or disables the controller submodule.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "ibc.applications.interchain_accounts.controller.v1.QueryInterchainAccountResponse": {
        "description": "QueryInterchainAccountResponse the response type for the Query/InterchainAccount RPC method.",
        "properties": {
          "address": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "ibc.applications.interchain_accounts.controller.v1.QueryParamsResponse": {
        "description": "QueryParamsResponse is the response type for the Query/Params RPC method.",
        "properties": {
          "params": {
            "$ref": "#/components/schemas/InterchainAccountsControllerParams_200_response_params"
          }
        },
        "type": "object"
      },
      "ibc.applications.interchain_accounts.host.v1.Params": {
        "description": "Params defines the set of on-chain interchain accounts parameters.\nThe following parameters may be used to disable the host submodule.",
        "properties": {
          "host_enabled": {
            "description": "host_enabled enables or disables the host submodule.",
            "type": "boolean"
          },
          "allow_messages": {
            "description": "allow_messages defines a list of sdk message typeURLs allowed to be executed on a host chain.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "ibc.applications.interchain_accounts.host.v1.QueryParamsResponse": {
        "description": "QueryParamsResponse is the response type for the Query/Params RPC method.",
        "properties": {
          "params": {
            "$ref": "#/components/schemas/InterchainAccountsHostParams_200_response_params"
          }
        },
        "type": "object"
      },
      "ibc.applications.fee.v1.Fee": {
        "properties": {
          "recv_fee": {
            "items": {
              "$ref": "#/components/schemas/TotalEscrowForDenom_200_response_amount"
            },
            "title": "the packet receive fee",
            "type": "array"
          },
          "ack_fee": {
            "items": {
              "$ref": "#/components/schemas/TotalEscrowForDenom_200_response_amount"
            },
            "title": "the packet acknowledgement fee",
            "type": "array"
          },
          "timeout_fee": {
            "items": {
              "$ref": "#/components/schemas/TotalEscrowForDenom_200_response_amount"
            },
            "title": "the packet timeout fee",
            "type": "array"
          }
        },
        "title": "Fee defines the ICS29 receive, acknowledgement and timeout fees",
        "type": "object"
      },
      "ibc.applications.fee.v1.FeeEnabledChannel": {
        "properties": {
          "port_id": {
            "title": "unique port identifier",
            "type": "string"
          },
          "channel_id": {
            "title": "unique channel identifier",
            "type": "string"
          }
        },
        "title": "FeeEnabledChannel contains the PortID & ChannelID for a fee enabled channel",
        "type": "object"
      },
      "ibc.applications.fee.v1.IdentifiedPacketFees": {
        "properties": {
          "packet_id": {
            "$ref": "#/components/schemas/unique_packet_identifier_comprised_of_the_channel_ID__port_ID_and_sequence"
          },
          "packet_fees": {
            "items": {
              "$ref": "#/components/schemas/PacketFee_contains_ICS29_relayer_fees__refund_address_and_optional_list_of_permitted_relayers"
            },
            "title": "list of packet fees",
            "type": "array"
          }
        },
        "title": "IdentifiedPacketFees contains a list of type PacketFee and associated PacketId",
        "type": "object"
      },
      "ibc.applications.fee.v1.PacketFee": {
        "properties": {
          "fee": {
            "$ref": "#/components/schemas/fee_encapsulates_the_recv__ack_and_timeout_fees_associated_with_an_IBC_packet"
          },
          "refund_address": {
            "title": "the refund address for unspent fees",
            "type": "string"
          },
          "relayers": {
            "items": {
              "type": "string"
            },
            "title": "optional list of relayers permitted to receive fees",
            "type": "array"
          }
        },
        "title": "PacketFee contains ICS29 relayer fees, refund address and optional list of permitted relayers",
        "type": "object"
      },
      "ibc.applications.fee.v1.QueryCounterpartyPayeeResponse": {
        "properties": {
          "counterparty_payee": {
            "title": "the counterparty payee address used to compensate forward relaying",
            "type": "string"
          }
        },
        "title": "QueryCounterpartyPayeeResponse defines the response type for the CounterpartyPayee rpc",
        "type": "object"
      },
      "ibc.applications.fee.v1.QueryFeeEnabledChannelResponse": {
        "properties": {
          "fee_enabled": {
            "title": "boolean flag representing the fee enabled channel status",
            "type": "boolean"
          }
        },
        "title": "QueryFeeEnabledChannelResponse defines the response type for the FeeEnabledChannel rpc",
        "type": "object"
      },
      "ibc.applications.fee.v1.QueryFeeEnabledChannelsResponse": {
        "properties": {
          "fee_enabled_channels": {
            "items": {
              "$ref": "#/components/schemas/FeeEnabledChannel_contains_the_PortID___ChannelID_for_a_fee_enabled_channel"
            },
            "title": "list of fee enabled channels",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/DenomTraces_200_response_pagination"
          }
        },
        "title": "QueryFeeEnabledChannelsResponse defines the response type for the FeeEnabledChannels rpc",
        "type": "object"
      },
      "ibc.applications.fee.v1.QueryIncentivizedPacketResponse": {
        "properties": {
          "incentivized_packet": {
            "$ref": "#/components/schemas/IdentifiedPacketFees_contains_a_list_of_type_PacketFee_and_associated_PacketId"
          }
        },
        "title": "QueryIncentivizedPacketsResponse defines the response type for the IncentivizedPacket rpc",
        "type": "object"
      },
      "ibc.applications.fee.v1.QueryIncentivizedPacketsForChannelResponse": {
        "properties": {
          "incentivized_packets": {
            "items": {
              "$ref": "#/components/schemas/IdentifiedPacketFees_contains_a_list_of_type_PacketFee_and_associated_PacketId"
            },
            "title": "Map of all incentivized_packets",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/DenomTraces_200_response_pagination"
          }
        },
        "title": "QueryIncentivizedPacketsResponse defines the response type for the incentivized packets RPC",
        "type": "object"
      },
      "ibc.applications.fee.v1.QueryIncentivizedPacketsResponse": {
        "properties": {
          "incentivized_packets": {
            "items": {
              "$ref": "#/components/schemas/IdentifiedPacketFees_contains_a_list_of_type_PacketFee_and_associated_PacketId"
            },
            "title": "list of identified fees for incentivized packets",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/DenomTraces_200_response_pagination"
          }
        },
        "title": "QueryIncentivizedPacketsResponse defines the response type for the IncentivizedPackets rpc",
        "type": "object"
      },
      "ibc.applications.fee.v1.QueryPayeeResponse": {
        "properties": {
          "payee_address": {
            "title": "the payee address to which packet fees are paid out",
            "type": "string"
          }
        },
        "title": "QueryPayeeResponse defines the response type for the Payee rpc",
        "type": "object"
      },
      "ibc.applications.fee.v1.QueryTotalAckFeesResponse": {
        "properties": {
          "ack_fees": {
            "items": {
              "$ref": "#/components/schemas/TotalEscrowForDenom_200_response_amount"
            },
            "title": "the total packet acknowledgement fees",
            "type": "array"
          }
        },
        "title": "QueryTotalAckFeesResponse defines the response type for the TotalAckFees rpc",
        "type": "object"
      },
      "ibc.applications.fee.v1.QueryTotalRecvFeesResponse": {
        "properties": {
          "recv_fees": {
            "items": {
              "$ref": "#/components/schemas/TotalEscrowForDenom_200_response_amount"
            },
            "title": "the total packet receive fees",
            "type": "array"
          }
        },
        "title": "QueryTotalRecvFeesResponse defines the response type for the TotalRecvFees rpc",
        "type": "object"
      },
      "ibc.applications.fee.v1.QueryTotalTimeoutFeesResponse": {
        "properties": {
          "timeout_fees": {
            "items": {
              "$ref": "#/components/schemas/TotalEscrowForDenom_200_response_amount"
            },
            "title": "the total packet timeout fees",
            "type": "array"
          }
        },
        "title": "QueryTotalTimeoutFeesResponse defines the response type for the TotalTimeoutFees rpc",
        "type": "object"
      },
      "ibc.core.channel.v1.PacketId": {
        "properties": {
          "port_id": {
            "title": "channel port identifier",
            "type": "string"
          },
          "channel_id": {
            "title": "channel unique identifier",
            "type": "string"
          },
          "sequence": {
            "format": "uint64",
            "title": "packet sequence",
            "type": "string"
          }
        },
        "title": "PacketId is an identifer for a unique Packet\nSource chains refer to packets by source port/channel\nDestination chains refer to packets by destination port/channel",
        "type": "object"
      },
      "ibc.core.client.v1.ConsensusStateWithHeight": {
        "description": "ConsensusStateWithHeight defines a consensus state with an additional height\nfield.",
        "properties": {
          "height": {
            "$ref": "#/components/schemas/consensus_state_height"
          },
          "consensus_state": {
            "$ref": "#/components/schemas/consensus_state"
          }
        },
        "type": "object"
      },
      "ibc.core.client.v1.Height": {
        "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset",
        "properties": {
          "revision_number": {
            "format": "uint64",
            "title": "the revision that the client is currently on",
            "type": "string"
          },
          "revision_height": {
            "format": "uint64",
            "title": "the height within the given revision",
            "type": "string"
          }
        },
        "title": "Height is a monotonically increasing data type\nthat can be compared against another Height for the purposes of updating and\nfreezing clients",
        "type": "object"
      },
      "ibc.core.client.v1.IdentifiedClientState": {
        "description": "IdentifiedClientState defines a client state with an additional client\nidentifier field.",
        "properties": {
          "client_id": {
            "title": "client identifier",
            "type": "string"
          },
          "client_state": {
            "$ref": "#/components/schemas/client_state"
          }
        },
        "type": "object"
      },
      "ibc.core.client.v1.Params": {
        "description": "Params defines the set of IBC light client parameters.",
        "properties": {
          "allowed_clients": {
            "description": "allowed_clients defines the list of allowed client state types which can be created\nand interacted with. If a client type is removed from the allowed clients list, usage\nof this client will be disabled until it is added again to the list.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "ibc.core.client.v1.QueryClientParamsResponse": {
        "description": "QueryClientParamsResponse is the response type for the Query/ClientParams RPC\nmethod.",
        "properties": {
          "params": {
            "$ref": "#/components/schemas/ClientParams_200_response_params"
          }
        },
        "type": "object"
      },
      "ibc.core.client.v1.QueryClientStateResponse": {
        "description": "QueryClientStateResponse is the response type for the Query/ClientState RPC\nmethod. Besides the client state, it includes a proof and the height from\nwhich the proof was retrieved.",
        "properties": {
          "client_state": {
            "$ref": "#/components/schemas/client_state_associated_with_the_request_identifier"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/height_at_which_the_proof_was_retrieved"
          }
        },
        "type": "object"
      },
      "ibc.core.client.v1.QueryClientStatesResponse": {
        "description": "QueryClientStatesResponse is the response type for the Query/ClientStates RPC\nmethod.",
        "properties": {
          "client_states": {
            "description": "list of stored ClientStates of the chain.",
            "items": {
              "$ref": "#/components/schemas/ClientStates_200_response_client_states_inner"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/pagination_response"
          }
        },
        "type": "object"
      },
      "ibc.core.client.v1.QueryClientStatusResponse": {
        "description": "QueryClientStatusResponse is the response type for the Query/ClientStatus RPC\nmethod. It returns the current status of the IBC client.",
        "properties": {
          "status": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "ibc.core.client.v1.QueryConsensusStateHeightsResponse": {
        "properties": {
          "consensus_state_heights": {
            "items": {
              "$ref": "#/components/schemas/Height_is_a_monotonically_increasing_data_type_that_can_be_compared_against_another_Height_for_the_purposes_of_updating_and_freezing_clients"
            },
            "title": "consensus state heights",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/pagination_response"
          }
        },
        "title": "QueryConsensusStateHeightsResponse is the response type for the\nQuery/ConsensusStateHeights RPC method",
        "type": "object"
      },
      "ibc.core.client.v1.QueryConsensusStateResponse": {
        "properties": {
          "consensus_state": {
            "$ref": "#/components/schemas/consensus_state_associated_with_the_client_identifier_at_the_given_height"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/Height_is_a_monotonically_increasing_data_type_that_can_be_compared_against_another_Height_for_the_purposes_of_updating_and_freezing_clients"
          }
        },
        "title": "QueryConsensusStateResponse is the response type for the Query/ConsensusState\nRPC method",
        "type": "object"
      },
      "ibc.core.client.v1.QueryConsensusStatesResponse": {
        "properties": {
          "consensus_states": {
            "items": {
              "$ref": "#/components/schemas/consensus_states_associated_with_the_identifier_inner"
            },
            "title": "consensus states associated with the identifier",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/pagination_response"
          }
        },
        "title": "QueryConsensusStatesResponse is the response type for the\nQuery/ConsensusStates RPC method",
        "type": "object"
      },
      "ibc.core.client.v1.QueryUpgradedClientStateResponse": {
        "description": "QueryUpgradedClientStateResponse is the response type for the\nQuery/UpgradedClientState RPC method.",
        "properties": {
          "upgraded_client_state": {
            "$ref": "#/components/schemas/client_state_associated_with_the_request_identifier"
          }
        },
        "type": "object"
      },
      "ibc.core.client.v1.QueryUpgradedConsensusStateResponse": {
        "description": "QueryUpgradedConsensusStateResponse is the response type for the\nQuery/UpgradedConsensusState RPC method.",
        "properties": {
          "upgraded_consensus_state": {
            "$ref": "#/components/schemas/Consensus_state_associated_with_the_request_identifier"
          }
        },
        "type": "object"
      },
      "ibc.core.commitment.v1.MerklePrefix": {
        "properties": {
          "key_prefix": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string"
          }
        },
        "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath,\nappend(Path.KeyPrefix, key...))",
        "type": "object"
      },
      "ibc.core.connection.v1.ConnectionEnd": {
        "description": "ConnectionEnd defines a stateful object on a chain connected to another\nseparate one.\nNOTE: there must only be 2 defined ConnectionEnds to establish\na connection between two chains.",
        "properties": {
          "client_id": {
            "description": "client associated with this connection.",
            "type": "string"
          },
          "versions": {
            "description": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection.",
            "items": {
              "$ref": "#/components/schemas/IBC_version_which_can_be_utilised_to_determine_encodings_or_protocols_for_channels_or_packets_utilising_this_connection_inner"
            },
            "type": "array"
          },
          "state": {
            "default": "STATE_UNINITIALIZED_UNSPECIFIED",
            "description": "current state of the connection end.",
            "enum": [
              "STATE_UNINITIALIZED_UNSPECIFIED",
              "STATE_INIT",
              "STATE_TRYOPEN",
              "STATE_OPEN"
            ],
            "type": "string"
          },
          "counterparty": {
            "$ref": "#/components/schemas/Connections_200_response_connections_inner_counterparty"
          },
          "delay_period": {
            "description": "delay period that must pass before a consensus state can be used for\npacket-verification NOTE: delay period logic is only implemented by some\nclients.",
            "format": "uint64",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ibc.core.connection.v1.Counterparty": {
        "description": "Counterparty defines the counterparty chain associated with a connection end.",
        "properties": {
          "client_id": {
            "description": "identifies the client on the counterparty chain associated with a given\nconnection.",
            "type": "string"
          },
          "connection_id": {
            "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection.",
            "type": "string"
          },
          "prefix": {
            "$ref": "#/components/schemas/MerklePrefix_is_merkle_path_prefixed_to_the_key__The_constructed_key_from_the_Path_and_the_key_will_be_append_Path_KeyPath__append_Path_KeyPrefix__key_____"
          }
        },
        "type": "object"
      },
      "ibc.core.connection.v1.IdentifiedConnection": {
        "description": "IdentifiedConnection defines a connection with additional connection\nidentifier field.",
        "properties": {
          "id": {
            "description": "connection identifier.",
            "type": "string"
          },
          "client_id": {
            "description": "client associated with this connection.",
            "type": "string"
          },
          "versions": {
            "items": {
              "$ref": "#/components/schemas/IBC_version_which_can_be_utilised_to_determine_encodings_or_protocols_for_channels_or_packets_utilising_this_connection_inner"
            },
            "title": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection",
            "type": "array"
          },
          "state": {
            "default": "STATE_UNINITIALIZED_UNSPECIFIED",
            "description": "current state of the connection end.",
            "enum": [
              "STATE_UNINITIALIZED_UNSPECIFIED",
              "STATE_INIT",
              "STATE_TRYOPEN",
              "STATE_OPEN"
            ],
            "type": "string"
          },
          "counterparty": {
            "$ref": "#/components/schemas/Connections_200_response_connections_inner_counterparty"
          },
          "delay_period": {
            "description": "delay period associated with this connection.",
            "format": "uint64",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ibc.core.connection.v1.Params": {
        "description": "Params defines the set of Connection parameters.",
        "properties": {
          "max_expected_time_per_block": {
            "description": "maximum expected time per block (in nanoseconds), used to enforce block delay. This parameter should reflect the\nlargest amount of time that the chain might reasonably take to produce the next block under normal operating\nconditions. A safe choice is 3-5x the expected time per block.",
            "format": "uint64",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ibc.core.connection.v1.QueryClientConnectionsResponse": {
        "properties": {
          "connection_paths": {
            "description": "slice of all the connection paths associated with a client.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/height_at_which_the_proof_was_generated"
          }
        },
        "title": "QueryClientConnectionsResponse is the response type for the\nQuery/ClientConnections RPC method",
        "type": "object"
      },
      "ibc.core.connection.v1.QueryConnectionClientStateResponse": {
        "properties": {
          "identified_client_state": {
            "$ref": "#/components/schemas/client_state_associated_with_the_channel"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/height_at_which_the_proof_was_retrieved"
          }
        },
        "title": "QueryConnectionClientStateResponse is the response type for the\nQuery/ConnectionClientState RPC method",
        "type": "object"
      },
      "ibc.core.connection.v1.QueryConnectionConsensusStateResponse": {
        "properties": {
          "consensus_state": {
            "$ref": "#/components/schemas/consensus_state_associated_with_the_channel"
          },
          "client_id": {
            "title": "client ID associated with the consensus state",
            "type": "string"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/height_at_which_the_proof_was_retrieved"
          }
        },
        "title": "QueryConnectionConsensusStateResponse is the response type for the\nQuery/ConnectionConsensusState RPC method",
        "type": "object"
      },
      "ibc.core.connection.v1.QueryConnectionParamsResponse": {
        "description": "QueryConnectionParamsResponse is the response type for the Query/ConnectionParams RPC method.",
        "properties": {
          "params": {
            "$ref": "#/components/schemas/ConnectionParams_200_response_params"
          }
        },
        "type": "object"
      },
      "ibc.core.connection.v1.QueryConnectionResponse": {
        "description": "QueryConnectionResponse is the response type for the Query/Connection RPC\nmethod. Besides the connection end, it includes a proof and the height from\nwhich the proof was retrieved.",
        "properties": {
          "connection": {
            "$ref": "#/components/schemas/connection_associated_with_the_request_identifier"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/height_at_which_the_proof_was_retrieved"
          }
        },
        "type": "object"
      },
      "ibc.core.connection.v1.QueryConnectionsResponse": {
        "description": "QueryConnectionsResponse is the response type for the Query/Connections RPC\nmethod.",
        "properties": {
          "connections": {
            "description": "list of stored connections of the chain.",
            "items": {
              "$ref": "#/components/schemas/Connections_200_response_connections_inner"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/pagination_response"
          },
          "height": {
            "$ref": "#/components/schemas/query_block_height"
          }
        },
        "type": "object"
      },
      "ibc.core.connection.v1.State": {
        "default": "STATE_UNINITIALIZED_UNSPECIFIED",
        "description": "State defines if a connection is in one of the following states:\nINIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A connection end has just started the opening handshake.\n - STATE_TRYOPEN: A connection end has acknowledged the handshake step on the counterparty\nchain.\n - STATE_OPEN: A connection end has completed the handshake.",
        "enum": ["STATE_UNINITIALIZED_UNSPECIFIED", "STATE_INIT", "STATE_TRYOPEN", "STATE_OPEN"],
        "type": "string"
      },
      "ibc.core.connection.v1.Version": {
        "description": "Version defines the versioning scheme used to negotiate the IBC verison in\nthe connection handshake.",
        "properties": {
          "identifier": {
            "title": "unique version identifier",
            "type": "string"
          },
          "features": {
            "items": {
              "type": "string"
            },
            "title": "list of features compatible with the specified identifier",
            "type": "array"
          }
        },
        "type": "object"
      },
      "ibc.core.channel.v1.Channel": {
        "description": "Channel defines pipeline for exactly-once packet delivery between specific\nmodules on separate blockchains, which has at least one end capable of\nsending packets and one end capable of receiving packets.",
        "properties": {
          "state": {
            "default": "STATE_UNINITIALIZED_UNSPECIFIED",
            "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets.",
            "enum": [
              "STATE_UNINITIALIZED_UNSPECIFIED",
              "STATE_INIT",
              "STATE_TRYOPEN",
              "STATE_OPEN",
              "STATE_CLOSED"
            ],
            "title": "current state of the channel end",
            "type": "string"
          },
          "ordering": {
            "default": "ORDER_NONE_UNSPECIFIED",
            "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent",
            "enum": ["ORDER_NONE_UNSPECIFIED", "ORDER_UNORDERED", "ORDER_ORDERED"],
            "title": "whether the channel is ordered or unordered",
            "type": "string"
          },
          "counterparty": {
            "$ref": "#/components/schemas/counterparty_channel_end"
          },
          "connection_hops": {
            "items": {
              "type": "string"
            },
            "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel",
            "type": "array"
          },
          "version": {
            "title": "opaque channel version, which is agreed upon during the handshake",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ibc.core.channel.v1.Counterparty": {
        "properties": {
          "port_id": {
            "description": "port on the counterparty chain which owns the other end of the channel.",
            "type": "string"
          },
          "channel_id": {
            "title": "channel end on the counterparty chain",
            "type": "string"
          }
        },
        "title": "Counterparty defines a channel end counterparty",
        "type": "object"
      },
      "ibc.core.channel.v1.IdentifiedChannel": {
        "description": "IdentifiedChannel defines a channel with additional port and channel\nidentifier fields.",
        "properties": {
          "state": {
            "default": "STATE_UNINITIALIZED_UNSPECIFIED",
            "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets.",
            "enum": [
              "STATE_UNINITIALIZED_UNSPECIFIED",
              "STATE_INIT",
              "STATE_TRYOPEN",
              "STATE_OPEN",
              "STATE_CLOSED"
            ],
            "title": "current state of the channel end",
            "type": "string"
          },
          "ordering": {
            "default": "ORDER_NONE_UNSPECIFIED",
            "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent",
            "enum": ["ORDER_NONE_UNSPECIFIED", "ORDER_UNORDERED", "ORDER_ORDERED"],
            "title": "whether the channel is ordered or unordered",
            "type": "string"
          },
          "counterparty": {
            "$ref": "#/components/schemas/counterparty_channel_end"
          },
          "connection_hops": {
            "items": {
              "type": "string"
            },
            "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel",
            "type": "array"
          },
          "version": {
            "title": "opaque channel version, which is agreed upon during the handshake",
            "type": "string"
          },
          "port_id": {
            "title": "port identifier",
            "type": "string"
          },
          "channel_id": {
            "title": "channel identifier",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ibc.core.channel.v1.Order": {
        "default": "ORDER_NONE_UNSPECIFIED",
        "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent",
        "enum": ["ORDER_NONE_UNSPECIFIED", "ORDER_UNORDERED", "ORDER_ORDERED"],
        "title": "Order defines if a channel is ORDERED or UNORDERED",
        "type": "string"
      },
      "ibc.core.channel.v1.PacketState": {
        "description": "PacketState defines the generic type necessary to retrieve and store\npacket commitments, acknowledgements, and receipts.\nCaller is responsible for knowing the context necessary to interpret this\nstate as a commitment, acknowledgement, or a receipt.",
        "properties": {
          "port_id": {
            "description": "channel port identifier.",
            "type": "string"
          },
          "channel_id": {
            "description": "channel unique identifier.",
            "type": "string"
          },
          "sequence": {
            "description": "packet sequence.",
            "format": "uint64",
            "type": "string"
          },
          "data": {
            "description": "embedded data that represents packet state.",
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ibc.core.channel.v1.QueryChannelClientStateResponse": {
        "properties": {
          "identified_client_state": {
            "$ref": "#/components/schemas/client_state_associated_with_the_channel"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/height_at_which_the_proof_was_retrieved"
          }
        },
        "title": "QueryChannelClientStateResponse is the Response type for the\nQuery/QueryChannelClientState RPC method",
        "type": "object"
      },
      "ibc.core.channel.v1.QueryChannelConsensusStateResponse": {
        "properties": {
          "consensus_state": {
            "$ref": "#/components/schemas/consensus_state_associated_with_the_channel"
          },
          "client_id": {
            "title": "client ID associated with the consensus state",
            "type": "string"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/height_at_which_the_proof_was_retrieved"
          }
        },
        "title": "QueryChannelClientStateResponse is the Response type for the\nQuery/QueryChannelClientState RPC method",
        "type": "object"
      },
      "ibc.core.channel.v1.QueryChannelResponse": {
        "description": "QueryChannelResponse is the response type for the Query/Channel RPC method.\nBesides the Channel end, it includes a proof and the height from which the\nproof was retrieved.",
        "properties": {
          "channel": {
            "$ref": "#/components/schemas/channel_associated_with_the_request_identifiers"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/height_at_which_the_proof_was_retrieved"
          }
        },
        "type": "object"
      },
      "ibc.core.channel.v1.QueryChannelsResponse": {
        "description": "QueryChannelsResponse is the response type for the Query/Channels RPC method.",
        "properties": {
          "channels": {
            "description": "list of stored channels of the chain.",
            "items": {
              "$ref": "#/components/schemas/Channels_200_response_channels_inner"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/pagination_response"
          },
          "height": {
            "$ref": "#/components/schemas/query_block_height"
          }
        },
        "type": "object"
      },
      "ibc.core.channel.v1.QueryConnectionChannelsResponse": {
        "properties": {
          "channels": {
            "description": "list of channels associated with a connection.",
            "items": {
              "$ref": "#/components/schemas/Channels_200_response_channels_inner"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/pagination_response"
          },
          "height": {
            "$ref": "#/components/schemas/query_block_height"
          }
        },
        "title": "QueryConnectionChannelsResponse is the Response type for the\nQuery/QueryConnectionChannels RPC method",
        "type": "object"
      },
      "ibc.core.channel.v1.QueryNextSequenceReceiveResponse": {
        "properties": {
          "next_sequence_receive": {
            "format": "uint64",
            "title": "next sequence receive number",
            "type": "string"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/height_at_which_the_proof_was_retrieved"
          }
        },
        "title": "QuerySequenceResponse is the request type for the\nQuery/QueryNextSequenceReceiveResponse RPC method",
        "type": "object"
      },
      "ibc.core.channel.v1.QueryNextSequenceSendResponse": {
        "properties": {
          "next_sequence_send": {
            "format": "uint64",
            "title": "next sequence send number",
            "type": "string"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/height_at_which_the_proof_was_retrieved"
          }
        },
        "title": "QueryNextSequenceSendResponse is the request type for the\nQuery/QueryNextSequenceSend RPC method",
        "type": "object"
      },
      "ibc.core.channel.v1.QueryPacketAcknowledgementResponse": {
        "properties": {
          "acknowledgement": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "packet associated with the request fields",
            "type": "string"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/height_at_which_the_proof_was_retrieved"
          }
        },
        "title": "QueryPacketAcknowledgementResponse defines the client query response for a\npacket which also includes a proof and the height from which the\nproof was retrieved",
        "type": "object"
      },
      "ibc.core.channel.v1.QueryPacketAcknowledgementsResponse": {
        "properties": {
          "acknowledgements": {
            "items": {
              "$ref": "#/components/schemas/QueryPacketAcknowledgemetsResponse_is_the_request_type_for_the_Query_QueryPacketAcknowledgements_RPC_method_acknowledgements_inner"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/pagination_response"
          },
          "height": {
            "$ref": "#/components/schemas/query_block_height"
          }
        },
        "title": "QueryPacketAcknowledgemetsResponse is the request type for the\nQuery/QueryPacketAcknowledgements RPC method",
        "type": "object"
      },
      "ibc.core.channel.v1.QueryPacketCommitmentResponse": {
        "properties": {
          "commitment": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "packet associated with the request fields",
            "type": "string"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/height_at_which_the_proof_was_retrieved"
          }
        },
        "title": "QueryPacketCommitmentResponse defines the client query response for a packet\nwhich also includes a proof and the height from which the proof was\nretrieved",
        "type": "object"
      },
      "ibc.core.channel.v1.QueryPacketCommitmentsResponse": {
        "properties": {
          "commitments": {
            "items": {
              "$ref": "#/components/schemas/QueryPacketAcknowledgemetsResponse_is_the_request_type_for_the_Query_QueryPacketAcknowledgements_RPC_method_acknowledgements_inner"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/pagination_response"
          },
          "height": {
            "$ref": "#/components/schemas/query_block_height"
          }
        },
        "title": "QueryPacketCommitmentsResponse is the request type for the\nQuery/QueryPacketCommitments RPC method",
        "type": "object"
      },
      "ibc.core.channel.v1.QueryPacketReceiptResponse": {
        "properties": {
          "received": {
            "title": "success flag for if receipt exists",
            "type": "boolean"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/height_at_which_the_proof_was_retrieved"
          }
        },
        "title": "QueryPacketReceiptResponse defines the client query response for a packet\nreceipt which also includes a proof, and the height from which the proof was\nretrieved",
        "type": "object"
      },
      "ibc.core.channel.v1.QueryUnreceivedAcksResponse": {
        "properties": {
          "sequences": {
            "items": {
              "format": "uint64",
              "type": "string"
            },
            "title": "list of unreceived acknowledgement sequences",
            "type": "array"
          },
          "height": {
            "$ref": "#/components/schemas/query_block_height"
          }
        },
        "title": "QueryUnreceivedAcksResponse is the response type for the\nQuery/UnreceivedAcks RPC method",
        "type": "object"
      },
      "ibc.core.channel.v1.QueryUnreceivedPacketsResponse": {
        "properties": {
          "sequences": {
            "items": {
              "format": "uint64",
              "type": "string"
            },
            "title": "list of unreceived packet sequences",
            "type": "array"
          },
          "height": {
            "$ref": "#/components/schemas/query_block_height"
          }
        },
        "title": "QueryUnreceivedPacketsResponse is the response type for the\nQuery/UnreceivedPacketCommitments RPC method",
        "type": "object"
      },
      "ibc.core.channel.v1.State": {
        "default": "STATE_UNINITIALIZED_UNSPECIFIED",
        "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets.",
        "enum": [
          "STATE_UNINITIALIZED_UNSPECIFIED",
          "STATE_INIT",
          "STATE_TRYOPEN",
          "STATE_OPEN",
          "STATE_CLOSED"
        ],
        "type": "string"
      },
      "ibc.lightclients.wasm.v1.QueryCodeHashesResponse": {
        "description": "QueryCodeHashesResponse is the response type for the Query/CodeHashes RPC method.",
        "properties": {
          "code_hashes": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/CodeHashes_200_response_pagination"
          }
        },
        "type": "object"
      },
      "ibc.lightclients.wasm.v1.QueryCodeResponse": {
        "description": "QueryCodeResponse is the response type for the Query/Code RPC method.",
        "properties": {
          "data": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string"
          }
        },
        "type": "object"
      },
      "EscrowAddress_200_response": {
        "description": "QueryEscrowAddressResponse is the response type of the EscrowAddress RPC method.",
        "example": {
          "escrow_address": "escrow_address"
        },
        "properties": {
          "escrow_address": {
            "title": "the escrow account address",
            "type": "string"
          }
        },
        "type": "object"
      },
      "EscrowAddress_default_response_details_inner": {
        "example": {
          "value": "value",
          "type_url": "type_url"
        },
        "properties": {
          "type_url": {
            "type": "string"
          },
          "value": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string"
          }
        },
        "type": "object"
      },
      "EscrowAddress_default_response": {
        "example": {
          "code": 0,
          "details": [
            {
              "value": "value",
              "type_url": "type_url"
            },
            {
              "value": "value",
              "type_url": "type_url"
            }
          ],
          "error": "error",
          "message": "message"
        },
        "properties": {
          "error": {
            "type": "string"
          },
          "code": {
            "format": "int32",
            "type": "integer"
          },
          "message": {
            "type": "string"
          },
          "details": {
            "items": {
              "$ref": "#/components/schemas/EscrowAddress_default_response_details_inner"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "DenomHash_200_response": {
        "description": "QueryDenomHashResponse is the response type for the Query/DenomHash RPC\nmethod.",
        "example": {
          "hash": "hash"
        },
        "properties": {
          "hash": {
            "description": "hash (in hex format) of the denomination trace information.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "DenomTraces_200_response_denom_traces_inner": {
        "description": "DenomTrace contains the base denomination for ICS20 fungible tokens and the\nsource tracing information path.",
        "example": {
          "path": "path",
          "base_denom": "base_denom"
        },
        "properties": {
          "path": {
            "description": "path defines the chain of port/channel identifiers used for tracing the\nsource of the fungible token.",
            "type": "string"
          },
          "base_denom": {
            "description": "base denomination of the relayed fungible token.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "DenomTraces_200_response_pagination": {
        "description": "pagination defines the pagination in the response.",
        "example": {
          "total": "total",
          "next_key": "next_key"
        },
        "properties": {
          "next_key": {
            "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string"
          },
          "total": {
            "format": "uint64",
            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
            "type": "string"
          }
        },
        "type": "object"
      },
      "DenomTraces_200_response": {
        "description": "QueryConnectionsResponse is the response type for the Query/DenomTraces RPC\nmethod.",
        "example": {
          "denom_traces": [
            {
              "path": "path",
              "base_denom": "base_denom"
            },
            {
              "path": "path",
              "base_denom": "base_denom"
            }
          ],
          "pagination": {
            "total": "total",
            "next_key": "next_key"
          }
        },
        "properties": {
          "denom_traces": {
            "description": "denom_traces returns all denominations trace information.",
            "items": {
              "$ref": "#/components/schemas/DenomTraces_200_response_denom_traces_inner"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/DenomTraces_200_response_pagination"
          }
        },
        "type": "object"
      },
      "DenomTrace_200_response": {
        "description": "QueryDenomTraceResponse is the response type for the Query/DenomTrace RPC\nmethod.",
        "example": {
          "denom_trace": {
            "path": "path",
            "base_denom": "base_denom"
          }
        },
        "properties": {
          "denom_trace": {
            "$ref": "#/components/schemas/DenomTraces_200_response_denom_traces_inner"
          }
        },
        "type": "object"
      },
      "TotalEscrowForDenom_200_response_amount": {
        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
        "example": {
          "amount": "amount",
          "denom": "denom"
        },
        "properties": {
          "denom": {
            "type": "string"
          },
          "amount": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "TotalEscrowForDenom_200_response": {
        "description": "QueryTotalEscrowForDenomResponse is the response type for TotalEscrowForDenom RPC method.",
        "example": {
          "amount": {
            "amount": "amount",
            "denom": "denom"
          }
        },
        "properties": {
          "amount": {
            "$ref": "#/components/schemas/TotalEscrowForDenom_200_response_amount"
          }
        },
        "type": "object"
      },
      "TransferParams_200_response_params": {
        "description": "params defines the parameters of the module.",
        "example": {
          "send_enabled": true,
          "receive_enabled": true
        },
        "properties": {
          "send_enabled": {
            "description": "send_enabled enables or disables all cross-chain token transfers from this\nchain.",
            "type": "boolean"
          },
          "receive_enabled": {
            "description": "receive_enabled enables or disables all cross-chain token transfers to this\nchain.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "TransferParams_200_response": {
        "description": "QueryParamsResponse is the response type for the Query/Params RPC method.",
        "example": {
          "params": {
            "send_enabled": true,
            "receive_enabled": true
          }
        },
        "properties": {
          "params": {
            "$ref": "#/components/schemas/TransferParams_200_response_params"
          }
        },
        "type": "object"
      },
      "InterchainAccount_200_response": {
        "description": "QueryInterchainAccountResponse the response type for the Query/InterchainAccount RPC method.",
        "example": {
          "address": "address"
        },
        "properties": {
          "address": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "InterchainAccountsControllerParams_200_response_params": {
        "description": "params defines the parameters of the module.",
        "example": {
          "controller_enabled": true
        },
        "properties": {
          "controller_enabled": {
            "description": "controller_enabled enables or disables the controller submodule.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "InterchainAccountsControllerParams_200_response": {
        "description": "QueryParamsResponse is the response type for the Query/Params RPC method.",
        "example": {
          "params": {
            "controller_enabled": true
          }
        },
        "properties": {
          "params": {
            "$ref": "#/components/schemas/InterchainAccountsControllerParams_200_response_params"
          }
        },
        "type": "object"
      },
      "InterchainAccountsHostParams_200_response_params": {
        "description": "params defines the parameters of the module.",
        "example": {
          "host_enabled": true,
          "allow_messages": ["allow_messages", "allow_messages"]
        },
        "properties": {
          "host_enabled": {
            "description": "host_enabled enables or disables the host submodule.",
            "type": "boolean"
          },
          "allow_messages": {
            "description": "allow_messages defines a list of sdk message typeURLs allowed to be executed on a host chain.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "InterchainAccountsHostParams_200_response": {
        "description": "QueryParamsResponse is the response type for the Query/Params RPC method.",
        "example": {
          "params": {
            "host_enabled": true,
            "allow_messages": ["allow_messages", "allow_messages"]
          }
        },
        "properties": {
          "params": {
            "$ref": "#/components/schemas/InterchainAccountsHostParams_200_response_params"
          }
        },
        "type": "object"
      },
      "QueryFeeEnabledChannelResponse_defines_the_response_type_for_the_FeeEnabledChannel_rpc": {
        "example": {
          "fee_enabled": true
        },
        "properties": {
          "fee_enabled": {
            "title": "boolean flag representing the fee enabled channel status",
            "type": "boolean"
          }
        },
        "title": "QueryFeeEnabledChannelResponse defines the response type for the FeeEnabledChannel rpc",
        "type": "object"
      },
      "FeeEnabledChannel_default_response_details_inner": {
        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
        "example": {
          "value": "value",
          "type_url": "type_url"
        },
        "properties": {
          "type_url": {
            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
            "type": "string"
          },
          "value": {
            "description": "Must be a valid serialized protocol buffer of the above specified type.",
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string"
          }
        },
        "type": "object"
      },
      "FeeEnabledChannel_default_response": {
        "example": {
          "code": 0,
          "details": [
            {
              "value": "value",
              "type_url": "type_url"
            },
            {
              "value": "value",
              "type_url": "type_url"
            }
          ],
          "error": "error",
          "message": "message"
        },
        "properties": {
          "error": {
            "type": "string"
          },
          "code": {
            "format": "int32",
            "type": "integer"
          },
          "message": {
            "type": "string"
          },
          "details": {
            "items": {
              "$ref": "#/components/schemas/FeeEnabledChannel_default_response_details_inner"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "unique_packet_identifier_comprised_of_the_channel_ID__port_ID_and_sequence": {
        "example": {
          "sequence": "sequence",
          "port_id": "port_id",
          "channel_id": "channel_id"
        },
        "properties": {
          "port_id": {
            "title": "channel port identifier",
            "type": "string"
          },
          "channel_id": {
            "title": "channel unique identifier",
            "type": "string"
          },
          "sequence": {
            "format": "uint64",
            "title": "packet sequence",
            "type": "string"
          }
        },
        "title": "unique packet identifier comprised of the channel ID, port ID and sequence",
        "type": "object"
      },
      "fee_encapsulates_the_recv__ack_and_timeout_fees_associated_with_an_IBC_packet": {
        "example": {
          "recv_fee": [
            {
              "amount": "amount",
              "denom": "denom"
            },
            {
              "amount": "amount",
              "denom": "denom"
            }
          ],
          "ack_fee": [
            {
              "amount": "amount",
              "denom": "denom"
            },
            {
              "amount": "amount",
              "denom": "denom"
            }
          ],
          "timeout_fee": [
            {
              "amount": "amount",
              "denom": "denom"
            },
            {
              "amount": "amount",
              "denom": "denom"
            }
          ]
        },
        "properties": {
          "recv_fee": {
            "items": {
              "$ref": "#/components/schemas/TotalEscrowForDenom_200_response_amount"
            },
            "title": "the packet receive fee",
            "type": "array"
          },
          "ack_fee": {
            "items": {
              "$ref": "#/components/schemas/TotalEscrowForDenom_200_response_amount"
            },
            "title": "the packet acknowledgement fee",
            "type": "array"
          },
          "timeout_fee": {
            "items": {
              "$ref": "#/components/schemas/TotalEscrowForDenom_200_response_amount"
            },
            "title": "the packet timeout fee",
            "type": "array"
          }
        },
        "title": "fee encapsulates the recv, ack and timeout fees associated with an IBC packet",
        "type": "object"
      },
      "PacketFee_contains_ICS29_relayer_fees__refund_address_and_optional_list_of_permitted_relayers": {
        "example": {
          "relayers": ["relayers", "relayers"],
          "fee": {
            "recv_fee": [
              {
                "amount": "amount",
                "denom": "denom"
              },
              {
                "amount": "amount",
                "denom": "denom"
              }
            ],
            "ack_fee": [
              {
                "amount": "amount",
                "denom": "denom"
              },
              {
                "amount": "amount",
                "denom": "denom"
              }
            ],
            "timeout_fee": [
              {
                "amount": "amount",
                "denom": "denom"
              },
              {
                "amount": "amount",
                "denom": "denom"
              }
            ]
          },
          "refund_address": "refund_address"
        },
        "properties": {
          "fee": {
            "$ref": "#/components/schemas/fee_encapsulates_the_recv__ack_and_timeout_fees_associated_with_an_IBC_packet"
          },
          "refund_address": {
            "title": "the refund address for unspent fees",
            "type": "string"
          },
          "relayers": {
            "items": {
              "type": "string"
            },
            "title": "optional list of relayers permitted to receive fees",
            "type": "array"
          }
        },
        "title": "PacketFee contains ICS29 relayer fees, refund address and optional list of permitted relayers",
        "type": "object"
      },
      "IdentifiedPacketFees_contains_a_list_of_type_PacketFee_and_associated_PacketId": {
        "example": {
          "packet_id": {
            "sequence": "sequence",
            "port_id": "port_id",
            "channel_id": "channel_id"
          },
          "packet_fees": [
            {
              "relayers": ["relayers", "relayers"],
              "fee": {
                "recv_fee": [
                  {
                    "amount": "amount",
                    "denom": "denom"
                  },
                  {
                    "amount": "amount",
                    "denom": "denom"
                  }
                ],
                "ack_fee": [
                  {
                    "amount": "amount",
                    "denom": "denom"
                  },
                  {
                    "amount": "amount",
                    "denom": "denom"
                  }
                ],
                "timeout_fee": [
                  {
                    "amount": "amount",
                    "denom": "denom"
                  },
                  {
                    "amount": "amount",
                    "denom": "denom"
                  }
                ]
              },
              "refund_address": "refund_address"
            },
            {
              "relayers": ["relayers", "relayers"],
              "fee": {
                "recv_fee": [
                  {
                    "amount": "amount",
                    "denom": "denom"
                  },
                  {
                    "amount": "amount",
                    "denom": "denom"
                  }
                ],
                "ack_fee": [
                  {
                    "amount": "amount",
                    "denom": "denom"
                  },
                  {
                    "amount": "amount",
                    "denom": "denom"
                  }
                ],
                "timeout_fee": [
                  {
                    "amount": "amount",
                    "denom": "denom"
                  },
                  {
                    "amount": "amount",
                    "denom": "denom"
                  }
                ]
              },
              "refund_address": "refund_address"
            }
          ]
        },
        "properties": {
          "packet_id": {
            "$ref": "#/components/schemas/unique_packet_identifier_comprised_of_the_channel_ID__port_ID_and_sequence"
          },
          "packet_fees": {
            "items": {
              "$ref": "#/components/schemas/PacketFee_contains_ICS29_relayer_fees__refund_address_and_optional_list_of_permitted_relayers"
            },
            "title": "list of packet fees",
            "type": "array"
          }
        },
        "title": "IdentifiedPacketFees contains a list of type PacketFee and associated PacketId",
        "type": "object"
      },
      "QueryIncentivizedPacketsResponse_defines_the_response_type_for_the_incentivized_packets_RPC": {
        "example": {
          "pagination": {
            "total": "total",
            "next_key": "next_key"
          },
          "incentivized_packets": [
            {
              "packet_id": {
                "sequence": "sequence",
                "port_id": "port_id",
                "channel_id": "channel_id"
              },
              "packet_fees": [
                {
                  "relayers": ["relayers", "relayers"],
                  "fee": {
                    "recv_fee": [
                      {
                        "amount": "amount",
                        "denom": "denom"
                      },
                      {
                        "amount": "amount",
                        "denom": "denom"
                      }
                    ],
                    "ack_fee": [
                      {
                        "amount": "amount",
                        "denom": "denom"
                      },
                      {
                        "amount": "amount",
                        "denom": "denom"
                      }
                    ],
                    "timeout_fee": [
                      {
                        "amount": "amount",
                        "denom": "denom"
                      },
                      {
                        "amount": "amount",
                        "denom": "denom"
                      }
                    ]
                  },
                  "refund_address": "refund_address"
                },
                {
                  "relayers": ["relayers", "relayers"],
                  "fee": {
                    "recv_fee": [
                      {
                        "amount": "amount",
                        "denom": "denom"
                      },
                      {
                        "amount": "amount",
                        "denom": "denom"
                      }
                    ],
                    "ack_fee": [
                      {
                        "amount": "amount",
                        "denom": "denom"
                      },
                      {
                        "amount": "amount",
                        "denom": "denom"
                      }
                    ],
                    "timeout_fee": [
                      {
                        "amount": "amount",
                        "denom": "denom"
                      },
                      {
                        "amount": "amount",
                        "denom": "denom"
                      }
                    ]
                  },
                  "refund_address": "refund_address"
                }
              ]
            },
            {
              "packet_id": {
                "sequence": "sequence",
                "port_id": "port_id",
                "channel_id": "channel_id"
              },
              "packet_fees": [
                {
                  "relayers": ["relayers", "relayers"],
                  "fee": {
                    "recv_fee": [
                      {
                        "amount": "amount",
                        "denom": "denom"
                      },
                      {
                        "amount": "amount",
                        "denom": "denom"
                      }
                    ],
                    "ack_fee": [
                      {
                        "amount": "amount",
                        "denom": "denom"
                      },
                      {
                        "amount": "amount",
                        "denom": "denom"
                      }
                    ],
                    "timeout_fee": [
                      {
                        "amount": "amount",
                        "denom": "denom"
                      },
                      {
                        "amount": "amount",
                        "denom": "denom"
                      }
                    ]
                  },
                  "refund_address": "refund_address"
                },
                {
                  "relayers": ["relayers", "relayers"],
                  "fee": {
                    "recv_fee": [
                      {
                        "amount": "amount",
                        "denom": "denom"
                      },
                      {
                        "amount": "amount",
                        "denom": "denom"
                      }
                    ],
                    "ack_fee": [
                      {
                        "amount": "amount",
                        "denom": "denom"
                      },
                      {
                        "amount": "amount",
                        "denom": "denom"
                      }
                    ],
                    "timeout_fee": [
                      {
                        "amount": "amount",
                        "denom": "denom"
                      },
                      {
                        "amount": "amount",
                        "denom": "denom"
                      }
                    ]
                  },
                  "refund_address": "refund_address"
                }
              ]
            }
          ]
        },
        "properties": {
          "incentivized_packets": {
            "items": {
              "$ref": "#/components/schemas/IdentifiedPacketFees_contains_a_list_of_type_PacketFee_and_associated_PacketId"
            },
            "title": "Map of all incentivized_packets",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/DenomTraces_200_response_pagination"
          }
        },
        "title": "QueryIncentivizedPacketsResponse defines the response type for the incentivized packets RPC",
        "type": "object"
      },
      "QueryCounterpartyPayeeResponse_defines_the_response_type_for_the_CounterpartyPayee_rpc": {
        "example": {
          "counterparty_payee": "counterparty_payee"
        },
        "properties": {
          "counterparty_payee": {
            "title": "the counterparty payee address used to compensate forward relaying",
            "type": "string"
          }
        },
        "title": "QueryCounterpartyPayeeResponse defines the response type for the CounterpartyPayee rpc",
        "type": "object"
      },
      "QueryPayeeResponse_defines_the_response_type_for_the_Payee_rpc": {
        "example": {
          "payee_address": "payee_address"
        },
        "properties": {
          "payee_address": {
            "title": "the payee address to which packet fees are paid out",
            "type": "string"
          }
        },
        "title": "QueryPayeeResponse defines the response type for the Payee rpc",
        "type": "object"
      },
      "QueryIncentivizedPacketsResponse_defines_the_response_type_for_the_IncentivizedPacket_rpc": {
        "example": {
          "incentivized_packet": {
            "packet_id": {
              "sequence": "sequence",
              "port_id": "port_id",
              "channel_id": "channel_id"
            },
            "packet_fees": [
              {
                "relayers": ["relayers", "relayers"],
                "fee": {
                  "recv_fee": [
                    {
                      "amount": "amount",
                      "denom": "denom"
                    },
                    {
                      "amount": "amount",
                      "denom": "denom"
                    }
                  ],
                  "ack_fee": [
                    {
                      "amount": "amount",
                      "denom": "denom"
                    },
                    {
                      "amount": "amount",
                      "denom": "denom"
                    }
                  ],
                  "timeout_fee": [
                    {
                      "amount": "amount",
                      "denom": "denom"
                    },
                    {
                      "amount": "amount",
                      "denom": "denom"
                    }
                  ]
                },
                "refund_address": "refund_address"
              },
              {
                "relayers": ["relayers", "relayers"],
                "fee": {
                  "recv_fee": [
                    {
                      "amount": "amount",
                      "denom": "denom"
                    },
                    {
                      "amount": "amount",
                      "denom": "denom"
                    }
                  ],
                  "ack_fee": [
                    {
                      "amount": "amount",
                      "denom": "denom"
                    },
                    {
                      "amount": "amount",
                      "denom": "denom"
                    }
                  ],
                  "timeout_fee": [
                    {
                      "amount": "amount",
                      "denom": "denom"
                    },
                    {
                      "amount": "amount",
                      "denom": "denom"
                    }
                  ]
                },
                "refund_address": "refund_address"
              }
            ]
          }
        },
        "properties": {
          "incentivized_packet": {
            "$ref": "#/components/schemas/IdentifiedPacketFees_contains_a_list_of_type_PacketFee_and_associated_PacketId"
          }
        },
        "title": "QueryIncentivizedPacketsResponse defines the response type for the IncentivizedPacket rpc",
        "type": "object"
      },
      "QueryTotalAckFeesResponse_defines_the_response_type_for_the_TotalAckFees_rpc": {
        "example": {
          "ack_fees": [
            {
              "amount": "amount",
              "denom": "denom"
            },
            {
              "amount": "amount",
              "denom": "denom"
            }
          ]
        },
        "properties": {
          "ack_fees": {
            "items": {
              "$ref": "#/components/schemas/TotalEscrowForDenom_200_response_amount"
            },
            "title": "the total packet acknowledgement fees",
            "type": "array"
          }
        },
        "title": "QueryTotalAckFeesResponse defines the response type for the TotalAckFees rpc",
        "type": "object"
      },
      "QueryTotalRecvFeesResponse_defines_the_response_type_for_the_TotalRecvFees_rpc": {
        "example": {
          "recv_fees": [
            {
              "amount": "amount",
              "denom": "denom"
            },
            {
              "amount": "amount",
              "denom": "denom"
            }
          ]
        },
        "properties": {
          "recv_fees": {
            "items": {
              "$ref": "#/components/schemas/TotalEscrowForDenom_200_response_amount"
            },
            "title": "the total packet receive fees",
            "type": "array"
          }
        },
        "title": "QueryTotalRecvFeesResponse defines the response type for the TotalRecvFees rpc",
        "type": "object"
      },
      "QueryTotalTimeoutFeesResponse_defines_the_response_type_for_the_TotalTimeoutFees_rpc": {
        "example": {
          "timeout_fees": [
            {
              "amount": "amount",
              "denom": "denom"
            },
            {
              "amount": "amount",
              "denom": "denom"
            }
          ]
        },
        "properties": {
          "timeout_fees": {
            "items": {
              "$ref": "#/components/schemas/TotalEscrowForDenom_200_response_amount"
            },
            "title": "the total packet timeout fees",
            "type": "array"
          }
        },
        "title": "QueryTotalTimeoutFeesResponse defines the response type for the TotalTimeoutFees rpc",
        "type": "object"
      },
      "FeeEnabledChannel_contains_the_PortID___ChannelID_for_a_fee_enabled_channel": {
        "example": {
          "port_id": "port_id",
          "channel_id": "channel_id"
        },
        "properties": {
          "port_id": {
            "title": "unique port identifier",
            "type": "string"
          },
          "channel_id": {
            "title": "unique channel identifier",
            "type": "string"
          }
        },
        "title": "FeeEnabledChannel contains the PortID & ChannelID for a fee enabled channel",
        "type": "object"
      },
      "QueryFeeEnabledChannelsResponse_defines_the_response_type_for_the_FeeEnabledChannels_rpc": {
        "example": {
          "fee_enabled_channels": [
            {
              "port_id": "port_id",
              "channel_id": "channel_id"
            },
            {
              "port_id": "port_id",
              "channel_id": "channel_id"
            }
          ],
          "pagination": {
            "total": "total",
            "next_key": "next_key"
          }
        },
        "properties": {
          "fee_enabled_channels": {
            "items": {
              "$ref": "#/components/schemas/FeeEnabledChannel_contains_the_PortID___ChannelID_for_a_fee_enabled_channel"
            },
            "title": "list of fee enabled channels",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/DenomTraces_200_response_pagination"
          }
        },
        "title": "QueryFeeEnabledChannelsResponse defines the response type for the FeeEnabledChannels rpc",
        "type": "object"
      },
      "QueryIncentivizedPacketsResponse_defines_the_response_type_for_the_IncentivizedPackets_rpc": {
        "example": {
          "pagination": {
            "total": "total",
            "next_key": "next_key"
          },
          "incentivized_packets": [
            {
              "packet_id": {
                "sequence": "sequence",
                "port_id": "port_id",
                "channel_id": "channel_id"
              },
              "packet_fees": [
                {
                  "relayers": ["relayers", "relayers"],
                  "fee": {
                    "recv_fee": [
                      {
                        "amount": "amount",
                        "denom": "denom"
                      },
                      {
                        "amount": "amount",
                        "denom": "denom"
                      }
                    ],
                    "ack_fee": [
                      {
                        "amount": "amount",
                        "denom": "denom"
                      },
                      {
                        "amount": "amount",
                        "denom": "denom"
                      }
                    ],
                    "timeout_fee": [
                      {
                        "amount": "amount",
                        "denom": "denom"
                      },
                      {
                        "amount": "amount",
                        "denom": "denom"
                      }
                    ]
                  },
                  "refund_address": "refund_address"
                },
                {
                  "relayers": ["relayers", "relayers"],
                  "fee": {
                    "recv_fee": [
                      {
                        "amount": "amount",
                        "denom": "denom"
                      },
                      {
                        "amount": "amount",
                        "denom": "denom"
                      }
                    ],
                    "ack_fee": [
                      {
                        "amount": "amount",
                        "denom": "denom"
                      },
                      {
                        "amount": "amount",
                        "denom": "denom"
                      }
                    ],
                    "timeout_fee": [
                      {
                        "amount": "amount",
                        "denom": "denom"
                      },
                      {
                        "amount": "amount",
                        "denom": "denom"
                      }
                    ]
                  },
                  "refund_address": "refund_address"
                }
              ]
            },
            {
              "packet_id": {
                "sequence": "sequence",
                "port_id": "port_id",
                "channel_id": "channel_id"
              },
              "packet_fees": [
                {
                  "relayers": ["relayers", "relayers"],
                  "fee": {
                    "recv_fee": [
                      {
                        "amount": "amount",
                        "denom": "denom"
                      },
                      {
                        "amount": "amount",
                        "denom": "denom"
                      }
                    ],
                    "ack_fee": [
                      {
                        "amount": "amount",
                        "denom": "denom"
                      },
                      {
                        "amount": "amount",
                        "denom": "denom"
                      }
                    ],
                    "timeout_fee": [
                      {
                        "amount": "amount",
                        "denom": "denom"
                      },
                      {
                        "amount": "amount",
                        "denom": "denom"
                      }
                    ]
                  },
                  "refund_address": "refund_address"
                },
                {
                  "relayers": ["relayers", "relayers"],
                  "fee": {
                    "recv_fee": [
                      {
                        "amount": "amount",
                        "denom": "denom"
                      },
                      {
                        "amount": "amount",
                        "denom": "denom"
                      }
                    ],
                    "ack_fee": [
                      {
                        "amount": "amount",
                        "denom": "denom"
                      },
                      {
                        "amount": "amount",
                        "denom": "denom"
                      }
                    ],
                    "timeout_fee": [
                      {
                        "amount": "amount",
                        "denom": "denom"
                      },
                      {
                        "amount": "amount",
                        "denom": "denom"
                      }
                    ]
                  },
                  "refund_address": "refund_address"
                }
              ]
            }
          ]
        },
        "properties": {
          "incentivized_packets": {
            "items": {
              "$ref": "#/components/schemas/IdentifiedPacketFees_contains_a_list_of_type_PacketFee_and_associated_PacketId"
            },
            "title": "list of identified fees for incentivized packets",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/DenomTraces_200_response_pagination"
          }
        },
        "title": "QueryIncentivizedPacketsResponse defines the response type for the IncentivizedPackets rpc",
        "type": "object"
      },
      "client_state": {
        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
        "example": {
          "value": "value",
          "type_url": "type_url"
        },
        "properties": {
          "type_url": {
            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
            "type": "string"
          },
          "value": {
            "description": "Must be a valid serialized protocol buffer of the above specified type.",
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string"
          }
        },
        "title": "client state",
        "type": "object"
      },
      "ClientStates_200_response_client_states_inner": {
        "description": "IdentifiedClientState defines a client state with an additional client\nidentifier field.",
        "example": {
          "client_state": {
            "value": "value",
            "type_url": "type_url"
          },
          "client_id": "client_id"
        },
        "properties": {
          "client_id": {
            "title": "client identifier",
            "type": "string"
          },
          "client_state": {
            "$ref": "#/components/schemas/client_state"
          }
        },
        "type": "object"
      },
      "pagination_response": {
        "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }",
        "example": {
          "total": "total",
          "next_key": "next_key"
        },
        "properties": {
          "next_key": {
            "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string"
          },
          "total": {
            "format": "uint64",
            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
            "type": "string"
          }
        },
        "title": "pagination response",
        "type": "object"
      },
      "ClientStates_200_response": {
        "description": "QueryClientStatesResponse is the response type for the Query/ClientStates RPC\nmethod.",
        "example": {
          "pagination": {
            "total": "total",
            "next_key": "next_key"
          },
          "client_states": [
            {
              "client_state": {
                "value": "value",
                "type_url": "type_url"
              },
              "client_id": "client_id"
            },
            {
              "client_state": {
                "value": "value",
                "type_url": "type_url"
              },
              "client_id": "client_id"
            }
          ]
        },
        "properties": {
          "client_states": {
            "description": "list of stored ClientStates of the chain.",
            "items": {
              "$ref": "#/components/schemas/ClientStates_200_response_client_states_inner"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/pagination_response"
          }
        },
        "type": "object"
      },
      "client_state_associated_with_the_request_identifier": {
        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
        "example": {
          "value": "value",
          "type_url": "type_url"
        },
        "properties": {
          "type_url": {
            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
            "type": "string"
          },
          "value": {
            "description": "Must be a valid serialized protocol buffer of the above specified type.",
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string"
          }
        },
        "title": "client state associated with the request identifier",
        "type": "object"
      },
      "height_at_which_the_proof_was_retrieved": {
        "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset",
        "example": {
          "revision_height": "revision_height",
          "revision_number": "revision_number"
        },
        "properties": {
          "revision_number": {
            "format": "uint64",
            "title": "the revision that the client is currently on",
            "type": "string"
          },
          "revision_height": {
            "format": "uint64",
            "title": "the height within the given revision",
            "type": "string"
          }
        },
        "title": "height at which the proof was retrieved",
        "type": "object"
      },
      "ClientState_200_response": {
        "description": "QueryClientStateResponse is the response type for the Query/ClientState RPC\nmethod. Besides the client state, it includes a proof and the height from\nwhich the proof was retrieved.",
        "example": {
          "client_state": {
            "value": "value",
            "type_url": "type_url"
          },
          "proof_height": {
            "revision_height": "revision_height",
            "revision_number": "revision_number"
          },
          "proof": "proof"
        },
        "properties": {
          "client_state": {
            "$ref": "#/components/schemas/client_state_associated_with_the_request_identifier"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/height_at_which_the_proof_was_retrieved"
          }
        },
        "type": "object"
      },
      "ClientStatus_200_response": {
        "description": "QueryClientStatusResponse is the response type for the Query/ClientStatus RPC\nmethod. It returns the current status of the IBC client.",
        "example": {
          "status": "status"
        },
        "properties": {
          "status": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "consensus_state_height": {
        "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset",
        "example": {
          "revision_height": "revision_height",
          "revision_number": "revision_number"
        },
        "properties": {
          "revision_number": {
            "format": "uint64",
            "title": "the revision that the client is currently on",
            "type": "string"
          },
          "revision_height": {
            "format": "uint64",
            "title": "the height within the given revision",
            "type": "string"
          }
        },
        "title": "consensus state height",
        "type": "object"
      },
      "consensus_state": {
        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
        "example": {
          "value": "value",
          "type_url": "type_url"
        },
        "properties": {
          "type_url": {
            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
            "type": "string"
          },
          "value": {
            "description": "Must be a valid serialized protocol buffer of the above specified type.",
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string"
          }
        },
        "title": "consensus state",
        "type": "object"
      },
      "consensus_states_associated_with_the_identifier_inner": {
        "description": "ConsensusStateWithHeight defines a consensus state with an additional height\nfield.",
        "example": {
          "consensus_state": {
            "value": "value",
            "type_url": "type_url"
          },
          "height": {
            "revision_height": "revision_height",
            "revision_number": "revision_number"
          }
        },
        "properties": {
          "height": {
            "$ref": "#/components/schemas/consensus_state_height"
          },
          "consensus_state": {
            "$ref": "#/components/schemas/consensus_state"
          }
        },
        "type": "object"
      },
      "QueryConsensusStatesResponse_is_the_response_type_for_the_Query_ConsensusStates_RPC_method": {
        "example": {
          "consensus_states": [
            {
              "consensus_state": {
                "value": "value",
                "type_url": "type_url"
              },
              "height": {
                "revision_height": "revision_height",
                "revision_number": "revision_number"
              }
            },
            {
              "consensus_state": {
                "value": "value",
                "type_url": "type_url"
              },
              "height": {
                "revision_height": "revision_height",
                "revision_number": "revision_number"
              }
            }
          ],
          "pagination": {
            "total": "total",
            "next_key": "next_key"
          }
        },
        "properties": {
          "consensus_states": {
            "items": {
              "$ref": "#/components/schemas/consensus_states_associated_with_the_identifier_inner"
            },
            "title": "consensus states associated with the identifier",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/pagination_response"
          }
        },
        "title": "QueryConsensusStatesResponse is the response type for the\nQuery/ConsensusStates RPC method",
        "type": "object"
      },
      "Height_is_a_monotonically_increasing_data_type_that_can_be_compared_against_another_Height_for_the_purposes_of_updating_and_freezing_clients": {
        "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset",
        "example": {
          "revision_height": "revision_height",
          "revision_number": "revision_number"
        },
        "properties": {
          "revision_number": {
            "format": "uint64",
            "title": "the revision that the client is currently on",
            "type": "string"
          },
          "revision_height": {
            "format": "uint64",
            "title": "the height within the given revision",
            "type": "string"
          }
        },
        "title": "Height is a monotonically increasing data type\nthat can be compared against another Height for the purposes of updating and\nfreezing clients",
        "type": "object"
      },
      "QueryConsensusStateHeightsResponse_is_the_response_type_for_the_Query_ConsensusStateHeights_RPC_method": {
        "example": {
          "pagination": {
            "total": "total",
            "next_key": "next_key"
          },
          "consensus_state_heights": [
            {
              "revision_height": "revision_height",
              "revision_number": "revision_number"
            },
            {
              "revision_height": "revision_height",
              "revision_number": "revision_number"
            }
          ]
        },
        "properties": {
          "consensus_state_heights": {
            "items": {
              "$ref": "#/components/schemas/Height_is_a_monotonically_increasing_data_type_that_can_be_compared_against_another_Height_for_the_purposes_of_updating_and_freezing_clients"
            },
            "title": "consensus state heights",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/pagination_response"
          }
        },
        "title": "QueryConsensusStateHeightsResponse is the response type for the\nQuery/ConsensusStateHeights RPC method",
        "type": "object"
      },
      "consensus_state_associated_with_the_client_identifier_at_the_given_height": {
        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
        "example": {
          "value": "value",
          "type_url": "type_url"
        },
        "properties": {
          "type_url": {
            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
            "type": "string"
          },
          "value": {
            "description": "Must be a valid serialized protocol buffer of the above specified type.",
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string"
          }
        },
        "title": "consensus state associated with the client identifier at the given height",
        "type": "object"
      },
      "QueryConsensusStateResponse_is_the_response_type_for_the_Query_ConsensusState_RPC_method": {
        "example": {
          "proof_height": {
            "revision_height": "revision_height",
            "revision_number": "revision_number"
          },
          "consensus_state": {
            "value": "value",
            "type_url": "type_url"
          },
          "proof": "proof"
        },
        "properties": {
          "consensus_state": {
            "$ref": "#/components/schemas/consensus_state_associated_with_the_client_identifier_at_the_given_height"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/Height_is_a_monotonically_increasing_data_type_that_can_be_compared_against_another_Height_for_the_purposes_of_updating_and_freezing_clients"
          }
        },
        "title": "QueryConsensusStateResponse is the response type for the Query/ConsensusState\nRPC method",
        "type": "object"
      },
      "ClientParams_200_response_params": {
        "description": "params defines the parameters of the module.",
        "example": {
          "allowed_clients": ["allowed_clients", "allowed_clients"]
        },
        "properties": {
          "allowed_clients": {
            "description": "allowed_clients defines the list of allowed client state types which can be created\nand interacted with. If a client type is removed from the allowed clients list, usage\nof this client will be disabled until it is added again to the list.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "ClientParams_200_response": {
        "description": "QueryClientParamsResponse is the response type for the Query/ClientParams RPC\nmethod.",
        "example": {
          "params": {
            "allowed_clients": ["allowed_clients", "allowed_clients"]
          }
        },
        "properties": {
          "params": {
            "$ref": "#/components/schemas/ClientParams_200_response_params"
          }
        },
        "type": "object"
      },
      "UpgradedClientState_200_response": {
        "description": "QueryUpgradedClientStateResponse is the response type for the\nQuery/UpgradedClientState RPC method.",
        "example": {
          "upgraded_client_state": {
            "value": "value",
            "type_url": "type_url"
          }
        },
        "properties": {
          "upgraded_client_state": {
            "$ref": "#/components/schemas/client_state_associated_with_the_request_identifier"
          }
        },
        "type": "object"
      },
      "Consensus_state_associated_with_the_request_identifier": {
        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
        "example": {
          "value": "value",
          "type_url": "type_url"
        },
        "properties": {
          "type_url": {
            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
            "type": "string"
          },
          "value": {
            "description": "Must be a valid serialized protocol buffer of the above specified type.",
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string"
          }
        },
        "title": "Consensus state associated with the request identifier",
        "type": "object"
      },
      "UpgradedConsensusState_200_response": {
        "description": "QueryUpgradedConsensusStateResponse is the response type for the\nQuery/UpgradedConsensusState RPC method.",
        "example": {
          "upgraded_consensus_state": {
            "value": "value",
            "type_url": "type_url"
          }
        },
        "properties": {
          "upgraded_consensus_state": {
            "$ref": "#/components/schemas/Consensus_state_associated_with_the_request_identifier"
          }
        },
        "type": "object"
      },
      "height_at_which_the_proof_was_generated": {
        "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset",
        "example": {
          "revision_height": "revision_height",
          "revision_number": "revision_number"
        },
        "properties": {
          "revision_number": {
            "format": "uint64",
            "title": "the revision that the client is currently on",
            "type": "string"
          },
          "revision_height": {
            "format": "uint64",
            "title": "the height within the given revision",
            "type": "string"
          }
        },
        "title": "height at which the proof was generated",
        "type": "object"
      },
      "QueryClientConnectionsResponse_is_the_response_type_for_the_Query_ClientConnections_RPC_method": {
        "example": {
          "connection_paths": ["connection_paths", "connection_paths"],
          "proof_height": {
            "revision_height": "revision_height",
            "revision_number": "revision_number"
          },
          "proof": "proof"
        },
        "properties": {
          "connection_paths": {
            "description": "slice of all the connection paths associated with a client.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/height_at_which_the_proof_was_generated"
          }
        },
        "title": "QueryClientConnectionsResponse is the response type for the\nQuery/ClientConnections RPC method",
        "type": "object"
      },
      "IBC_version_which_can_be_utilised_to_determine_encodings_or_protocols_for_channels_or_packets_utilising_this_connection_inner": {
        "description": "Version defines the versioning scheme used to negotiate the IBC verison in\nthe connection handshake.",
        "example": {
          "identifier": "identifier",
          "features": ["features", "features"]
        },
        "properties": {
          "identifier": {
            "title": "unique version identifier",
            "type": "string"
          },
          "features": {
            "items": {
              "type": "string"
            },
            "title": "list of features compatible with the specified identifier",
            "type": "array"
          }
        },
        "type": "object"
      },
      "MerklePrefix_is_merkle_path_prefixed_to_the_key__The_constructed_key_from_the_Path_and_the_key_will_be_append_Path_KeyPath__append_Path_KeyPrefix__key_____": {
        "description": "commitment merkle prefix of the counterparty chain.",
        "example": {
          "key_prefix": "key_prefix"
        },
        "properties": {
          "key_prefix": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string"
          }
        },
        "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath,\nappend(Path.KeyPrefix, key...))",
        "type": "object"
      },
      "Connections_200_response_connections_inner_counterparty": {
        "description": "counterparty chain associated with this connection.",
        "example": {
          "connection_id": "connection_id",
          "prefix": {
            "key_prefix": "key_prefix"
          },
          "client_id": "client_id"
        },
        "properties": {
          "client_id": {
            "description": "identifies the client on the counterparty chain associated with a given\nconnection.",
            "type": "string"
          },
          "connection_id": {
            "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection.",
            "type": "string"
          },
          "prefix": {
            "$ref": "#/components/schemas/MerklePrefix_is_merkle_path_prefixed_to_the_key__The_constructed_key_from_the_Path_and_the_key_will_be_append_Path_KeyPath__append_Path_KeyPrefix__key_____"
          }
        },
        "type": "object"
      },
      "Connections_200_response_connections_inner": {
        "description": "IdentifiedConnection defines a connection with additional connection\nidentifier field.",
        "example": {
          "versions": [
            {
              "identifier": "identifier",
              "features": ["features", "features"]
            },
            {
              "identifier": "identifier",
              "features": ["features", "features"]
            }
          ],
          "delay_period": "delay_period",
          "counterparty": {
            "connection_id": "connection_id",
            "prefix": {
              "key_prefix": "key_prefix"
            },
            "client_id": "client_id"
          },
          "id": "id",
          "state": "STATE_UNINITIALIZED_UNSPECIFIED",
          "client_id": "client_id"
        },
        "properties": {
          "id": {
            "description": "connection identifier.",
            "type": "string"
          },
          "client_id": {
            "description": "client associated with this connection.",
            "type": "string"
          },
          "versions": {
            "items": {
              "$ref": "#/components/schemas/IBC_version_which_can_be_utilised_to_determine_encodings_or_protocols_for_channels_or_packets_utilising_this_connection_inner"
            },
            "title": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection",
            "type": "array"
          },
          "state": {
            "default": "STATE_UNINITIALIZED_UNSPECIFIED",
            "description": "current state of the connection end.",
            "enum": [
              "STATE_UNINITIALIZED_UNSPECIFIED",
              "STATE_INIT",
              "STATE_TRYOPEN",
              "STATE_OPEN"
            ],
            "type": "string"
          },
          "counterparty": {
            "$ref": "#/components/schemas/Connections_200_response_connections_inner_counterparty"
          },
          "delay_period": {
            "description": "delay period associated with this connection.",
            "format": "uint64",
            "type": "string"
          }
        },
        "type": "object"
      },
      "query_block_height": {
        "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset",
        "example": {
          "revision_height": "revision_height",
          "revision_number": "revision_number"
        },
        "properties": {
          "revision_number": {
            "format": "uint64",
            "title": "the revision that the client is currently on",
            "type": "string"
          },
          "revision_height": {
            "format": "uint64",
            "title": "the height within the given revision",
            "type": "string"
          }
        },
        "title": "query block height",
        "type": "object"
      },
      "Connections_200_response": {
        "description": "QueryConnectionsResponse is the response type for the Query/Connections RPC\nmethod.",
        "example": {
          "pagination": {
            "total": "total",
            "next_key": "next_key"
          },
          "connections": [
            {
              "versions": [
                {
                  "identifier": "identifier",
                  "features": ["features", "features"]
                },
                {
                  "identifier": "identifier",
                  "features": ["features", "features"]
                }
              ],
              "delay_period": "delay_period",
              "counterparty": {
                "connection_id": "connection_id",
                "prefix": {
                  "key_prefix": "key_prefix"
                },
                "client_id": "client_id"
              },
              "id": "id",
              "state": "STATE_UNINITIALIZED_UNSPECIFIED",
              "client_id": "client_id"
            },
            {
              "versions": [
                {
                  "identifier": "identifier",
                  "features": ["features", "features"]
                },
                {
                  "identifier": "identifier",
                  "features": ["features", "features"]
                }
              ],
              "delay_period": "delay_period",
              "counterparty": {
                "connection_id": "connection_id",
                "prefix": {
                  "key_prefix": "key_prefix"
                },
                "client_id": "client_id"
              },
              "id": "id",
              "state": "STATE_UNINITIALIZED_UNSPECIFIED",
              "client_id": "client_id"
            }
          ],
          "height": {
            "revision_height": "revision_height",
            "revision_number": "revision_number"
          }
        },
        "properties": {
          "connections": {
            "description": "list of stored connections of the chain.",
            "items": {
              "$ref": "#/components/schemas/Connections_200_response_connections_inner"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/pagination_response"
          },
          "height": {
            "$ref": "#/components/schemas/query_block_height"
          }
        },
        "type": "object"
      },
      "connection_associated_with_the_request_identifier": {
        "description": "ConnectionEnd defines a stateful object on a chain connected to another\nseparate one.\nNOTE: there must only be 2 defined ConnectionEnds to establish\na connection between two chains.",
        "example": {
          "versions": [
            {
              "identifier": "identifier",
              "features": ["features", "features"]
            },
            {
              "identifier": "identifier",
              "features": ["features", "features"]
            }
          ],
          "delay_period": "delay_period",
          "counterparty": {
            "connection_id": "connection_id",
            "prefix": {
              "key_prefix": "key_prefix"
            },
            "client_id": "client_id"
          },
          "state": "STATE_UNINITIALIZED_UNSPECIFIED",
          "client_id": "client_id"
        },
        "properties": {
          "client_id": {
            "description": "client associated with this connection.",
            "type": "string"
          },
          "versions": {
            "description": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection.",
            "items": {
              "$ref": "#/components/schemas/IBC_version_which_can_be_utilised_to_determine_encodings_or_protocols_for_channels_or_packets_utilising_this_connection_inner"
            },
            "type": "array"
          },
          "state": {
            "default": "STATE_UNINITIALIZED_UNSPECIFIED",
            "description": "current state of the connection end.",
            "enum": [
              "STATE_UNINITIALIZED_UNSPECIFIED",
              "STATE_INIT",
              "STATE_TRYOPEN",
              "STATE_OPEN"
            ],
            "type": "string"
          },
          "counterparty": {
            "$ref": "#/components/schemas/Connections_200_response_connections_inner_counterparty"
          },
          "delay_period": {
            "description": "delay period that must pass before a consensus state can be used for\npacket-verification NOTE: delay period logic is only implemented by some\nclients.",
            "format": "uint64",
            "type": "string"
          }
        },
        "title": "connection associated with the request identifier",
        "type": "object"
      },
      "Connection_200_response": {
        "description": "QueryConnectionResponse is the response type for the Query/Connection RPC\nmethod. Besides the connection end, it includes a proof and the height from\nwhich the proof was retrieved.",
        "example": {
          "proof_height": {
            "revision_height": "revision_height",
            "revision_number": "revision_number"
          },
          "connection": {
            "versions": [
              {
                "identifier": "identifier",
                "features": ["features", "features"]
              },
              {
                "identifier": "identifier",
                "features": ["features", "features"]
              }
            ],
            "delay_period": "delay_period",
            "counterparty": {
              "connection_id": "connection_id",
              "prefix": {
                "key_prefix": "key_prefix"
              },
              "client_id": "client_id"
            },
            "state": "STATE_UNINITIALIZED_UNSPECIFIED",
            "client_id": "client_id"
          },
          "proof": "proof"
        },
        "properties": {
          "connection": {
            "$ref": "#/components/schemas/connection_associated_with_the_request_identifier"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/height_at_which_the_proof_was_retrieved"
          }
        },
        "type": "object"
      },
      "client_state_associated_with_the_channel": {
        "description": "IdentifiedClientState defines a client state with an additional client\nidentifier field.",
        "example": {
          "client_state": {
            "value": "value",
            "type_url": "type_url"
          },
          "client_id": "client_id"
        },
        "properties": {
          "client_id": {
            "title": "client identifier",
            "type": "string"
          },
          "client_state": {
            "$ref": "#/components/schemas/client_state"
          }
        },
        "title": "client state associated with the channel",
        "type": "object"
      },
      "QueryConnectionClientStateResponse_is_the_response_type_for_the_Query_ConnectionClientState_RPC_method": {
        "example": {
          "identified_client_state": {
            "client_state": {
              "value": "value",
              "type_url": "type_url"
            },
            "client_id": "client_id"
          },
          "proof_height": {
            "revision_height": "revision_height",
            "revision_number": "revision_number"
          },
          "proof": "proof"
        },
        "properties": {
          "identified_client_state": {
            "$ref": "#/components/schemas/client_state_associated_with_the_channel"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/height_at_which_the_proof_was_retrieved"
          }
        },
        "title": "QueryConnectionClientStateResponse is the response type for the\nQuery/ConnectionClientState RPC method",
        "type": "object"
      },
      "consensus_state_associated_with_the_channel": {
        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
        "example": {
          "value": "value",
          "type_url": "type_url"
        },
        "properties": {
          "type_url": {
            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
            "type": "string"
          },
          "value": {
            "description": "Must be a valid serialized protocol buffer of the above specified type.",
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string"
          }
        },
        "title": "consensus state associated with the channel",
        "type": "object"
      },
      "QueryConnectionConsensusStateResponse_is_the_response_type_for_the_Query_ConnectionConsensusState_RPC_method": {
        "example": {
          "proof_height": {
            "revision_height": "revision_height",
            "revision_number": "revision_number"
          },
          "consensus_state": {
            "value": "value",
            "type_url": "type_url"
          },
          "proof": "proof",
          "client_id": "client_id"
        },
        "properties": {
          "consensus_state": {
            "$ref": "#/components/schemas/consensus_state_associated_with_the_channel"
          },
          "client_id": {
            "title": "client ID associated with the consensus state",
            "type": "string"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/height_at_which_the_proof_was_retrieved"
          }
        },
        "title": "QueryConnectionConsensusStateResponse is the response type for the\nQuery/ConnectionConsensusState RPC method",
        "type": "object"
      },
      "ConnectionParams_200_response_params": {
        "description": "params defines the parameters of the module.",
        "example": {
          "max_expected_time_per_block": "max_expected_time_per_block"
        },
        "properties": {
          "max_expected_time_per_block": {
            "description": "maximum expected time per block (in nanoseconds), used to enforce block delay. This parameter should reflect the\nlargest amount of time that the chain might reasonably take to produce the next block under normal operating\nconditions. A safe choice is 3-5x the expected time per block.",
            "format": "uint64",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ConnectionParams_200_response": {
        "description": "QueryConnectionParamsResponse is the response type for the Query/ConnectionParams RPC method.",
        "example": {
          "params": {
            "max_expected_time_per_block": "max_expected_time_per_block"
          }
        },
        "properties": {
          "params": {
            "$ref": "#/components/schemas/ConnectionParams_200_response_params"
          }
        },
        "type": "object"
      },
      "counterparty_channel_end": {
        "example": {
          "port_id": "port_id",
          "channel_id": "channel_id"
        },
        "properties": {
          "port_id": {
            "description": "port on the counterparty chain which owns the other end of the channel.",
            "type": "string"
          },
          "channel_id": {
            "title": "channel end on the counterparty chain",
            "type": "string"
          }
        },
        "title": "counterparty channel end",
        "type": "object"
      },
      "Channels_200_response_channels_inner": {
        "description": "IdentifiedChannel defines a channel with additional port and channel\nidentifier fields.",
        "example": {
          "connection_hops": ["connection_hops", "connection_hops"],
          "ordering": "ORDER_NONE_UNSPECIFIED",
          "counterparty": {
            "port_id": "port_id",
            "channel_id": "channel_id"
          },
          "port_id": "port_id",
          "state": "STATE_UNINITIALIZED_UNSPECIFIED",
          "version": "version",
          "channel_id": "channel_id"
        },
        "properties": {
          "state": {
            "default": "STATE_UNINITIALIZED_UNSPECIFIED",
            "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets.",
            "enum": [
              "STATE_UNINITIALIZED_UNSPECIFIED",
              "STATE_INIT",
              "STATE_TRYOPEN",
              "STATE_OPEN",
              "STATE_CLOSED"
            ],
            "title": "current state of the channel end",
            "type": "string"
          },
          "ordering": {
            "default": "ORDER_NONE_UNSPECIFIED",
            "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent",
            "enum": ["ORDER_NONE_UNSPECIFIED", "ORDER_UNORDERED", "ORDER_ORDERED"],
            "title": "whether the channel is ordered or unordered",
            "type": "string"
          },
          "counterparty": {
            "$ref": "#/components/schemas/counterparty_channel_end"
          },
          "connection_hops": {
            "items": {
              "type": "string"
            },
            "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel",
            "type": "array"
          },
          "version": {
            "title": "opaque channel version, which is agreed upon during the handshake",
            "type": "string"
          },
          "port_id": {
            "title": "port identifier",
            "type": "string"
          },
          "channel_id": {
            "title": "channel identifier",
            "type": "string"
          }
        },
        "type": "object"
      },
      "Channels_200_response": {
        "description": "QueryChannelsResponse is the response type for the Query/Channels RPC method.",
        "example": {
          "pagination": {
            "total": "total",
            "next_key": "next_key"
          },
          "channels": [
            {
              "connection_hops": ["connection_hops", "connection_hops"],
              "ordering": "ORDER_NONE_UNSPECIFIED",
              "counterparty": {
                "port_id": "port_id",
                "channel_id": "channel_id"
              },
              "port_id": "port_id",
              "state": "STATE_UNINITIALIZED_UNSPECIFIED",
              "version": "version",
              "channel_id": "channel_id"
            },
            {
              "connection_hops": ["connection_hops", "connection_hops"],
              "ordering": "ORDER_NONE_UNSPECIFIED",
              "counterparty": {
                "port_id": "port_id",
                "channel_id": "channel_id"
              },
              "port_id": "port_id",
              "state": "STATE_UNINITIALIZED_UNSPECIFIED",
              "version": "version",
              "channel_id": "channel_id"
            }
          ],
          "height": {
            "revision_height": "revision_height",
            "revision_number": "revision_number"
          }
        },
        "properties": {
          "channels": {
            "description": "list of stored channels of the chain.",
            "items": {
              "$ref": "#/components/schemas/Channels_200_response_channels_inner"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/pagination_response"
          },
          "height": {
            "$ref": "#/components/schemas/query_block_height"
          }
        },
        "type": "object"
      },
      "channel_associated_with_the_request_identifiers": {
        "description": "Channel defines pipeline for exactly-once packet delivery between specific\nmodules on separate blockchains, which has at least one end capable of\nsending packets and one end capable of receiving packets.",
        "example": {
          "connection_hops": ["connection_hops", "connection_hops"],
          "ordering": "ORDER_NONE_UNSPECIFIED",
          "counterparty": {
            "port_id": "port_id",
            "channel_id": "channel_id"
          },
          "state": "STATE_UNINITIALIZED_UNSPECIFIED",
          "version": "version"
        },
        "properties": {
          "state": {
            "default": "STATE_UNINITIALIZED_UNSPECIFIED",
            "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets.",
            "enum": [
              "STATE_UNINITIALIZED_UNSPECIFIED",
              "STATE_INIT",
              "STATE_TRYOPEN",
              "STATE_OPEN",
              "STATE_CLOSED"
            ],
            "title": "current state of the channel end",
            "type": "string"
          },
          "ordering": {
            "default": "ORDER_NONE_UNSPECIFIED",
            "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent",
            "enum": ["ORDER_NONE_UNSPECIFIED", "ORDER_UNORDERED", "ORDER_ORDERED"],
            "title": "whether the channel is ordered or unordered",
            "type": "string"
          },
          "counterparty": {
            "$ref": "#/components/schemas/counterparty_channel_end"
          },
          "connection_hops": {
            "items": {
              "type": "string"
            },
            "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel",
            "type": "array"
          },
          "version": {
            "title": "opaque channel version, which is agreed upon during the handshake",
            "type": "string"
          }
        },
        "title": "channel associated with the request identifiers",
        "type": "object"
      },
      "Channel_200_response": {
        "description": "QueryChannelResponse is the response type for the Query/Channel RPC method.\nBesides the Channel end, it includes a proof and the height from which the\nproof was retrieved.",
        "example": {
          "proof_height": {
            "revision_height": "revision_height",
            "revision_number": "revision_number"
          },
          "channel": {
            "connection_hops": ["connection_hops", "connection_hops"],
            "ordering": "ORDER_NONE_UNSPECIFIED",
            "counterparty": {
              "port_id": "port_id",
              "channel_id": "channel_id"
            },
            "state": "STATE_UNINITIALIZED_UNSPECIFIED",
            "version": "version"
          },
          "proof": "proof"
        },
        "properties": {
          "channel": {
            "$ref": "#/components/schemas/channel_associated_with_the_request_identifiers"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/height_at_which_the_proof_was_retrieved"
          }
        },
        "type": "object"
      },
      "QueryChannelClientStateResponse_is_the_Response_type_for_the_Query_QueryChannelClientState_RPC_method": {
        "example": {
          "identified_client_state": {
            "client_state": {
              "value": "value",
              "type_url": "type_url"
            },
            "client_id": "client_id"
          },
          "proof_height": {
            "revision_height": "revision_height",
            "revision_number": "revision_number"
          },
          "proof": "proof"
        },
        "properties": {
          "identified_client_state": {
            "$ref": "#/components/schemas/client_state_associated_with_the_channel"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/height_at_which_the_proof_was_retrieved"
          }
        },
        "title": "QueryChannelClientStateResponse is the Response type for the\nQuery/QueryChannelClientState RPC method",
        "type": "object"
      },
      "QueryChannelClientStateResponse_is_the_Response_type_for_the_Query_QueryChannelClientState_RPC_method_1": {
        "example": {
          "proof_height": {
            "revision_height": "revision_height",
            "revision_number": "revision_number"
          },
          "consensus_state": {
            "value": "value",
            "type_url": "type_url"
          },
          "proof": "proof",
          "client_id": "client_id"
        },
        "properties": {
          "consensus_state": {
            "$ref": "#/components/schemas/consensus_state_associated_with_the_channel"
          },
          "client_id": {
            "title": "client ID associated with the consensus state",
            "type": "string"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/height_at_which_the_proof_was_retrieved"
          }
        },
        "title": "QueryChannelClientStateResponse is the Response type for the\nQuery/QueryChannelClientState RPC method",
        "type": "object"
      },
      "QuerySequenceResponse_is_the_request_type_for_the_Query_QueryNextSequenceReceiveResponse_RPC_method": {
        "example": {
          "next_sequence_receive": "next_sequence_receive",
          "proof_height": {
            "revision_height": "revision_height",
            "revision_number": "revision_number"
          },
          "proof": "proof"
        },
        "properties": {
          "next_sequence_receive": {
            "format": "uint64",
            "title": "next sequence receive number",
            "type": "string"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/height_at_which_the_proof_was_retrieved"
          }
        },
        "title": "QuerySequenceResponse is the request type for the\nQuery/QueryNextSequenceReceiveResponse RPC method",
        "type": "object"
      },
      "QueryNextSequenceSendResponse_is_the_request_type_for_the_Query_QueryNextSequenceSend_RPC_method": {
        "example": {
          "proof_height": {
            "revision_height": "revision_height",
            "revision_number": "revision_number"
          },
          "proof": "proof",
          "next_sequence_send": "next_sequence_send"
        },
        "properties": {
          "next_sequence_send": {
            "format": "uint64",
            "title": "next sequence send number",
            "type": "string"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/height_at_which_the_proof_was_retrieved"
          }
        },
        "title": "QueryNextSequenceSendResponse is the request type for the\nQuery/QueryNextSequenceSend RPC method",
        "type": "object"
      },
      "QueryPacketAcknowledgemetsResponse_is_the_request_type_for_the_Query_QueryPacketAcknowledgements_RPC_method_acknowledgements_inner": {
        "description": "PacketState defines the generic type necessary to retrieve and store\npacket commitments, acknowledgements, and receipts.\nCaller is responsible for knowing the context necessary to interpret this\nstate as a commitment, acknowledgement, or a receipt.",
        "example": {
          "sequence": "sequence",
          "data": "data",
          "port_id": "port_id",
          "channel_id": "channel_id"
        },
        "properties": {
          "port_id": {
            "description": "channel port identifier.",
            "type": "string"
          },
          "channel_id": {
            "description": "channel unique identifier.",
            "type": "string"
          },
          "sequence": {
            "description": "packet sequence.",
            "format": "uint64",
            "type": "string"
          },
          "data": {
            "description": "embedded data that represents packet state.",
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string"
          }
        },
        "type": "object"
      },
      "QueryPacketAcknowledgemetsResponse_is_the_request_type_for_the_Query_QueryPacketAcknowledgements_RPC_method": {
        "example": {
          "pagination": {
            "total": "total",
            "next_key": "next_key"
          },
          "acknowledgements": [
            {
              "sequence": "sequence",
              "data": "data",
              "port_id": "port_id",
              "channel_id": "channel_id"
            },
            {
              "sequence": "sequence",
              "data": "data",
              "port_id": "port_id",
              "channel_id": "channel_id"
            }
          ],
          "height": {
            "revision_height": "revision_height",
            "revision_number": "revision_number"
          }
        },
        "properties": {
          "acknowledgements": {
            "items": {
              "$ref": "#/components/schemas/QueryPacketAcknowledgemetsResponse_is_the_request_type_for_the_Query_QueryPacketAcknowledgements_RPC_method_acknowledgements_inner"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/pagination_response"
          },
          "height": {
            "$ref": "#/components/schemas/query_block_height"
          }
        },
        "title": "QueryPacketAcknowledgemetsResponse is the request type for the\nQuery/QueryPacketAcknowledgements RPC method",
        "type": "object"
      },
      "QueryPacketAcknowledgementResponse_defines_the_client_query_response_for_a_packet_which_also_includes_a_proof_and_the_height_from_which_the_proof_was_retrieved": {
        "example": {
          "acknowledgement": "acknowledgement",
          "proof_height": {
            "revision_height": "revision_height",
            "revision_number": "revision_number"
          },
          "proof": "proof"
        },
        "properties": {
          "acknowledgement": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "packet associated with the request fields",
            "type": "string"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/height_at_which_the_proof_was_retrieved"
          }
        },
        "title": "QueryPacketAcknowledgementResponse defines the client query response for a\npacket which also includes a proof and the height from which the\nproof was retrieved",
        "type": "object"
      },
      "QueryPacketCommitmentsResponse_is_the_request_type_for_the_Query_QueryPacketCommitments_RPC_method": {
        "example": {
          "commitments": [
            {
              "sequence": "sequence",
              "data": "data",
              "port_id": "port_id",
              "channel_id": "channel_id"
            },
            {
              "sequence": "sequence",
              "data": "data",
              "port_id": "port_id",
              "channel_id": "channel_id"
            }
          ],
          "pagination": {
            "total": "total",
            "next_key": "next_key"
          },
          "height": {
            "revision_height": "revision_height",
            "revision_number": "revision_number"
          }
        },
        "properties": {
          "commitments": {
            "items": {
              "$ref": "#/components/schemas/QueryPacketAcknowledgemetsResponse_is_the_request_type_for_the_Query_QueryPacketAcknowledgements_RPC_method_acknowledgements_inner"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/pagination_response"
          },
          "height": {
            "$ref": "#/components/schemas/query_block_height"
          }
        },
        "title": "QueryPacketCommitmentsResponse is the request type for the\nQuery/QueryPacketCommitments RPC method",
        "type": "object"
      },
      "QueryUnreceivedAcksResponse_is_the_response_type_for_the_Query_UnreceivedAcks_RPC_method": {
        "example": {
          "sequences": ["sequences", "sequences"],
          "height": {
            "revision_height": "revision_height",
            "revision_number": "revision_number"
          }
        },
        "properties": {
          "sequences": {
            "items": {
              "format": "uint64",
              "type": "string"
            },
            "title": "list of unreceived acknowledgement sequences",
            "type": "array"
          },
          "height": {
            "$ref": "#/components/schemas/query_block_height"
          }
        },
        "title": "QueryUnreceivedAcksResponse is the response type for the\nQuery/UnreceivedAcks RPC method",
        "type": "object"
      },
      "QueryUnreceivedPacketsResponse_is_the_response_type_for_the_Query_UnreceivedPacketCommitments_RPC_method": {
        "example": {
          "sequences": ["sequences", "sequences"],
          "height": {
            "revision_height": "revision_height",
            "revision_number": "revision_number"
          }
        },
        "properties": {
          "sequences": {
            "items": {
              "format": "uint64",
              "type": "string"
            },
            "title": "list of unreceived packet sequences",
            "type": "array"
          },
          "height": {
            "$ref": "#/components/schemas/query_block_height"
          }
        },
        "title": "QueryUnreceivedPacketsResponse is the response type for the\nQuery/UnreceivedPacketCommitments RPC method",
        "type": "object"
      },
      "QueryPacketCommitmentResponse_defines_the_client_query_response_for_a_packet_which_also_includes_a_proof_and_the_height_from_which_the_proof_was_retrieved": {
        "example": {
          "proof_height": {
            "revision_height": "revision_height",
            "revision_number": "revision_number"
          },
          "commitment": "commitment",
          "proof": "proof"
        },
        "properties": {
          "commitment": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "packet associated with the request fields",
            "type": "string"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/height_at_which_the_proof_was_retrieved"
          }
        },
        "title": "QueryPacketCommitmentResponse defines the client query response for a packet\nwhich also includes a proof and the height from which the proof was\nretrieved",
        "type": "object"
      },
      "QueryPacketReceiptResponse_defines_the_client_query_response_for_a_packet_receipt_which_also_includes_a_proof__and_the_height_from_which_the_proof_was_retrieved": {
        "example": {
          "proof_height": {
            "revision_height": "revision_height",
            "revision_number": "revision_number"
          },
          "received": true,
          "proof": "proof"
        },
        "properties": {
          "received": {
            "title": "success flag for if receipt exists",
            "type": "boolean"
          },
          "proof": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "title": "merkle proof of existence",
            "type": "string"
          },
          "proof_height": {
            "$ref": "#/components/schemas/height_at_which_the_proof_was_retrieved"
          }
        },
        "title": "QueryPacketReceiptResponse defines the client query response for a packet\nreceipt which also includes a proof, and the height from which the proof was\nretrieved",
        "type": "object"
      },
      "QueryConnectionChannelsResponse_is_the_Response_type_for_the_Query_QueryConnectionChannels_RPC_method": {
        "example": {
          "pagination": {
            "total": "total",
            "next_key": "next_key"
          },
          "channels": [
            {
              "connection_hops": ["connection_hops", "connection_hops"],
              "ordering": "ORDER_NONE_UNSPECIFIED",
              "counterparty": {
                "port_id": "port_id",
                "channel_id": "channel_id"
              },
              "port_id": "port_id",
              "state": "STATE_UNINITIALIZED_UNSPECIFIED",
              "version": "version",
              "channel_id": "channel_id"
            },
            {
              "connection_hops": ["connection_hops", "connection_hops"],
              "ordering": "ORDER_NONE_UNSPECIFIED",
              "counterparty": {
                "port_id": "port_id",
                "channel_id": "channel_id"
              },
              "port_id": "port_id",
              "state": "STATE_UNINITIALIZED_UNSPECIFIED",
              "version": "version",
              "channel_id": "channel_id"
            }
          ],
          "height": {
            "revision_height": "revision_height",
            "revision_number": "revision_number"
          }
        },
        "properties": {
          "channels": {
            "description": "list of channels associated with a connection.",
            "items": {
              "$ref": "#/components/schemas/Channels_200_response_channels_inner"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/pagination_response"
          },
          "height": {
            "$ref": "#/components/schemas/query_block_height"
          }
        },
        "title": "QueryConnectionChannelsResponse is the Response type for the\nQuery/QueryConnectionChannels RPC method",
        "type": "object"
      },
      "CodeHashes_200_response_pagination": {
        "description": "pagination defines an optional pagination for the request.",
        "example": {
          "total": "total",
          "next_key": "next_key"
        },
        "properties": {
          "next_key": {
            "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string"
          },
          "total": {
            "format": "uint64",
            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
            "type": "string"
          }
        },
        "type": "object"
      },
      "CodeHashes_200_response": {
        "description": "QueryCodeHashesResponse is the response type for the Query/CodeHashes RPC method.",
        "example": {
          "code_hashes": ["code_hashes", "code_hashes"],
          "pagination": {
            "total": "total",
            "next_key": "next_key"
          }
        },
        "properties": {
          "code_hashes": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/CodeHashes_200_response_pagination"
          }
        },
        "type": "object"
      },
      "Code_200_response": {
        "description": "QueryCodeResponse is the response type for the Query/Code RPC method.",
        "example": {
          "data": "data"
        },
        "properties": {
          "data": {
            "format": "byte",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string"
          }
        },
        "type": "object"
      }
    }
  }
}
